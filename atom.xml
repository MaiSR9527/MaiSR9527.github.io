<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>maiBlog</title>
  
  <subtitle>maishuren blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.maishuren.top/"/>
  <updated>2020-06-18T15:55:47.066Z</updated>
  <id>http://www.maishuren.top/</id>
  
  <author>
    <name>maishuren</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang学习十四：golang中的面向对象</title>
    <link href="http://www.maishuren.top/posts/golang/202006182355-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006182355-index.html</id>
    <published>2020-06-18T15:55:09.000Z</published>
    <updated>2020-06-18T15:55:47.066Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十三：结构体</title>
    <link href="http://www.maishuren.top/posts/golang/202006182349-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006182349-index.html</id>
    <published>2020-06-18T15:49:04.000Z</published>
    <updated>2020-06-18T15:54:22.418Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ul><li>结构体解释:将一个或多个变量组合到一起,形成新的类型.这个类型就是结构体</li><li>Go语言中的结构体和C++结构体有点类似,而Java或C#中类本质就是结构体</li><li>结构体是值类型</li><li>结构体定义语法<ul><li>通过语法可以看出,Go语言发明者明确认为结构体就是一种自定义类型<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名称 <span class="keyword">struct</span>&#123;</span><br><span class="line">  名称 类型<span class="comment">//成员或属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li><p>定义结构体</p><ul><li>结构体可以定义在函数内部或函数外部(与普通变量一样),定义位置影响到结构体的访问范围</li><li>如果结构体定义在函数外面,结构体名称首字母是否大写影响到结构体是否能跨包访问</li><li>如果结构体能跨包访问,属性首字母是否大写影响到属性是否跨包访问<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>声明结构体变量</p><ul><li>由于结构体是值类型,所以声明后就会开辟内存空间</li><li>所有成员为类型对应的初始值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peo People</span><br><span class="line">fmt.Print(peo)<span class="comment">//输出:&#123;0 &#125;</span></span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>,&amp;peo)<span class="comment">//会打印内存地址值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>可以直接给结构体多个属性赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peo People</span><br><span class="line"><span class="comment">//按照结构体中属性的顺序进行赋值,可以省略属性名称</span></span><br><span class="line">peo = People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line">fmt.Println(peo)</span><br><span class="line"><span class="comment">//明确指定给哪些属性赋值.可以都赋值,也可以只给其中一部分赋值</span></span><br><span class="line">peo = People&#123;Age: <span class="number">18</span>, Name: <span class="string">"maishuren"</span>&#125;</span><br><span class="line">fmt.Println(peo)</span><br></pre></td></tr></table></figure></li><li><p>也可以通过结构体变量名称获取到属性进行赋值或查看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peo People</span><br><span class="line">peo.Name=<span class="string">"msr"</span></span><br><span class="line">peo.Age=<span class="number">17</span></span><br><span class="line">fmt.Println(peo)</span><br><span class="line">fmt.Println(peo.Name)</span><br><span class="line">fmt.Println(peo.Age)</span><br></pre></td></tr></table></figure><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2></li><li><p>双等(==)判断结构体中内容是否相等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p1 := People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line">p2 := People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>, &amp;p1, &amp;p2) <span class="comment">//输出地址不同</span></span><br><span class="line">fmt.Println(p1 == p2)           <span class="comment">//输出:true</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h1><ul><li>由于结构体是值类型,在方法传递时希望传递结构体地址,可以使用时结构体指针完成</li><li>可以结合new(T)函数创建结构体指针<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">peo := <span class="built_in">new</span>(People)</span><br><span class="line"><span class="comment">//因为结构体本质是值类型,所以创建结构体指针时已经开辟了内存空间</span></span><br><span class="line">fmt.Println(peo == <span class="literal">nil</span>) <span class="comment">//输出:false</span></span><br><span class="line"><span class="comment">//由于结构体中属性并不是指针类型,所以可以直接调用</span></span><br><span class="line">peo.Name = <span class="string">"msr"</span></span><br><span class="line">fmt.Println(peo)<span class="comment">//输出:&amp;&#123;msr 0&#125;</span></span><br><span class="line">peo1:=peo</span><br><span class="line">peo1.Name=<span class="string">"maishuren"</span></span><br><span class="line">fmt.Println(peo1,peo)<span class="comment">//输出:&amp;&#123;maishuren 0&#125; &amp;&#123;maishuren 0&#125;</span></span><br></pre></td></tr></table></figure></li><li>如果不想使用new(T)函数,可以直接声明结构体指针并赋值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明结构体指针</span></span><br><span class="line"><span class="keyword">var</span> peo *People</span><br><span class="line"><span class="comment">//给结构体指针赋值</span></span><br><span class="line">peo = &amp;People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码使用短变量方式如下</span></span><br><span class="line"><span class="comment">peo:= &amp;People&#123;"msr", 17&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fmt.Println(peo)</span><br></pre></td></tr></table></figure><h2 id="判断-1"><a href="#判断-1" class="headerlink" title="判断"></a>判断</h2></li><li>结构体指针比较的是地址</li><li>(*结构体指针)取出地址中对应的值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p1 := People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line">p2 := People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>, &amp;p1, &amp;p2) <span class="comment">//输出地址不同</span></span><br><span class="line">fmt.Println(p1 == p2)           <span class="comment">//输出:true</span></span><br><span class="line"></span><br><span class="line">p3 := <span class="built_in">new</span>(People)</span><br><span class="line">p3 = &amp;People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line"><span class="comment">//结构体变量不能和指针比较,使用*指针取出地址中值</span></span><br><span class="line">fmt.Println(p1 == *p3) <span class="comment">//输出:true</span></span><br><span class="line"></span><br><span class="line">p4 := &amp;People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line"><span class="comment">//指针比较的是地址</span></span><br><span class="line">fmt.Println(p3 == p4) <span class="comment">//输出:false</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul><li><p>方法和函数语法比较像,区别是函数属于包,通过包调用函数,而方法属于结构体,通过结构体变量调用</p></li><li><p>默认是函数,隶属于包,所以需要添加标识.告诉编译器这个方法属性哪个结构体</p><ul><li>调用方法时就把调用者赋值给接收者(下面的变量名就是接受者)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(变量名 结构体类型)</span> 方法名<span class="params">(参数列表)</span> 返回值列表</span>&#123;</span><br><span class="line">  <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Go语言中已经有函数了,又添加了对方法的支持主要是保证Go语言是面向对象的.Go语言官方对面向对象的解释</p><ul><li>翻译如下:虽然面向对象没有统一的定义，但是对于我们来说对象仅仅是一个有着方法的值或变量,而方法就是一个属于特定类型的函数</li></ul><p><img src="images/2_7_3_method.png" alt=""></p></li><li><p>从上面的解释可以看出,官方给出可明确说明,方法类似于函数.方法归属于特定类型</p></li></ul><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li>定义一个People类型结构体,在对People结构体定义个run()方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span><span class="comment">//姓名</span></span><br><span class="line">Weight<span class="keyword">float64</span><span class="comment">//体重.单位斤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p People)</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(p.Name,<span class="string">"正在跑步"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">peo:=People&#123;<span class="string">"张三"</span>,<span class="number">17</span>&#125;</span><br><span class="line">peo.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果设定需求,在每次跑步后体重都减少0.1斤.上面代码就需要修改了.因为结构体是值类型,修改方法中结构体变量p的值,主函数中peo的值不会改变,因为传递的是值副本.所以修改方法中结构体类型为结构体指针类型就可以完成设定需求<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span><span class="comment">//姓名</span></span><br><span class="line">Weight<span class="keyword">float64</span><span class="comment">//体重.单位斤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(p.Name,<span class="string">"正在跑步,体重为:"</span>,p.Weight)<span class="comment">//输出:张三 正在跑步,体重为: 17</span></span><br><span class="line">p.Weight-=<span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">peo:=&amp;People&#123;<span class="string">"张三"</span>,<span class="number">17</span>&#125;</span><br><span class="line">peo.run()</span><br><span class="line">fmt.Println(peo.Name,<span class="string">"跑完步后的体重是"</span>,peo.Weight)<span class="comment">//输出:张三 跑完步后的体重是 16.9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十二：值传递和引用传递</title>
    <link href="http://www.maishuren.top/posts/gloang/202006182347-index.html"/>
    <id>http://www.maishuren.top/posts/gloang/202006182347-index.html</id>
    <published>2020-06-18T15:47:22.000Z</published>
    <updated>2020-06-18T15:48:11.732Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>讨论值传递和引用传递时,其实就是看值类型变量和引用类型变量作为函数参数时,修改形参是否会影响到实参</li><li>在Go语言中五个引用类型变量,其他都是值类型<ul><li>slice</li><li>map</li><li>channel</li><li>interface</li><li>func()</li></ul></li><li>引用类型作为参数时,称为浅拷贝,形参改变,实参数跟随变化.因为传递的是地址,形参和实参都指向同一块地址</li><li>值类型作为参数时,称为深拷贝,形参改变,实参不变,因为传递的是值的副本,形参会新开辟一块空间,与实参指向不同</li><li>如果希望值类型数据在修改形参时实参跟随变化,可以把参数设置为指针类型</li></ul><h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><ul><li>值类型作为参数代码演示<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i <span class="keyword">int</span>, s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">s = <span class="string">"改变"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">s := <span class="string">"原值"</span></span><br><span class="line">demo(i, s)</span><br><span class="line">fmt.Println(i, s) <span class="comment">//输出:1 原值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>引用传递代码示例<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(arg []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   arg[<span class="built_in">len</span>(arg)<span class="number">-1</span>] = <span class="number">110</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">   demo(s)</span><br><span class="line">   fmt.Println(s) <span class="comment">//输出:[1 2 110]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果希望值类型实参跟随形参变化,可以把值类型指针作为参数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//行参指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i *<span class="keyword">int</span>, s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="comment">//需要在变量前面带有*表示指针变量</span></span><br><span class="line">   *i = <span class="number">5</span></span><br><span class="line">   s = <span class="string">"改变"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   i := <span class="number">1</span></span><br><span class="line">   s := <span class="string">"原值"</span></span><br><span class="line">   <span class="comment">//注意此处第一个参数是i的地址,前面&amp;</span></span><br><span class="line">   <span class="comment">//s保留为值类型</span></span><br><span class="line">   demo(&amp;i, s)</span><br><span class="line">   fmt.Println(i, s) <span class="comment">//输出:5 原值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十一：包的访问权限、变量作用域、闭包</title>
    <link href="http://www.maishuren.top/posts/golang/202006182343-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006182343-index.html</id>
    <published>2020-06-18T15:43:23.000Z</published>
    <updated>2020-06-18T15:46:48.644Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="包概述"><a href="#包概述" class="headerlink" title="包概述"></a>包概述</h1><ul><li>包(package)是Go语言中组织单元.包是逻辑上的分组.而物理上的分组是不同的文件夹,文件夹和包一般是对应的</li><li>把多个文件放入同一个文件夹中,这些文件就是在同一个包中.</li><li>虽然允许源码文件的package和文件夹名不同但是最终编译后都会把文件的package编译成文件夹名称.所以为防止错误最好把文件的package和文件夹名称设置成相同的</li><li>一个Go语言项目必须要有main包,其他自定义名称的包个数任意,根据自己的需求即可.</li><li>Go语言在寻找包时会从GOPATH/src 路径中寻找包,如果不存在去GOROOT/src(Go语言标准库源码所在文件夹)下找</li><li>不同包下资源可以相互访问,在导入其他包后,可以访问包下首字母大写的内容</li><li>同包下不同文件中全局资源可以随意访问</li></ul><h1 id="自定义包"><a href="#自定义包" class="headerlink" title="自定义包"></a>自定义包</h1><ul><li>新建项目后在项目下新建src文件夹,在src文件夹中新建demo文件</li><li>在demo文件中新建demo1.go和demo2.go文件</li><li>demo1.go文件源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo<span class="comment">//包为demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"执行demo1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>demo2.go文件源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo<span class="comment">//包为demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo2</span><span class="params">()</span></span>  &#123;<span class="comment">//函数名大写才能被其他包访问</span></span><br><span class="line">fmt.Println(<span class="string">"执行demo2"</span>)</span><br><span class="line">demo1()<span class="comment">//同包下内容任意访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在项目根目录下新建main.go,源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"demo"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">demo.Demo2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行整个项目后,发现可以正常调用Demo2()函数</li><li>整个程序目录结构如下<br><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/project.png" alt=""></li></ul><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><ul><li>变量声明位置决定了变量的可访问范围(哪里能调用到变量)</li><li>Go语言中变量的有效范围如下<ul><li>函数级别:变量声明在函数内部,只有在函数内部才能访问,称变量为局部变量</li><li>package 包级别,在当前包下都可以访问.称变量为全局变量.变量声明在函数外面</li><li>应用级别,在整个应用下任何包内都可以访问.通过首字母大小写控制</li></ul></li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ul><li>局部变量一定是在函数内部</li><li>在哪个{}内部声明,只能在哪个{}内部访问<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">2</span> <span class="comment">//从此处开始到test1结束&#125;任何位置都能调用i</span></span><br><span class="line"><span class="keyword">if</span> i&gt;=<span class="number">2</span>&#123;</span><br><span class="line">j:=<span class="number">3</span></span><br><span class="line">fmt.Println(i+j)<span class="comment">//此处可以访问i</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="comment">//fmt.Println(j)//此处不能调用j,超出声明j时&#123;&#125;外</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(i) <span class="comment">//此处无法调用test1()中的i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2></li><li>全局变量声明到函数外部,整个包都可以访问</li><li>如果全局变量首字母大写,跨包也可以访问.</li><li>声明全局变量时规范是<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">变量名</span><br><span class="line">变量名=值</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>全局变量代码示例<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name = <span class="string">"smallming"</span></span><br><span class="line">age  = <span class="number">17</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"名字:"</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"年龄:"</span>,age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="闭包概述"><a href="#闭包概述" class="headerlink" title="闭包概述"></a>闭包概述</h1><ul><li>闭包不是Go语言独有的概念,在很多编程语言中都有闭包</li><li>闭包就是解决局部变量不能被外部访问一种解决方案</li><li>是把函数当作返回值的一种应用</li></ul><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><ul><li>总体思想为:在函数内部定义局部变量,把另一个函数当作返回值,局部变量对于返回值函数就相当于全局变量,所以多次调用返回值函数局部变量的值跟随变化<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//res其实就是test1返回值函数,和之前匿名函数变量一个道理</span></span><br><span class="line">res := test1()</span><br><span class="line">fmt.Println(res()) <span class="comment">//输出2</span></span><br><span class="line">fmt.Println(res()) <span class="comment">//输出3</span></span><br><span class="line">fmt.Println(res()) <span class="comment">//输出4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意此处,返回值类型是func int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果重新调用test1()会重新声明及赋值局部变量i<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := test1()</span><br><span class="line">fmt.Println(<span class="string">"f的地址"</span>, f) <span class="comment">//输出匿名函数地址</span></span><br><span class="line">fmt.Println(<span class="string">"f:"</span>, f()) <span class="comment">//调用匿名函数输出2</span></span><br><span class="line">fmt.Println(<span class="string">"f:"</span>, f()) <span class="comment">//调用匿名函数输出3</span></span><br><span class="line">k := test1()</span><br><span class="line">fmt.Println(<span class="string">"k的地址"</span>, k) <span class="comment">//输出匿名函数地址,与f相等</span></span><br><span class="line">fmt.Println(<span class="string">"k:"</span>, k()) <span class="comment">//调用匿名函数输出2</span></span><br><span class="line">fmt.Println(<span class="string">"f:"</span>, f()) <span class="comment">//输出:4</span></span><br><span class="line">fmt.Println(<span class="string">"k:"</span>, k()) <span class="comment">//输出:3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i++</span><br><span class="line"><span class="comment">// 每调用一次test1()输出的地址不一样</span></span><br><span class="line">fmt.Println(<span class="string">"i的地址:"</span>, &amp;i)</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十：函数</title>
    <link href="http://www.maishuren.top/posts/golang/202006182334-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006182334-index.html</id>
    <published>2020-06-18T15:34:22.000Z</published>
    <updated>2020-06-18T15:42:38.878Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>函数:一段代码块</li><li>所有的流程控制代码和业务代码都只能写在函数内部</li><li>为什么使用函数:<ul><li>把一个功能提出作为一个函数便于后期维护,结构清晰</li></ul></li><li>函数声明的语法<ul><li>函数声明后不会执行,必须调用后才会执行<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span> 返回值</span>&#123;</span><br><span class="line">  <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>函数调用的语法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值:=函数名(参数)</span><br></pre></td></tr></table></figure></li></ul><h1 id="无参数无返回值函数"><a href="#无参数无返回值函数" class="headerlink" title="无参数无返回值函数"></a>无参数无返回值函数</h1><ul><li><p>函数可以有参数也可以没有参数,可以有返回值也可以没有返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">demo1()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"执行demo1函数"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面代码等同于</span></span><br><span class="line"><span class="comment">//func main()&#123;</span></span><br><span class="line"><span class="comment">//fmt.Println("执行demo1函数")</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h1 id="有参数函数"><a href="#有参数函数" class="headerlink" title="有参数函数"></a>有参数函数</h1></li><li><p>函数的参数可以有多个,且每个参数类型都可以不同</p></li><li><p>参数表示调用函数方想要给函数内部传递的值,给函数使用的.</p></li><li><p>声明函数时的参数叫做形参数,调用函数时参数叫做实参</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i:=<span class="number">5</span></span><br><span class="line">s:=<span class="string">"msr"</span></span><br><span class="line">show(s,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(name <span class="keyword">string</span>,age <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"姓名:"</span>,name,<span class="string">"年龄"</span>,age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h1></li><li><p>函数的返回值是给调用方返回的数据,给调用方使用的.</p></li><li><p>具有返回值的函数,必须要有return</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">fmt.Println(add(a,b))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(c, d <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c + d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也可以在返回值类型前面添加变量,return关键字后不写内容,表示变量是什么返回值什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">fmt.Println(add2(a,b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add2</span><span class="params">(c, d <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum = c + d</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="多返回值函数"><a href="#多返回值函数" class="headerlink" title="多返回值函数"></a>多返回值函数</h1><ul><li><p>在Go语言中每个函数声明时都可以定义成多返回值函数</p></li><li><p>Go语言中所有的错误都是通过返回值返回的</p></li><li><p>声明多返回值函数的语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span> <span class="params">(返回值,返回值)</span></span>&#123;</span><br><span class="line">  <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用函数的语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量,变量:=函数名(参数)</span><br></pre></td></tr></table></figure></li><li><p>调用函数时如果不想接收可以使用下划线占位</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量,_:=函数名(参数)</span><br></pre></td></tr></table></figure></li><li><p>理论上函数返回值个数可以无限多个,但是一般不去定义特别多个返回值(用结构体代替多返回值)</p></li></ul><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><ul><li>函数的返回值可以不接收,表示执行函数</li><li>函数的返回值如果接收,用于接收返回值的变量个数与返回值个数相同</li><li>不想接收的使用占位符(_)占位<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//不接收函数返回值</span></span><br><span class="line">demo()</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个返回值都接收</span></span><br><span class="line">a, b := demo()</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不希望接收的返回值使用下划线占位</span></span><br><span class="line">c, _ := demo()</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"msr"</span>, <span class="number">17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>多返回值函数也可以给返回值定义变量,return后面就不需要编写内容<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">()</span> <span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">name = <span class="string">"nsr"</span></span><br><span class="line">age = <span class="number">17</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h1><ul><li>Go语言支持可变参数函数</li><li>可变参数指调用参数时,参数的个数可以是任意个</li><li>可变参数必须在参数列表最后的位置,在参数名和类型之间添加三个点表示可变参数函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数<span class="params">(参数,参数,名称 ... 类型 )</span></span>&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>输出语句就是可变参数函数,源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>声明函数时,在函数体把可变参数当作切片使用即可</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li>声明可变参数声明与调用<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">demo(<span class="string">"看书"</span>, <span class="string">"写代码"</span>, <span class="string">"看抖音视频"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(hover ... <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> a, b := <span class="keyword">range</span> hover &#123;</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可变参数必须存在其他参数后面,一个函数不能有多个可变参数.<ul><li>因为前面普通参数个数是确定的,编译器知道,哪个实参给哪个形参<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">demo(<span class="string">"张三"</span>, <span class="string">"看书"</span>, <span class="string">"写代码"</span>, <span class="string">"看抖音视频"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(name <span class="keyword">string</span>, hover ... <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(name, <span class="string">"的爱好是"</span>)</span><br><span class="line"><span class="keyword">for</span> a, b := <span class="keyword">range</span> hover &#123;</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><ul><li><p>匿名函数就是没有名称的函数</p></li><li><p>正常函数可以通过名称多次调用,而匿名函数由于没有函数名,所以大部分情况都是在当前位置声明并立即调用(函数变量除外)</p></li><li><p>匿名函数声明完需要调用,在函数结束大括号后面紧跟小括号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;()<span class="comment">//括号表示调用</span></span><br></pre></td></tr></table></figure></li><li><p>匿名函数都是声明在其他函数内部</p><h2 id="匿名函数演示"><a href="#匿名函数演示" class="headerlink" title="匿名函数演示"></a>匿名函数演示</h2></li><li><p>无参数匿名函数</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"这是匿名函数"</span>)</span><br><span class="line">   &#125;()<span class="comment">//括号表示调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参数匿名函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Println(s, <span class="string">"这是匿名函数"</span>)</span><br><span class="line">   &#125;(<span class="string">"传递参数"</span>) <span class="comment">//调用时传递参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参数有返回值匿名函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(s, <span class="string">"这是匿名函数"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">110</span></span><br><span class="line">&#125;(<span class="string">"传递参数"</span>) <span class="comment">//调用时传递参数</span></span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h1><ul><li><p>在Go语言中函数也是一种类型,函数有多少种形式,函数变量就有多少种写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">()</span>           //无参数无返回值</span></span><br><span class="line"><span class="keyword">var</span> b <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span>        //有一个<span class="title">int</span>类型参数</span></span><br><span class="line"><span class="keyword">var</span> c <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">string</span> //有一个<span class="title">int</span>类型参数和<span class="title">string</span>类型返回值</span></span><br><span class="line">fmt.Println(a, b, c)   <span class="comment">//输出:&lt;nil&gt; &lt;nil&gt; &lt;nil&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义完函数变量后,可以使用匿名函数进行赋值.也可以使用已经定义好的函数进行赋值</p></li><li><p>函数变量定义以后与普通函数调用语法相同,变量名就是普通函数声明的函数名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">a = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"执行函数"</span>)</span><br><span class="line">&#125;   <span class="comment">//注意此处没有括号,有括号表示调用函数,变量a就表示接收函数返回值</span></span><br><span class="line">a() <span class="comment">//调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也可以使用短变量方式定义函数变量</span></span><br><span class="line"><span class="comment">等效于</span></span><br><span class="line"><span class="comment">func b(s string)&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">b := <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"执行第二个函数"</span>)</span><br><span class="line">&#125;</span><br><span class="line">b(<span class="string">"参数"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用定义好的函数</span></span><br><span class="line">d := c</span><br><span class="line">d()</span><br><span class="line"><span class="comment">//函数名称c也是一个变量</span></span><br><span class="line">c()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"c函数"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数类型变量是除了slice、map、channel、interface外第五种引用类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">a = b</span><br><span class="line">a()</span><br><span class="line"><span class="keyword">var</span> c <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">c = a</span><br><span class="line">c()</span><br><span class="line">fmt.Printf(<span class="string">"%p %p"</span>, a, c)<span class="comment">//输出地址相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"b"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数作为参数或返回值"><a href="#函数作为参数或返回值" class="headerlink" title="函数作为参数或返回值"></a>函数作为参数或返回值</h2></li><li><p>变量可以作为函数的参数或返回值类型.而函数既然可以当做变量看待,函数变量也可以当做函数的参数或返回值</p></li><li><p>函数作为参数时,类型写成对应的类型即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a(<span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">(b <span class="keyword">func</span>(s <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a执行"</span>)</span><br><span class="line">b(<span class="string">"传递给s的内容"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数作为返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//此时result指向返回值函数.</span></span><br><span class="line">result := a()</span><br><span class="line"><span class="comment">//调用函数,才能获取结果</span></span><br><span class="line">fmt.Println(result())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">110</span><span class="keyword">go</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习九：sort包、map、双向链表、双向循环链表</title>
    <link href="http://www.maishuren.top/posts/golang/202006182323-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006182323-index.html</id>
    <published>2020-06-18T15:23:43.000Z</published>
    <updated>2020-06-18T15:33:37.972Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="sort包"><a href="#sort包" class="headerlink" title="sort包"></a>sort包</h1><ul><li>Go语言标准库中sort提供了排序API</li><li>sort包提供了多种排序算法,这些算法是内部实现的,每次使用sort包排序时,会自动选择最优算法实现<ul><li>插入排序</li><li>快速排序</li><li>堆排</li></ul></li><li>sort包中最上层是一个名称为Interface的接口,只要满足sort.Interface类型都可以排序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A type, typically a collection, that satisfies sort.Interface can be</span></span><br><span class="line"><span class="comment">// sorted by the routines in this package. The methods require that the</span></span><br><span class="line"><span class="comment">// elements of the collection be enumerated by an integer index.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">Len() <span class="keyword">int</span></span><br><span class="line"><span class="comment">// Less reports whether the element with</span></span><br><span class="line"><span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Go语言标准库默认提供了对int、float64、string进行排序的API</li><li>很多函数的参数都是sort包下类型,需要进行转换.</li></ul><h1 id="排序实现"><a href="#排序实现" class="headerlink" title="排序实现"></a>排序实现</h1><ul><li>对int类型切片排序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num := [] <span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>&#125;</span><br><span class="line">sort.Ints(num) <span class="comment">//升序</span></span><br><span class="line">fmt.Println(num)</span><br><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(num))) <span class="comment">//降序</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure></li><li>对float64类型切片排序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f := [] <span class="keyword">float64</span>&#123;<span class="number">1.5</span>, <span class="number">7.2</span>, <span class="number">5.8</span>, <span class="number">2.3</span>, <span class="number">6.9</span>&#125;</span><br><span class="line">sort.Float64s(f) <span class="comment">//升序</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">sort.Sort(sort.Reverse(sort.Float64Slice(f))) <span class="comment">//降序</span></span><br><span class="line">fmt.Println(f)</span><br></pre></td></tr></table></figure></li><li>对string类型切片排序<ul><li>按照编码表数值进行排序</li><li>多字符串中按照第一个字符进行比较</li><li>如果第一个字符相同,比较第二个字符<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">string</span>&#123;<span class="string">"我"</span>, <span class="string">"我是Goer"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>, <span class="string">"国家"</span>, <span class="string">"你"</span>, <span class="string">"我a"</span>&#125;</span><br><span class="line">sort.Sort(sort.StringSlice(s)) <span class="comment">//升序</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="comment">//查找内容的索引,如果不存在,返回内容应该在升序排序切片的哪个位置插入</span></span><br><span class="line">fmt.Println(sort.SearchStrings(s, <span class="string">"你是"</span>))</span><br><span class="line">sort.Sort(sort.Reverse(sort.StringSlice(s)))</span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ul><li><p>map以散列表方式存储键值对集合</p></li><li><p>map中每个元素都是键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[key]Value</span><br></pre></td></tr></table></figure></li><li><p>key是操作map的唯一标准.可以通过key对map中元素进行增加/删除/修改/查看</p></li><li><p>key是唯一的,添加重复的key会覆盖之前的元素.</p></li><li><p>map是值类型,只声明时为空指针(nil)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(m == <span class="literal">nil</span>) <span class="comment">//输出:true</span></span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>, m)   <span class="comment">//输出:0x0</span></span><br></pre></td></tr></table></figure></li><li><p>map读写数据时并不是并发安全的,可以结合RWMutex保证并发安全(RWMutex在后面讲解)</p></li></ul><h2 id="实例化map的几种方式"><a href="#实例化map的几种方式" class="headerlink" title="实例化map的几种方式"></a>实例化map的几种方式</h2><ul><li>使用make函数实例化一个没有初始值的map<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(m==<span class="literal">nil</span>)<span class="comment">//输出:false</span></span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>, m)<span class="comment">//输出:内存地址</span></span><br></pre></td></tr></table></figure></li><li>可以在声明map时直接给map赋初始值.注意初始值在一行和在多行写时的语法区别<ul><li>map中元素键值对语法满足: key:value</li><li>key和value的类型必须和map[key]value类型严格对应<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"msr"</span>, <span class="string">"address"</span>: <span class="string">"中国广东"</span>&#125;</span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"name"</span>:     <span class="string">"msr"</span>,</span><br><span class="line"><span class="string">"addresss"</span>: <span class="string">"中国广东"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m, m1)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="操作map中的元素"><a href="#操作map中的元素" class="headerlink" title="操作map中的元素"></a>操作map中的元素</h2><ul><li>使用key判断,如果key不存在向map中新增数据,如果key存在会覆盖map中元素<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">m[<span class="string">"money"</span>] = <span class="number">5</span></span><br><span class="line">fmt.Println(m) <span class="comment">//输出:map[money:5]</span></span><br><span class="line">m[<span class="string">"money"</span>] = <span class="number">6</span></span><br><span class="line">fmt.Println(m) <span class="comment">//map[money:6]</span></span><br></pre></td></tr></table></figure></li><li>Go语言标准库中提供了对map元素删除的函数,使用顶层delete()即可完成删除<ul><li>如果key存在执行删除元素</li><li>如果key不存在,map中内容不变,也不会有错误<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">m[<span class="string">"money"</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"没有的key"</span>)</span><br><span class="line">fmt.Println(m) <span class="comment">//输出:map[money:5]</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"money"</span>)</span><br><span class="line">fmt.Println(m) <span class="comment">//输出:map[]</span></span><br></pre></td></tr></table></figure></li></ul></li><li>获取map中指定key对应的值<ul><li>使用:map变量[key]获取key对应的值</li><li>如果key不存在返回map[key]Value中Value类型的默认值.例如:Value是string类型就返回””</li><li>返回值可以是一个,也可以是两个.<ul><li>一个表示key对应的值</li><li>两个分别表示:key对应的值和这个key是否存在<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"msr"</span>, <span class="string">"address"</span>: <span class="string">"中国广东"</span>&#125;</span><br><span class="line">fmt.Println(m[<span class="string">"name"</span>]) <span class="comment">//输出:msr</span></span><br><span class="line">fmt.Println(m[<span class="string">"age"</span>])  <span class="comment">//输出:空字符串</span></span><br><span class="line">value, ok := m[<span class="string">"age"</span>]</span><br><span class="line">fmt.Println(value, ok) <span class="comment">//输出:空字符串 false</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>如果希望把map中所有元素都遍历,可以使用for结合range实现<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"msr"</span>, <span class="string">"address"</span>: <span class="string">"中国广东"</span>&#125;</span><br><span class="line"><span class="comment">//range遍历map时返回值分别表示key和value</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="双向链表概述"><a href="#双向链表概述" class="headerlink" title="双向链表概述"></a>双向链表概述</h1><ul><li><p>双向链表结构如下<br><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/lianbiao.png" alt="双向链表"></p></li><li><p>双向链表结构中元素在内存中不是紧邻空间,而是每个元素中存放上一个元素和后一个元素的地址</p><ul><li>第一个元素称为头(head)元素,前连接(前置指针域)为nil</li><li>最后一个元素称为尾(foot)元素,后连接(后置指针域)为nil</li></ul></li><li><p>双向链表的优点:</p><ul><li>在执行新增元素或删除元素时效率高,获取任意一个元素,可以方便的在这个元素前后插入元素</li><li>充分利用内存空间,实现内存灵活管理</li><li>可实现正序和逆序遍历</li><li>头元素和尾元素新增或删除时效率较高</li></ul></li><li><p>双向链表的缺点</p><ul><li>链表增加了元素的指针域,空间开销比较大</li><li>遍历时跳跃性查找内容,大量数据遍历性能低<h2 id="双向链表容器List"><a href="#双向链表容器List" class="headerlink" title="双向链表容器List"></a>双向链表容器List</h2></li></ul></li><li><p>在Go语言标准库的container/list 包提供了双向链表List</p></li><li><p>List结构体定义如下</p><ul><li>root表示根元素</li><li>len表示链表中有多少个元素<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List represents a doubly linked list.</span></span><br><span class="line"><span class="comment">// The zero value for List is an empty list ready to use.</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">root Element <span class="comment">// sentinel list element, only &amp;root, root.prev, and root.next are used</span></span><br><span class="line"><span class="built_in">len</span>  <span class="keyword">int</span>     <span class="comment">// current list length excluding (this) sentinel element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其中Element结构体定义如下</p><ul><li>next表示下一个元素,使用Next()可以获取到</li><li>prev表示上一个元素,使用Prev()可以获取到</li><li>list表示元素属于哪个链表</li><li>Value表示元素的值,interface{}在Go语言中表示任意类型<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Element is an element of a linked list.</span></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Next and previous pointers in the doubly-linked list of elements.</span></span><br><span class="line"><span class="comment">// To simplify the implementation, internally a list l is implemented</span></span><br><span class="line"><span class="comment">// as a ring, such that &amp;l.root is both the next element of the last</span></span><br><span class="line"><span class="comment">// list element (l.Back()) and the previous element of the first list</span></span><br><span class="line"><span class="comment">// element (l.Front()).</span></span><br><span class="line">next, prev *Element</span><br><span class="line"></span><br><span class="line"><span class="comment">// The list to which this element belongs.</span></span><br><span class="line">list *List</span><br><span class="line"></span><br><span class="line"><span class="comment">// The value stored with this element.</span></span><br><span class="line">Value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="操作List"><a href="#操作List" class="headerlink" title="操作List"></a>操作List</h2><ul><li>直接使用container/list包下的New()新建一个空的List<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylist := list.New()</span><br><span class="line">fmt.Println(mylist)       <span class="comment">//输出list中内容</span></span><br><span class="line">fmt.Println(mylist.Len()) <span class="comment">//查看链表中元素的个数</span></span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>, mylist)  <span class="comment">//输出地址</span></span><br></pre></td></tr></table></figure></li><li>Go语言标准库中提供了很多向双向链表中添加元素的函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加到最后,List["a"]</span></span><br><span class="line">mylist.PushBack(<span class="string">"a"</span>)</span><br><span class="line">   <span class="comment">//添加到最前面,List["b","a"]</span></span><br><span class="line">mylist.PushFront(<span class="string">"b"</span>) </span><br><span class="line"><span class="comment">//向第一个元素后面添加元素,List["b","c","a"]</span></span><br><span class="line">mylist.InsertAfter(<span class="string">"c"</span>, mylist.Front()) </span><br><span class="line"><span class="comment">//向最后一个元素前面添加元素,List["b","c","d","a"]</span></span><br><span class="line">mylist.InsertBefore(<span class="string">"d"</span>, mylist.Back())</span><br></pre></td></tr></table></figure></li><li>取出链表中的元素<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(mylist.Back().Value)  <span class="comment">//最后一个元素的值</span></span><br><span class="line">fmt.Println(mylist.Front().Value) <span class="comment">//第一个元素的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只能从头向后找,或从后往前找,获取元素内容</span></span><br><span class="line">n := <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> curr *list.Element</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; n &lt;= mylist.Len() &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">curr = mylist.Front()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> n == mylist.Len() &#123;</span><br><span class="line">curr = mylist.Back()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">curr = mylist.Front()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">curr = curr.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"n的数值不对"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历所有值</span></span><br><span class="line"><span class="keyword">for</span> e := mylist.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>移动元素的顺序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylist.MoveToBack(mylist.Front()) <span class="comment">//把第一个移动到后面</span></span><br><span class="line">mylist.MoveToFront(mylist.Back()) <span class="comment">//把最后一个移动到前面</span></span><br><span class="line">mylist.MoveAfter(mylist.Front(),mylist.Back())<span class="comment">//把第一个参数元素,移动到第二个参数元素后面</span></span><br><span class="line">mylist.MoveBefore(mylist.Front(),mylist.Back())<span class="comment">//把第一个参数元素,移动到第二个参数元素前面</span></span><br></pre></td></tr></table></figure></li><li>删除元素<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mylist.Remove(mylist.Front())</span><br></pre></td></tr></table></figure></li></ul><h1 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h1><ul><li><p>循环链表特点是没有节点的指针域为nil,通过任何一个元素都可以找到其他元素</p></li><li><p>环形链表结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A --&gt;B</span><br><span class="line">B --&gt;C</span><br><span class="line">C --&gt;D</span><br><span class="line">D --&gt;E</span><br><span class="line">E --&gt;D</span><br><span class="line">A --&gt;E</span><br><span class="line">E --&gt;A</span><br><span class="line">D --&gt;C</span><br><span class="line">C --&gt;B</span><br><span class="line">B --&gt;A</span><br></pre></td></tr></table></figure></li><li><p>双向循环链表和双向链表区别</p><ul><li>双向循环链表没有严格意义上的头元素和尾元素</li><li>没有元素的前连接和后连接为nil</li><li>一个长度为n的双向循环链表,通过某个元素向某个方向移动,在查找最多n-1次后一定会找到另一个元素</li></ul></li></ul><h2 id="Go语言中的双向循环链表"><a href="#Go语言中的双向循环链表" class="headerlink" title="Go语言中的双向循环链表"></a>Go语言中的双向循环链表</h2><ul><li><p>在container/ring包下结构体Ring源码如下</p><ul><li>官方明确说明了Ring是循环链表的元素,又是环形链表.</li><li>实际使用时Ring遍历就是环形链表第一个元素<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Ring is an element of a circular list, or ring.</span></span><br><span class="line"><span class="comment">// Rings do not have a beginning or end; a pointer to any ring element</span></span><br><span class="line"><span class="comment">// serves as reference to the entire ring. Empty rings are represented</span></span><br><span class="line"><span class="comment">// as nil Ring pointers. The zero value for a Ring is a one-element</span></span><br><span class="line"><span class="comment">// ring with a nil Value.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> Ring <span class="keyword">struct</span> &#123;</span><br><span class="line">next, prev *Ring</span><br><span class="line">Value      <span class="keyword">interface</span>&#123;&#125; <span class="comment">// for use by client; untouched by this library</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Go语言标准库中对container/ring包提供的API如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ring</span><br><span class="line"><span class="comment">//实例化长度为n的环形链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">//下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Next</span><span class="params">()</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="comment">//上一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Prev</span><span class="params">()</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="comment">//移动n次,支持负数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Move</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="comment">//合并s和r</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Link</span><span class="params">(s *Ring)</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="comment">//删除r后面n%r.Len()元素,删除多个,当前元素前面的不删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Unlink</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="comment">//循环遍历,i是当前元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span></span><br></pre></td></tr></table></figure><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2></li><li><p>实例化、赋值、遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r := ring.New(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r.Len(); i++ &#123;</span><br><span class="line">r.Move(i).Value = i</span><br><span class="line">&#125;</span><br><span class="line">r.Do(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>实例化后的r就是链表中第一个创建的元素.可以找到元素的前后元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(r.Next().Value)<span class="comment">//输出:1</span></span><br><span class="line">fmt.Println(r.Next().Next().Value)<span class="comment">//输出:2</span></span><br><span class="line">fmt.Println(r.Next().Next().Next().Value)<span class="comment">//输出:0</span></span><br><span class="line">fmt.Println(r.Move(<span class="number">-1</span>).Value)<span class="comment">//输出:2</span></span><br><span class="line">fmt.Println(r.Prev().Value)<span class="comment">//输出:2</span></span><br></pre></td></tr></table></figure></li><li><p>可以向环形链表添加或删除链表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s := ring.New(<span class="number">1</span>)</span><br><span class="line">s.Value = <span class="number">13</span></span><br><span class="line"><span class="comment">//r是哪个元素,就把新的链表添加到哪个元素后面</span></span><br><span class="line">r.Link(s)</span><br><span class="line">r.Do(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Print(i, <span class="string">" "</span>)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">""</span>)</span><br><span class="line"><span class="comment">//从r元素向后,n/r.Len()个元素被删除,当前元素和前面的保留</span></span><br><span class="line">r.Unlink(<span class="number">1</span>)</span><br><span class="line">r.Do(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Print(i, <span class="string">" "</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>centos7安装docker</title>
    <link href="http://www.maishuren.top/posts/docker/202006161622-index.html"/>
    <id>http://www.maishuren.top/posts/docker/202006161622-index.html</id>
    <published>2020-06-16T08:22:16.000Z</published>
    <updated>2020-06-16T09:10:47.762Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>1.查看内核版本</p><p>linux操作系统Centos7，linux 3.10 内核，docker官方说至少3.8以上（ubuntu下要linux内核3.8以上）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# uname -a</span><br><span class="line">Linux msr-server 3.10.0-514.26.2.el7.x86_64 #1 SMP Tue Jul 4 15:04:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>2.更新yum包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# yum update</span><br></pre></td></tr></table></figure><p>3.安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# yum -y install gcc</span><br><span class="line">[root@msr-server ~]# yum -y install gcc-c++</span><br><span class="line">[root@msr-server ~]# yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>4.设置阿里云的yum源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docke-rce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>5.查看仓库中docker版本，可以指定安装，不指定安装最新版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# yum list docker-ce --showduplicates | sort -r</span><br><span class="line">Repodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fast</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Installed Packages</span><br><span class="line">docker-ce.x86_64            3:19.03.5-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.5-3.el7                    @docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.4-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.3-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.2-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.1-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.0-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.9-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.8-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.7-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.6-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.5-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.4-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.3-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.2-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.1-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.0-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.3.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.2.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.1.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.0.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.03.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.03.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.12.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.12.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.09.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.09.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.06.2.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.06.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.06.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.3.ce-1.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.2.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">Determining fastest mirrors</span><br><span class="line">Available Packages</span><br></pre></td></tr></table></figure><p>6.安装docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# yum makecache fast</span><br><span class="line">[root@msr-server ~]# yum install docker-ce-18.03.1.ce</span><br></pre></td></tr></table></figure><p>7.启动Docker，加入开机启动，验证安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@msr-server ~]# systemctl start docker</span><br><span class="line">[root@msr-server ~]# systemctl enable  docker</span><br><span class="line">[root@msr-server ~]# docker version</span><br></pre></td></tr></table></figure><p>8.配置阿里云镜像加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# mkdir -p /etc/docker</span><br><span class="line">[root@msr-server ~]# tee /etc/docker/daemon.json &lt;&lt;-'EOF' </span><br><span class="line">&#123; </span><br><span class="line">"registry-mirrors": ["https://****.mirror.aliyuncs.com"] </span><br><span class="line">&#125; </span><br><span class="line">EOF</span><br><span class="line">[root@msr-server ~]# systemctl daemon-reload </span><br><span class="line">[root@msr-server ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="云计算" scheme="http://www.maishuren.top/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="docker" scheme="http://www.maishuren.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>nginx入门之配置语法</title>
    <link href="http://www.maishuren.top/posts/nginx/202006161551-index.html"/>
    <id>http://www.maishuren.top/posts/nginx/202006161551-index.html</id>
    <published>2020-06-16T07:51:03.000Z</published>
    <updated>2020-06-17T08:56:48.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="默认的配置文件"><a href="#默认的配置文件" class="headerlink" title="默认的配置文件"></a>默认的配置文件</h1><p>   shell<br>user  nginx;<br>worker_processes  1;</p><p>error_log  /var/log/nginx/error.log warn;<br>pid        /var/run/nginx.pid;</p><p>events {<br>    worker_connections  1024;<br>}</p><p>http {<br>    include       /etc/nginx/mime.types;<br>    default_type  application/octet-stream;</p><pre><code>log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;access_log  /var/log/nginx/access.log  main;sendfile        on;#tcp_nopush     on;keepalive_timeout  65;#gzip  on;#include /etc/nginx/conf.d/*.conf;server {    listen       80;    server_name  localhost;    location / {           root   /usr/share/nginx/html;        index  index.html index.htm;    }    error_page   500 502 503 504 404  /50x.html;    location = /50x.html {        root   /usr/share/nginx/html;    }}</code></pre><p>}</p><ul><li>user:设置nginx服务的系统使用用户</li><li>worker_processes:工作进程数</li><li>error_log:nginx的错误日志</li><li>pid:nginx服务启动时候pid</li><li>events：<ul><li>worker_connections:每个进程允许最大连接数</li><li>use:工作进程数</li></ul></li><li>server:<ul><li>listen 80 监听服务器80端口</li><li>server_name 可配置域名</li><li>location /:根目录<ul><li>root &amp; index:默认访问页面</li></ul></li><li>error_page: 错误页面，500 502 503 504 404这些状态码都会跳转到/50x.html</li><li>location = /50x.html:响应50x.html的访问，根目录下的50x.html</li></ul></li><li>keepalive_timeout:客户端超时时间</li><li>include /etc/nginx/conf.d/*.conf:引入配置文件，一般一个配置文件一个server</li></ul><h1 id="日志格式log-format"><a href="#日志格式log-format" class="headerlink" title="日志格式log_format"></a>日志格式log_format</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">默认配置</span></span><br><span class="line">log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                      '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                      '"$http_user_agent" "$http_x_forwarded_for"';</span><br></pre></td></tr></table></figure><p>1.Http变量：arg_PARAMETER、http_HEADER、sent_http_HEADER</p><p>​        eg:log_format  main ‘$arg_PARAMETER $http_HEADER $sent_http_HEADER’</p><p>2.内置变量：</p><p>​        内置变量存放在 ngx_http_core_module 模块中，变量的命名方式和apache 服务器变量是一致的。总而言之，这些变量代表着客户端请求头的内容。下面是nginx支持的内置变量：</p><p><strong>$arg_name</strong></p><p>请求中的的参数名，即“?”后面的arg_name=arg_value形式的arg_name</p><p><strong>$args</strong></p><p>请求中的参数值</p><p><strong>$binary_remote_addr</strong></p><p>客户端地址的二进制形式, 固定长度为4个字节</p><p><strong>$body_bytes_sent</strong></p><p>传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的“%B”参数保持兼容</p><p><strong>$bytes_sent</strong></p><p>传输给客户端的字节数 (1.3.8, 1.2.5)</p><p><strong>$connection</strong></p><p>TCP连接的序列号 (1.3.8, 1.2.5)</p><p><strong>$connection_requests</strong></p><p>TCP连接当前的请求数量 (1.3.8, 1.2.5)</p><p><strong>$content_length</strong></p><p>“Content-Length” 请求头字段</p><p><strong>$content_type</strong></p><p>“Content-Type” 请求头字段</p><p><strong>$cookie_name</strong></p><p>cookie名称</p><p><strong>$document_root</strong></p><p>当前请求的文档根目录或别名</p><p><strong>$document_uri</strong></p><p>同 $uri</p><p><strong>$host</strong></p><p>优先级如下：HTTP请求行的主机名&gt;”HOST”请求头字段&gt;符合请求的服务器名</p><p><strong>$hostname</strong></p><p>主机名</p><p><strong>$http_name</strong></p><p>匹配任意请求头字段； 变量名中的后半部分“name”可以替换成任意请求头字段，如在配置文件中需要获取http请求头：“Accept-Language”，那么将“－”替换为下划线，大写字母替换为小写，形如：$http_accept_language即可。</p><p>*<em>$https *</em></p><p>如果开启了SSL安全模式，值为“on”，否则为空字符串。</p><p><strong>$is_args</strong></p><p>如果请求中有参数，值为“?”，否则为空字符串。</p><p><strong>$limit_rate</strong></p><p>用于设置响应的速度限制，详见 limit_rate。</p><p><strong>$msec</strong></p><p>当前的Unix时间戳 (1.3.9, 1.2.6)</p><p><strong>$nginx_version</strong></p><p>nginx版本</p><p><strong>$pid</strong></p><p>工作进程的PID</p><p><strong>$pipe</strong></p><p>如果请求来自管道通信，值为“p”，否则为“.” (1.3.12, 1.2.7)</p><p><strong>$proxy_protocol_addr</strong></p><p>获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串。(1.5.12)</p><p><strong>$query_string</strong></p><p>同 $args</p><p><strong>$realpath_root</strong></p><p>当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径。</p><p><strong>$remote_addr</strong></p><p>客户端地址</p><p><strong>$remote_port</strong></p><p>客户端端口</p><p><strong>$remote_user</strong></p><p>用于HTTP基础认证服务的用户名</p><p><strong>$request</strong></p><p>代表客户端的请求地址</p><p><strong>$request_body</strong></p><p>客户端的请求主体</p><p>此变量可在location中使用，将请求主体通过proxy_pass, fastcgi_pass, uwsgi_pass, 和 scgi_pass传递给下一级的代理服务器。</p><p><strong>$request_body_file</strong></p><p>将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置client_body_in_file_only。如果将次文件传递给后端的代理服务器，需要禁用request body，即设置proxy_pass_request_body off，fastcgi_pass_request_body off, uwsgi_pass_request_body off, or scgi_pass_request_body off 。</p><p><strong>$request_completion</strong></p><p>如果请求成功，值为”OK”，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空。</p><p><strong>$request_filename</strong></p><p>当前连接请求的文件路径，由root或alias指令与URI请求生成。</p><p><strong>$request_length</strong></p><p>请求的长度 (包括请求的地址, http请求头和请求主体) (1.3.12, 1.2.7)</p><p><strong>$request_method</strong></p><p>HTTP请求方法，通常为“GET”或“POST”</p><p><strong>$request_time</strong></p><p>处理客户端请求使用的时间 (1.3.9, 1.2.6); 从读取客户端的第一个字节开始计时。</p><p><strong>$request_uri</strong></p><p>这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：”/cnphp/test.php?arg=freemouse”。</p><p><strong>$scheme</strong></p><p>请求使用的Web协议, “http” 或 “https”</p><p><strong>$sent_http_name</strong></p><p>可以设置任意http响应头字段； 变量名中的后半部分“name”可以替换成任意响应头字段，如需要设置响应头Content-length，那么将“－”替换为下划线，大写字母替换为小写，形如：$sent_http_content_length 4096即可。</p><p><strong>$server_addr</strong></p><p>服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中。</p><p><strong>$server_name</strong></p><p>服务器名，<a href="http://www.cnphp.info" target="_blank" rel="noopener">www.cnphp.info</a></p><p><strong>$server_port</strong></p><p>服务器端口</p><p><strong>$server_protocol</strong></p><p>服务器的HTTP版本, 通常为 “HTTP/1.0” 或 “HTTP/1.1”</p><p><strong>$status</strong></p><p>HTTP响应代码 (1.3.2, 1.2.2)</p><p><strong>$tcpinfo_rtt, $tcpinfo_rttvar, $tcpinfo_snd_cwnd, $tcpinfo_rcv_space</strong></p><p>客户端TCP连接的具体信息</p><p><strong>$time_iso8601</strong></p><p>服务器时间的ISO 8610格式 (1.3.12, 1.2.7)</p><p>*<em>$time_local $arg_name *</em></p><p>请求中的的参数名，即“?”后面的arg_name=arg_value形式的arg_name</p><p><strong>$args</strong></p><p>请求中的参数值</p><p><strong>$binary_remote_addr</strong></p><p>客户端地址的二进制形式, 固定长度为4个字节</p><p><strong>$body_bytes_sent</strong></p><p>传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的“%B”参数保持兼容</p><p><strong>$bytes_sent</strong></p><p>传输给客户端的字节数 (1.3.8, 1.2.5)</p><p><strong>$connection</strong></p><p>TCP连接的序列号 (1.3.8, 1.2.5)</p><p><strong>$connection_requests</strong></p><p>TCP连接当前的请求数量 (1.3.8, 1.2.5)</p><p>*<em>$content_lengt *</em></p><p>“Content-Length” 请求头字段</p><p><strong>$content_type</strong></p><p>“Content-Type” 请求头字段</p><p>*<em>$cookie_name *</em></p><p>cookie名称</p><p><strong>$document_root</strong></p><p>当前请求的文档根目录或别名</p><p><strong>$document_uri</strong></p><p>同 $uri</p><p><strong>$host</strong></p><p>优先级如下：HTTP请求行的主机名&gt;”HOST”请求头字段&gt;符合请求的服务器名</p><p><strong>$hostname</strong></p><p>主机名</p><p><strong>$http_name</strong></p><p>匹配任意请求头字段； 变量名中的后半部分“name”可以替换成任意请求头字段，如在配置文件中需要获取http请求头：“Accept-Language”，那么将“－”替换为下划线，大写字母替换为小写，形如：$http_accept_language即可。</p><p><strong>$https</strong></p><p>如果开启了SSL安全模式，值为“on”，否则为空字符串。</p><p><strong>$is_args</strong></p><p>如果请求中有参数，值为“?”，否则为空字符串。</p><p><strong>$limit_rate</strong></p><p>用于设置响应的速度限制，详见 limit_rate。</p><p><strong>$msec</strong></p><p>当前的Unix时间戳 (1.3.9, 1.2.6)</p><p><strong>$nginx_version</strong></p><p>nginx版本</p><p><strong>$pid</strong></p><p>工作进程的PID</p><p><strong>$pipe</strong></p><p>如果请求来自管道通信，值为“p”，否则为“.” (1.3.12, 1.2.7)</p><p><strong>$proxy_protocol_addr</strong></p><p>获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串。(1.5.12)</p><p><strong>$query_string</strong></p><p>同 $args</p><p><strong>$realpath_root</strong></p><p>当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径。</p><p><strong>$remote_addr</strong></p><p>客户端地址</p><p><strong>$remote_port</strong></p><p>客户端端口</p><p><strong>$remote_user</strong></p><p>用于HTTP基础认证服务的用户名</p><p><strong>$request</strong></p><p>代表客户端的请求地址</p><p><strong>$request_body</strong></p><p>客户端的请求主体</p><p>此变量可在location中使用，将请求主体通过proxy_pass, fastcgi_pass, uwsgi_pass, 和 scgi_pass传递给下一级的代理服务器。</p><p><strong>$request_body_file</strong></p><p>将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置client_body_in_file_only。如果将次文件传递给后端的代理服务器，需要禁用request body，即设置proxy_pass_request_body off，fastcgi_pass_request_body off, uwsgi_pass_request_body off, or scgi_pass_request_body off 。</p><p><strong>$request_completion</strong></p><p>如果请求成功，值为”OK”，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空。</p><p><strong>$request_filename</strong></p><p>当前连接请求的文件路径，由root或alias指令与URI请求生成。</p><p><strong>$request_length</strong></p><p>请求的长度 (包括请求的地址, http请求头和请求主体) (1.3.12, 1.2.7)</p><p><strong>$request_method</strong></p><p>HTTP请求方法，通常为“GET”或“POST”</p><p><strong>$request_time</strong></p><p>处理客户端请求使用的时间 (1.3.9, 1.2.6); 从读取客户端的第一个字节开始计时。</p><p><strong>$request_uri</strong></p><p>这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：”/cnphp/test.php?arg=freemouse”。</p><p><strong>$scheme</strong></p><p>请求使用的Web协议, “http” 或 “https”</p><p><strong>$sent_http_name</strong></p><p>可以设置任意http响应头字段； 变量名中的后半部分“name”可以替换成任意响应头字段，如需要设置响应头Content-length，那么将“－”替换为下划线，大写字母替换为小写，形如：$sent_http_content_length 4096即可。</p><p><strong>$server_addr</strong></p><p>服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中。</p><p><strong>$server_name</strong></p><p>服务器名如<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p><strong>$server_port</strong></p><p>服务器端口</p><p><strong>$server_protocol</strong></p><p>服务器的HTTP版本, 通常为 “HTTP/1.0” 或 “HTTP/1.1”</p><p><strong>$status</strong></p><p>HTTP响应代码 (1.3.2, 1.2.2)</p><p><strong>$tcpinfo_rtt</strong>, $tcpinfo_rttvar, $tcpinfo_snd_cwnd, $tcpinfo_rcv_space</p><p>客户端TCP连接的具体信息</p><p><strong>$time_iso8601</strong></p><p>服务器时间的ISO 8610格式 (1.3.12, 1.2.7)</p><p><strong>$time_local</strong></p><p>服务器时间（LOG Format 格式） (1.3.12, 1.2.7)</p><p><strong>$uri</strong></p><p>请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如”/foo/bar.html”。</p><p>服务器时间（LOG Format 格式） (1.3.12, 1.2.7)</p><p><strong>$uri</strong></p><p>请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如”/foo/bar.html”。</p><h1 id="监控模块http-stub-status-modules"><a href="#监控模块http-stub-status-modules" class="headerlink" title="监控模块http_stub_status_modules"></a>监控模块http_stub_status_modules</h1><p>作用：监控Nginx客户端状态</p><p>作用域：server；location</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查看配置参数</span><br><span class="line">root@3de922dd7a75:/usr/share/nginx/html# nginx -V </span><br><span class="line">nginx version: nginx/1.19.0</span><br><span class="line">built by gcc 8.3.0 (Debian 8.3.0-6) </span><br><span class="line">built with OpenSSL 1.1.1d  10 Sep 2019</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt='-g -O2 -fdebug-prefix-map=/data/builder/debuild/nginx-1.19.0/debian/debuild-base/nginx-1.19.0=. -fstack-protector-strong -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC' --with-ld-opt='-Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie'</span><br></pre></td></tr></table></figure><ol><li>配置语法：在一个server下配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location  /status &#123;</span><br><span class="line">stub_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改完之后，测试配置文件是否有错误</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@3de922dd7a75:/etc/nginx# nginx -tc ./nginx.conf </span><br><span class="line">nginx: the configuration file /etc/nginx/./nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/./nginx.conf test is successful</span><br></pre></td></tr></table></figure><ol start="3"><li>重载配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@3de922dd7a75:/etc/nginx# nginx-s reload /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><ol start="4"><li>再访问htttp://ip/stasus，出现一下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Active connections: 2 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 4 4 1 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 1</span><br></pre></td></tr></table></figure><ol start="5"><li>nginx_status详解</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Active connections: 1     </span><br><span class="line">##nginx正处理的活跃连接数　　</span><br><span class="line">server accepts handled requests</span><br><span class="line">##server  nginx启动到现在共处理了多少个连接</span><br><span class="line">##accepts  nginx启动到现在共创建了多少次握手，请求丢失数&#x3D;握手数-连接数</span><br><span class="line">##handled requests    总共处理了多少个请求</span><br><span class="line">Reading: 0 Writing: 1 Waiting: 0</span><br><span class="line">##Reading  nginx读取客户端 header 信息数</span><br><span class="line">##Writing  nginx返回给客户端的 hearder 信息数</span><br><span class="line">##Waiting  nginx已经处理完正在等待下一次请求指令的驻留连接，在开启keep-alive的情况下，waiting值等于active - (Reading+Writing)</span><br></pre></td></tr></table></figure><h1 id="模块http-random-index-module"><a href="#模块http-random-index-module" class="headerlink" title="模块http_random_index_module"></a>模块http_random_index_module</h1><p>作用：在主目录中选择一个随机主页</p><p>默认：关闭</p><p>作用域：location</p><ol><li>配置语法：在location中配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">root /etc/nginx/html;</span><br><span class="line">random_index on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在/etc/nginx/html中新建一个html文件</li><li>重复上一小节的检查配置文件，重载配置文件，在浏览器访问，不断刷新，出现不同的页面</li></ol><h1 id="默认模块http-sub-module"><a href="#默认模块http-sub-module" class="headerlink" title="默认模块http_sub_module"></a>默认模块http_sub_module</h1><p>作用：HTTP内容替换</p><p>常用选项：sub_filter string replacement；sub_filter_last_modified on|off；sub_filter_once on|off</p><p>作用域：http；server；location</p><ol><li><p>配置语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">root &#x2F;etc&#x2F;nginx&#x2F;html;</span><br><span class="line">index index.html index.htm;</span><br><span class="line">sub_filter &#39;nginx&#39; &#39;NGINX&#39;; #替换第一个nginx</span><br><span class="line">sub_filter_once off; #关闭之后，所有的nginx都会被替换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Nginx的请求访问限制"><a href="#Nginx的请求访问限制" class="headerlink" title="Nginx的请求访问限制"></a>Nginx的请求访问限制</h1><h2 id="请求限制"><a href="#请求限制" class="headerlink" title="请求限制"></a>请求限制</h2><ol><li><p>连接频率限制：limit_conn_module</p><p>limit_conn_zone key zone=name:size，作用域http</p><p>limit_conn zone number，作用域http，server，location</p></li><li><p>请求频率限制：limit_req_module</p><p>limit_req_zone key zone=name:size rate=rate,http</p><p>limit_req zone=name,http,server,location</p></li><li><p>配置语法：</p><p>在http下配置，以客户端的ip地址作为key，对这个key进行限制，同时申请一个zone空间大小为1m用来存储访问的频次信息。$binary_remote_addr可以节省zone空间。rate=1r/s：表示允许相同标识的客户端的<strong>访问频次</strong>，这里限制的是每秒1次，即每秒只处理一个请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;conn_zone:1m</span><br><span class="line">limit_req_zone $binary_remote_addr zone&#x3D;req_zone:1m rate&#x3D;1r&#x2F;s</span><br></pre></td></tr></table></figure><p>在localtion下配置：</p><p>limit_req zone=req_zon：使用配置好的rate的速率来处理数据</p><p>burst=3：设置一个大小为3的缓冲区当有大量请求（爆发）过来时，超过了<strong>访问频次</strong>限制的<strong>请求可以先放到这个缓冲区内等待，但是这个等待区里的位置只有3个</strong>，超过的请求会直接报503的错误然后返回。</p><p>nodelay：如果设置，会在瞬时提供处理(burst + rate)个请求的能力，请求超过（<strong>burst + rate）</strong>的时候就会直接返回503，永远不存在请求需要等待的情况。如果没有设置，则所有请求会依次等待排队</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location  &#x2F;status &#123;</span><br><span class="line">root html;</span><br><span class="line">#   limit_conn conn_zone 1;  #同一时间只允许一个连接</span><br><span class="line">    #   limit_req zone&#x3D;req_zone burst&#x3D;3 nodelay;  </span><br><span class="line">    #   limit_req zone&#x3D;req_zone burst&#x3D;3;</span><br><span class="line">    #   limit_req zone&#x3D;req_zone;</span><br><span class="line">    index show.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>基于IP的访问控制：http_access_module</p></li></ol><p>   基于用户的信任登录：http_auth_basic_module</p>]]></content>
    
    <summary type="html">
    
      高性能服务器Nginx的入门
    
    </summary>
    
    
      <category term="运维" scheme="http://www.maishuren.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="nginx" scheme="http://www.maishuren.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx入门之初识nginx</title>
    <link href="http://www.maishuren.top/posts/nginx/202006151538-index.html"/>
    <id>http://www.maishuren.top/posts/nginx/202006151538-index.html</id>
    <published>2020-06-15T07:38:28.000Z</published>
    <updated>2020-06-16T07:44:02.362Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><p><em>Nginx</em> (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><h1 id="Nginx的三个主要运用场景"><a href="#Nginx的三个主要运用场景" class="headerlink" title="Nginx的三个主要运用场景"></a>Nginx的三个主要运用场景</h1><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/nginx/nginx1.png" alt=""></p><ul><li>静态资源服务<ul><li>通过本地文件系统提供服务</li></ul></li><li>反向代理服务<ul><li>Ngnix强大性能</li><li>缓存</li><li>负载均衡</li></ul></li><li>API服务<ul><li>OpenResty</li></ul></li></ul><h1 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h1><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/nginx/nginx2.png" alt=""></p><h1 id="Nginx的组成"><a href="#Nginx的组成" class="headerlink" title="Nginx的组成"></a>Nginx的组成</h1><p>Nginx二进制可执行文件：由各模块源码编译出的一个文件</p><p>Nginx配置文件Nginx.conf：控制Nginx的行为</p><p>access.log访问日志：记录每一条http请求信息</p><p>error.log错误日志：记录错误信息，可以定位问题</p><h1 id="Nginx的编译和安装"><a href="#Nginx的编译和安装" class="headerlink" title="Nginx的编译和安装"></a>Nginx的编译和安装</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>1.安装相关依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel</span><br></pre></td></tr></table></figure><p>2.安装常用工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget httpd-tools vim</span><br></pre></td></tr></table></figure><p>3.查看防火墙状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br><span class="line">或者</span><br><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>4.开启了防火墙，所以配置iptables</p><p>安装iptables</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install iptables<span class="literal">-services</span></span><br></pre></td></tr></table></figure><p>配置iptables规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><p>常用的80和8080端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sample configuration <span class="keyword">for</span> iptables service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> you can edit this manually or use system-config-firewall</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> please <span class="keyword">do</span> not ask us to add additional ports/services to this default configuration</span></span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -jACCEPT    #添加的</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT  #添加的</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><p>重启生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart iptables</span><br></pre></td></tr></table></figure><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>1.下载Nginx压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.nginx.org/download/nginx-1.17.7.tar.gz</span><br></pre></td></tr></table></figure><p>2.解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.17.7.tar.gz</span><br></pre></td></tr></table></figure><p>3.Nginx目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x. 6 1001 1001   4096 Jun 15 18:53 auto</span><br><span class="line">-rw-r--r--. 1 1001 1001 301572 Dec 24 23:00 CHANGES</span><br><span class="line">-rw-r--r--. 1 1001 1001 460207 Dec 24 23:00 CHANGES.ru</span><br><span class="line">drwxr-xr-x. 2 1001 1001    168 Jun 15 18:53 conf</span><br><span class="line">-rwxr-xr-x. 1 1001 1001   2502 Dec 24 23:00 configure</span><br><span class="line">drwxr-xr-x. 4 1001 1001     72 Jun 15 18:53 contrib</span><br><span class="line">drwxr-xr-x. 2 1001 1001     40 Jun 15 18:53 html</span><br><span class="line">-rw-r--r--. 1 1001 1001   1397 Dec 24 23:00 LICENSE</span><br><span class="line">drwxr-xr-x. 2 1001 1001     21 Jun 15 18:53 man</span><br><span class="line">-rw-r--r--. 1 1001 1001     49 Dec 24 23:00 README</span><br><span class="line">drwxr-xr-x. 9 1001 1001     91 Jun 15 18:53 src</span><br></pre></td></tr></table></figure><p>4.编译安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 nginx-1.6.2]# ./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35</span><br><span class="line">[root@centos7 nginx-1.6.2]# make</span><br><span class="line">[root@centos7 nginx-1.6.2]# make install</span><br><span class="line">[root@centos7 nginx-1.6.2]#</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h3><p>安装目的目录或路径</p><ul><li>–prefix=/etc/nginx</li><li>–sbin-path=/usr/sbin/nginx</li><li>–modules-path=/usr/lib64/nginx/modules</li><li>–conf-path=/etc/nginx/nginx.conf</li><li>–error-log-path=/var/log/nginx/error.log</li><li>–http-log-path=/var/log/nginx/access.log</li><li>–pid-path=/var/run/nginx.pid (记录nginx启动服务的进程ID)</li><li>–lock-path=/var/run/nginx.lock</li></ul><p>编译生成的文件，执行对应模块时，Nginx所保留的临时性文件</p><ul><li>–http-client-body-temp-path=/var/cache/nginx/client_temp</li><li>–http-proxy-temp-path=/var/cache/nginx/proxy_temp</li><li>–http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp</li><li>–http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp</li><li>–http-scgi-temp-path=/var/cache/nginx/scgi_temp</li></ul><h3 id="rpm安装时的目录"><a href="#rpm安装时的目录" class="headerlink" title="rpm安装时的目录"></a>rpm安装时的目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;logrotate.d&#x2F;nginx</span><br></pre></td></tr></table></figure><ul><li><code>类型：配置文件</code></li><li><code>作用：Nginx日志轮转，用于logrotate服务的日志切割（比如按天切割日志）</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</span><br></pre></td></tr></table></figure><ul><li><code>类型：目录，配置文件</code></li><li><code>作用：Nginx主配置文件</code></li></ul><p>/etc/nginx/nginx.conf 是主配置文件，当Nginx启动优先读取，当没有变更的时候，会读取/etc/nginx/conf.d/default.conf（安装是默认加载的）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;fastcgi_params &#x2F;etc&#x2F;nginx&#x2F;uwsgi_params &#x2F;etc&#x2F;nginx&#x2F;scgi_params</span><br></pre></td></tr></table></figure><ul><li><code>类型：配置文件</code></li><li><code>作用：cgi配置相关，fastcgi配置</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;koi-utf &#x2F;etc&#x2F;nginx&#x2F;koi-win &#x2F;etc&#x2F;nginx&#x2F;win-utf</span><br></pre></td></tr></table></figure><ul><li><code>类型：配置文件</code></li><li><code>作用：编码转换映射转化文件</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;mime.types</span><br></pre></td></tr></table></figure><ul><li><p><code>类型：配置文件</code></p></li><li><p><code>作用：设置http协议的ContentType(数据返回类型)与扩展名对应关系</code></p><p>当Nginx要处理一些不能识别的扩展名和文件类型的时候就需要编辑该文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx-debug.service &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service &#x2F;etc&#x2F;sysconfig&#x2F;nginx &#x2F;etc&#x2F;sysconfig&#x2F;nginx-debug</span><br></pre></td></tr></table></figure><ul><li><code>类型：配置文件</code></li><li><code>作用：用于配置出系统守护进程管理器管理方式</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;lib64&#x2F;nginx &#x2F;etc&#x2F;nginx&#x2F;modules</span><br></pre></td></tr></table></figure><ul><li><code>类型：目录</code></li><li><code>作用：Nginx模块目录</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;sbin&#x2F;nginx-debug</span><br></pre></td></tr></table></figure><ul><li><code>类型：命令</code></li><li><code>作用：Nginx服务的启动管理的终端命令</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.6.2 &#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.6.2&#x2F;COPYRIGHT &#x2F;usr&#x2F;share&#x2F;man&#x2F;man8&#x2F;nginx.8.gz</span><br></pre></td></tr></table></figure><ul><li><code>类型：文件，目录</code></li><li><code>作用：Nginx的手册和帮助文件</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;cache&#x2F;nginx</span><br></pre></td></tr></table></figure><ul><li><code>类型：目录</code></li><li><code>作用：Nginx的缓存目录</code></li></ul><p>Nginx处理可以做代理，还可以做缓存服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;log&#x2F;nginx</span><br></pre></td></tr></table></figure><ul><li><code>类型：目录</code></li><li><code>作用：Nginx的日志目录</code></li></ul>]]></content>
    
    <summary type="html">
    
      高性能服务器Nginx的入门，初识Nginx
    
    </summary>
    
    
      <category term="运维" scheme="http://www.maishuren.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="nginx" scheme="http://www.maishuren.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot应用：整合actuator和Admin实现SpringBoot监控</title>
    <link href="http://www.maishuren.top/posts/springboot/202006141700-index.html"/>
    <id>http://www.maishuren.top/posts/springboot/202006141700-index.html</id>
    <published>2020-06-14T09:00:27.000Z</published>
    <updated>2020-06-14T09:00:27.868Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>大数据之hadoop一：hadoop入门</title>
    <link href="http://www.maishuren.top/posts/hadoop/202006132303-index.html"/>
    <id>http://www.maishuren.top/posts/hadoop/202006132303-index.html</id>
    <published>2020-06-13T15:03:26.000Z</published>
    <updated>2020-06-15T16:07:46.858Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Hadoop是什么？"><a href="#Hadoop是什么？" class="headerlink" title="Hadoop是什么？"></a>Hadoop是什么？</h1><p>1）hadoop是由Apache基金会所开发的分布式系统基础架构</p><p>2）主要解决海量数据的存储和海量数据的分析计算问题</p><p>3）广义来说，hadoop通常是之一个更广泛的概念—hadoop生态圈</p><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop1.jpg" alt=""></p><h1 id="Hadoop三大发行版本"><a href="#Hadoop三大发行版本" class="headerlink" title="Hadoop三大发行版本"></a>Hadoop三大发行版本</h1><p>Hadoop三大发行版本：Apache、Cloudera、Hortonworks。</p><p>Apache版本最原始（最基础）的版本，对于入门学习最好。</p><p>Cloudera在大型互联网企业中用的较多。</p><p>Hortonworks文档较好。</p><ol><li>Apache Hadoop</li></ol><p>官网地址：<a href="http://hadoop.apache.org/releases.html" target="_blank" rel="noopener">http://hadoop.apache.org/releases.html</a></p><p>下载地址：<a href="https://archive.apache.org/dist/hadoop/common/" target="_blank" rel="noopener">https://archive.apache.org/dist/hadoop/common/</a></p><ol start="2"><li>Cloudera Hadoop </li></ol><p>官网地址：<a href="https://www.cloudera.com/downloads/cdh/5-10-0.html" target="_blank" rel="noopener">https://www.cloudera.com/downloads/cdh/5-10-0.html</a></p><p>下载地址：<a href="http://archive-primary.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">http://archive-primary.cloudera.com/cdh5/cdh/5/</a></p><p>（1）2008年成立的Cloudera是最早将Hadoop商用的公司，为合作伙伴提供Hadoop的商用解决方案，主要是包括支持、咨询服务、培训。</p><p>（2）2009年Hadoop的创始人Doug Cutting也加盟Cloudera公司。Cloudera产品主要为CDH，Cloudera Manager，Cloudera Support</p><p>（3）CDH是Cloudera的Hadoop发行版，完全开源，比Apache Hadoop在兼容性，安全性，稳定性上有所增强。</p><p>（4）Cloudera Manager是集群的软件分发及管理监控平台，可以在几个小时内部署好一个Hadoop集群，并对集群的节点及服务进行实时监控。Cloudera Support即是对Hadoop的技术支持。</p><p>（5）Cloudera的标价为每年每个节点4000美元。Cloudera开发并贡献了可实时处理大数据的Impala项目。</p><ol start="3"><li>Hortonworks Hadoop</li></ol><p>官网地址：<a href="https://hortonworks.com/products/data-center/hdp/" target="_blank" rel="noopener">https://hortonworks.com/products/data-center/hdp/</a></p><p>下载地址：<a href="https://hortonworks.com/downloads/#data-platform" target="_blank" rel="noopener">https://hortonworks.com/downloads/#data-platform</a></p><p>（1）2011年成立的Hortonworks是雅虎与硅谷风投公司Benchmark Capital合资组建。</p><p>（2）公司成立之初就吸纳了大约25名至30名专门研究Hadoop的雅虎工程师，上述工程师均在2005年开始协助雅虎开发Hadoop，贡献了Hadoop80%的代码。</p><p>（3）雅虎工程副总裁、雅虎Hadoop开发团队负责人Eric Baldeschwieler出任Hortonworks的首席执行官。</p><p>（4）Hortonworks的主打产品是Hortonworks Data Platform（HDP），也同样是100%开源的产品，HDP除常见的项目外还包括了Ambari，一款开源的安装和管理系统。</p><p>（5）HCatalog，一个元数据管理系统，HCatalog现已集成到Facebook开源的Hive中。Hortonworks的Stinger开创性的极大的优化了Hive项目。Hortonworks为入门提供了一个非常好的，易于使用的沙盒。</p><p>（6）Hortonworks开发了很多增强特性并提交至核心主干，这使得Apache Hadoop能够在包括Window Server和Windows Azure在内的Microsoft Windows平台上本地运行。定价以集群为基础，每10个节点每年为12500美元。</p><h1 id="Hadoop的组成"><a href="#Hadoop的组成" class="headerlink" title="Hadoop的组成"></a>Hadoop的组成</h1><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop2.png" alt=""></p><h2 id="HDFS架构概述"><a href="#HDFS架构概述" class="headerlink" title="HDFS架构概述"></a>HDFS架构概述</h2><p>HDFS由NameNode、DataNode、SencodaryNode组成。</p><ul><li>NameNode：存储文件的元数据，如文件名，文件目录结构，文件属性(生成时间、副本数、文件权限)，以及每个文件的块列表和块所在的DataNode等。</li><li>DataNode：在本地文件系统存储文件块数据，以及块数据的校验和。</li><li>SecondaryNode：用于监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。</li></ul><h2 id="Yarn架构概述"><a href="#Yarn架构概述" class="headerlink" title="Yarn架构概述"></a>Yarn架构概述</h2><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop3.png" alt=""></p><h2 id="MapReduce架构概述"><a href="#MapReduce架构概述" class="headerlink" title="MapReduce架构概述"></a>MapReduce架构概述</h2><p>MapReduce将计算过程分为两个阶段：Map和Reduce</p><p>1）Map阶段并行处理输入数据</p><p>2）Reduce阶段对Map结果进行汇总</p><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop4.png" alt=""></p><h1 id="大数据生态体系"><a href="#大数据生态体系" class="headerlink" title="大数据生态体系"></a>大数据生态体系</h1><p>TODO</p><h1 id="推荐系统框架图"><a href="#推荐系统框架图" class="headerlink" title="推荐系统框架图"></a>推荐系统框架图</h1><p>TODO</p><h1 id="Hadoop运行环境搭建"><a href="#Hadoop运行环境搭建" class="headerlink" title="Hadoop运行环境搭建"></a>Hadoop运行环境搭建</h1><h2 id="安装JDK和安装Hadoop"><a href="#安装JDK和安装Hadoop" class="headerlink" title="安装JDK和安装Hadoop"></a>安装JDK和安装Hadoop</h2><p>1.解压jdk压缩包</p><p>2.解压Hadoop压缩包</p><p>3.配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/software/bigdata/jdk1.8</span><br><span class="line">export JRE_HOME=/opt/software/bigdata/jdk1.8/jre</span><br><span class="line">export HADOOP_HOME=/opt/software/bigdata/hadoop</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure><p>4.验证环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]# java -version</span><br><span class="line">java version "1.8.0_211"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]# hadoop version</span><br><span class="line">Hadoop 2.7.2</span><br><span class="line">Subversion Unknown -r Unknown</span><br><span class="line">Compiled by root on 2017-05-22T10:49Z</span><br><span class="line">Compiled with protoc 2.5.0</span><br><span class="line">From source with checksum d0fda26633fa762bff87ec759ebe689c</span><br><span class="line">This command was run using /opt/software/bigdata/hadoop/share/hadoop/common/hadoop-common-2.7.2.jar</span><br></pre></td></tr></table></figure><p>配置成功！</p><h2 id="Hadoop目录结构"><a href="#Hadoop目录结构" class="headerlink" title="Hadoop目录结构"></a>Hadoop目录结构</h2><p>1、查看Hadoop目录结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 hadoop-2.7.2]$ ll</span><br><span class="line">总用量 52</span><br><span class="line">drwxr-xr-x. 2 atguigu atguigu 4096 5月 22 2017 **bin**</span><br><span class="line">drwxr-xr-x. 3 atguigu atguigu 4096 5月 22 2017 **etc**</span><br><span class="line">drwxr-xr-x. 2 atguigu atguigu 4096 5月 22 2017 include</span><br><span class="line">drwxr-xr-x. 3 atguigu atguigu 4096 5月 22 2017 **lib**</span><br><span class="line">drwxr-xr-x. 2 atguigu atguigu 4096 5月 22 2017 libexec</span><br><span class="line">-rw-r--r--. 1 atguigu atguigu 15429 5月 22 2017 LICENSE.txt</span><br><span class="line">-rw-r--r--. 1 atguigu atguigu  101 5月 22 2017 NOTICE.txt</span><br><span class="line">-rw-r--r--. 1 atguigu atguigu 1366 5月 22 2017 README.txt</span><br><span class="line">drwxr-xr-x. 2 atguigu atguigu 4096 5月 22 2017 **sbin**</span><br><span class="line">drwxr-xr-x. 4 atguigu atguigu 4096 5月 22 2017 **share**</span><br></pre></td></tr></table></figure><p>2、重要目录</p><p>（1）bin目录：存放对Hadoop相关服务（HDFS,YARN）进行操作的脚本</p><p>（2）etc目录：Hadoop的配置文件目录，存放Hadoop的配置文件</p><p>（3）lib目录：存放Hadoop的本地库（对数据进行压缩解压缩功能）</p><p>（4）sbin目录：存放启动或停止Hadoop相关服务的脚本</p><p>（5）share目录：存放Hadoop的依赖jar包、文档、和官方案例</p><h1 id="Hadoop运行模式"><a href="#Hadoop运行模式" class="headerlink" title="Hadoop运行模式"></a>Hadoop运行模式</h1><p>Hadoop运行模式包括：本地模式、伪分布式模式以及完全分布式模式。</p><p>Hadoop官方网站：<a href="http://hadoop.apache.org/" target="_blank" rel="noopener">http://hadoop.apache.org/</a></p><h2 id="本地运行模式"><a href="#本地运行模式" class="headerlink" title="本地运行模式"></a>本地运行模式</h2><h3 id="官方Grep案例"><a href="#官方Grep案例" class="headerlink" title="官方Grep案例"></a>官方Grep案例</h3><ol><li>创建在hadoop-2.7.2文件下面创建一个input文件夹</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ mkdir input</span><br></pre></td></tr></table></figure><ol start="2"><li>将Hadoop的xml配置文件复制到input</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ cp etc/hadoop/*.xml input</span><br></pre></td></tr></table></figure><ol start="3"><li>执行share目录下的MapReduce程序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar grep input output 'dfs[a-z.]+'</span><br></pre></td></tr></table></figure><ol start="4"><li>查看输出结果</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ cat output/*</span><br></pre></td></tr></table></figure><h3 id="官方WordCount程序"><a href="#官方WordCount程序" class="headerlink" title="官方WordCount程序"></a>官方WordCount程序</h3><ol><li>创建在hadoop文件下面创建一个wcinput文件夹</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ mkdir wcinput</span><br></pre></td></tr></table></figure><ol start="2"><li>在wcinput文件下创建一个wc.input文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ cd wcinput</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ touch wc.input</span><br></pre></td></tr></table></figure><ol start="3"><li>编辑wc.input文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ vim wc.input</span><br><span class="line"></span><br><span class="line">hadoop yarn</span><br><span class="line">hadoop mapreduce</span><br><span class="line">root</span><br><span class="line">root</span><br></pre></td></tr></table></figure><ol start="4"><li>回到Hadoop目录，执行程序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount wcinput wcoutput</span><br></pre></td></tr></table></figure><ol start="6"><li>查看结果</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ cat wcoutput/part-r-00000</span><br><span class="line"></span><br><span class="line">root 2</span><br><span class="line">hadoop 2</span><br><span class="line">mapreduce    1</span><br><span class="line">yarn  1</span><br></pre></td></tr></table></figure><h2 id="伪分布式运行模式"><a href="#伪分布式运行模式" class="headerlink" title="伪分布式运行模式"></a>伪分布式运行模式</h2><h3 id="启动HDFS并运行MapReduce程序"><a href="#启动HDFS并运行MapReduce程序" class="headerlink" title="启动HDFS并运行MapReduce程序"></a>启动HDFS并运行MapReduce程序</h3><ol><li>分析</li></ol><p>​    （1）配置集群</p><p>​    （2）启动、测试集群增、删、查</p><p>​    （3）执行WordCount案例</p><ol start="2"><li>执行步骤</li></ol><p>（1）配置集群</p><p>​       （a）配置：hadoop-env.sh</p><p>​         Linux系统中获取JDK的安装路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# echo $JAVA_HOME</span><br><span class="line"></span><br><span class="line">/opt/module/jdk1.8.0_211</span><br></pre></td></tr></table></figure><p>​        修改hadoop-env.sh中的JAVA_HOME 路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_211</span><br></pre></td></tr></table></figure><p>（b）配置：core-site.xml</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定HDFS中NameNode的地址  --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop1:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 指定Hadoop运行时产生文件的存储目录  --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（c）配置：hdfs-site.xml</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  指定HDFS副本的数量 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）启动集群</p><p>​    （a）格式化<strong>NameNode</strong>（第一次启动时格式化，以后就不要总格式化）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><p>​    （b）启动NameNode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ sbin/hadoop-daemon.sh start namenode</span><br></pre></td></tr></table></figure><p>​    （c）启动DataNode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ sbin&#x2F;hadoop-daemon.sh start datanode</span><br></pre></td></tr></table></figure><p>（3）查看集群</p><p>​    （a）查看是否启动成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ jps</span><br><span class="line"></span><br><span class="line">13586 NameNode</span><br><span class="line">13668 DataNode</span><br><span class="line">13786 Jps</span><br></pre></td></tr></table></figure><p>​    （b）web端查看HDFS文件系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip:50070&#x2F;dfshealth.html#tab-overview</span><br></pre></td></tr></table></figure><p>​    （c）查看产生的Log日志</p><p>​        说明：在企业中遇到Bug时，经常根据日志提示信息去分析问题、解决Bug。</p><p>当前目录：hadoop/logs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 logs]$ ls</span><br><span class="line"></span><br><span class="line">hadoop-root-datanode-hadoop.root.com.log</span><br><span class="line">hadoop-root-datanode-hadoop.root.com.out</span><br><span class="line">hadoop-root-namenode-hadoop.root.com.log</span><br><span class="line">hadoop-root-namenode-hadoop.root.com.out</span><br><span class="line">SecurityAuth-root.audit</span><br><span class="line"></span><br><span class="line">[root@centos7 logs]$ cat hadoop-root-datanode-hadoop101.log</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ cd data/tmp/dfs/name/current/</span><br><span class="line"></span><br><span class="line">[root@centos7 current]$ cat VERSION</span><br><span class="line"></span><br><span class="line">**clusterID=CID-f0330a58-36fa-4a2a-a65f-2688269b5837**</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ cd data/tmp/dfs/data/current/</span><br><span class="line"></span><br><span class="line">**clusterID=CID-f0330a58-36fa-4a2a-a65f-2688269b5837**</span><br></pre></td></tr></table></figure><p>注意：格式化NameNode，会产生新的集群id,导致NameNode和DataNode的集群id不一致，集群找不到已往数据。所以，格式NameNode时，一定要先删除data数据和log日志，然后再格式化NameNode。</p><p>（4）操作集群</p><p>​       （a）在HDFS文件系统上<strong>创建</strong>一个input文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -mkdir -p /user/atguigu/input</span><br></pre></td></tr></table></figure><p>​       （b）将测试文件内容<strong>上传</strong>到文件系统上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$bin/hdfs dfs -put wcinput/wc.input</span><br><span class="line"></span><br><span class="line">/user/root/input/</span><br></pre></td></tr></table></figure><p>​       （c）<strong>查看</strong>上传的文件是否正确</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -ls /user/atguigu/input/</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -cat /user/atguigu/ input/wc.input</span><br></pre></td></tr></table></figure><p>​       （d）运行MapReduce程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/root/input/ /user/root/output</span><br></pre></td></tr></table></figure><p>​        （e）查看输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -cat /user/root/output/*</span><br></pre></td></tr></table></figure><p>浏览器查看，如图所示 查看output文件</p><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop5.png" alt=""></p><p>​       （f）将测试文件内容<strong>下载</strong>到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ hdfs dfs -get /user/atguigu/output/part-r-00000 ./wcoutput/</span><br></pre></td></tr></table></figure><p>​      （g）<strong>删除</strong>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ hdfs dfs -rm -r /user/atguigu/output</span><br></pre></td></tr></table></figure><h3 id="启动YARN并运行MapReduce程序"><a href="#启动YARN并运行MapReduce程序" class="headerlink" title="启动YARN并运行MapReduce程序"></a>启动YARN并运行MapReduce程序</h3><ol><li>分析</li></ol><p>​    （1）配置集群在YARN上运行MR</p><p>​    （2）启动、测试集群增、删、查</p><p>​    （3）在YARN上执行WordCount案例</p><ol start="2"><li>执行步骤    </li></ol><p>​    （1）配置集群</p><p>​       （a）配置yarn-env.sh.配置一下JAVA_HOME</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_211</span><br></pre></td></tr></table></figure><p>​        （b）配置yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Reducer获取数据的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定YARN的ResourceManager的地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop101<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​       （c）配置：mapred-env.sh.配置一下JAVA_HOME</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_144</span><br></pre></td></tr></table></figure><p>​       （d）配置： (对mapred-site.xml.template重新命名为) mapred-site.xml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ mv mapred-site.xml.template mapred-site.xml</span><br><span class="line">[root@centos7 hadoop]$ vim mapred-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定MR运行在YARN上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）启动集群</p><p>​    （a）启动前必须保证NameNode和DataNode已经启动</p><p>​    （b）启动ResourceManager</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ sbin/yarn-daemon.sh start resourcemanager</span><br></pre></td></tr></table></figure><p>​    （c）启动NodeManager</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ sbin/yarn-daemon.sh start nodemanager</span><br></pre></td></tr></table></figure><p>  （3）集群操作</p><p>​    （a）YARN的浏览器页面查看，如图所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip:8088&#x2F;cluster</span><br></pre></td></tr></table></figure><p> YARN的浏览器页面<img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop6.png" alt=""></p><p>​       （b）删除文件系统上的output文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -rm -R /user/atguigu/output</span><br></pre></td></tr></table></figure><p>​       （c）执行MapReduce程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/atguigu/input /user/atguigu/output</span><br></pre></td></tr></table></figure><p>​       （d）查看运行结果，如图所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -cat /user/atguigu/output/*</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop7.png" alt=""></p><h3 id="配置历史服务器"><a href="#配置历史服务器" class="headerlink" title="配置历史服务器"></a>配置历史服务器</h3><p>为了查看程序的历史运行情况，需要配置一下历史服务器。具体配置步骤如下：</p><ol><li>配置mapred-site.xml</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ vim mapred-site.xml</span><br></pre></td></tr></table></figure><p>在该文件里面增加如下配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 历史服务器端地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop101:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 历史服务器web端地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop101:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>启动历史服务器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ sbin&#x2F;mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure><ol start="3"><li>查看历史服务器是否启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$jps</span><br></pre></td></tr></table></figure><ol start="4"><li>查看JobHistory：<a href="http://ip:19888/jobgistory" target="_blank" rel="noopener">http://ip:19888/jobgistory</a></li></ol><h3 id="配置日志的聚集"><a href="#配置日志的聚集" class="headerlink" title="配置日志的聚集"></a>配置日志的聚集</h3><p>日志聚集概念：应用运行完成以后，将程序运行日志信息上传到HDFS系统上。</p><p>日志聚集功能好处：可以方便的查看到程序运行详情，方便开发调试。</p><p>注意：开启日志聚集功能，需要重新启动NodeManager 、ResourceManager和HistoryManager。</p><p>开启日志聚集功能具体步骤如下：</p><ol><li>配置yarn-site.xml</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ vi yarn-site.xml</span><br></pre></td></tr></table></figure><p>在该文件里面增加如下配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志聚集功能使能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 日志保留时间设置7天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>604800<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>关闭NodeManager 、ResourceManager和HistoryServer</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ sbin/yarn-daemon.sh stop resourcemanager</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ sbin/yarn-daemon.sh stop nodemanager</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ sbin/mr-jobhistory-daemon.sh stop historyserver</span><br></pre></td></tr></table></figure><ol start="3"><li>启动NodeManager 、ResourceManager和HistoryServer</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$]$ sbin/yarn-daemon.sh start resourcemanager</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ sbin/yarn-daemon.sh start nodemanager</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ sbin/mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure><ol start="4"><li>删除HDFS上已经存在的输出文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -rm -R /user/atguigu/output</span><br></pre></td></tr></table></figure><ol start="5"><li>执行WordCount程序</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/atguigu/input /user/atguigu/output</span><br></pre></td></tr></table></figure><ol start="6"><li>查看日志，如图所示</li></ol><p><a href="http://hadoop101:19888/jobhistory" target="_blank" rel="noopener">http://hadoop101:19888/jobhistory</a></p><p> Job History</p><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop8.png" alt=""></p><p>job运行情况<img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop9.png" alt=""></p><p>查看日志<img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop10.png" alt=""></p><h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><p>Hadoop配置文件分两类：默认配置文件和自定义配置文件，只有用户想修改某一默认配置值时，才需要修改自定义配置文件，更改相应属性值。</p><p>（1）默认配置文件：</p><table><thead><tr><th>要获取的默认文件</th><th>文件存放在Hadoop的jar包中的位置</th></tr></thead><tbody><tr><td>[core-default.xml]</td><td>hadoop-common-2.7.2.jar/  core-default.xml</td></tr><tr><td>[hdfs-default.xml]</td><td>hadoop-hdfs-2.7.2.jar/  hdfs-default.xml</td></tr><tr><td>[yarn-default.xml]</td><td>hadoop-yarn-common-2.7.2.jar/  yarn-default.xml</td></tr><tr><td>[mapred-default.xml]</td><td>hadoop-mapreduce-client-core-2.7.2.jar/  mapred-default.xml</td></tr></tbody></table><p>​    （2）自定义配置文件：</p><p>​    core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml四个配置文件存放在$HADOOP_HOME/etc/hadoop这个路径上，用户可以根据项目需求重新进行修改配置。</p><h2 id="完全分布式运行模式"><a href="#完全分布式运行模式" class="headerlink" title="完全分布式运行模式"></a>完全分布式运行模式</h2><p>TODO</p><h1 id="Hadoop编译源码"><a href="#Hadoop编译源码" class="headerlink" title="Hadoop编译源码"></a>Hadoop编译源码</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据" scheme="http://www.maishuren.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="hadoop" scheme="http://www.maishuren.top/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>golang学习八：切片</title>
    <link href="http://www.maishuren.top/posts/gloang/202006131039-index.html"/>
    <id>http://www.maishuren.top/posts/gloang/202006131039-index.html</id>
    <published>2020-06-13T02:39:26.000Z</published>
    <updated>2020-06-13T02:45:37.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><ul><li><p>切片的英文名称slice</p></li><li><p>切片:具有可变长度相同类型元素序列.</p></li><li><p>由于长度是可变,可以解决数组长度在数据个数不确定情况下浪费内存的问题.</p></li><li><p>切片和数组声明时语法最主要的区别就是长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">string</span>  <span class="comment">//切片</span></span><br><span class="line"><span class="keyword">var</span> array [<span class="number">3</span>]<span class="keyword">string</span> <span class="comment">//数组</span></span><br></pre></td></tr></table></figure></li><li><p>切片只声明时为nil,没有开辟内存空间,不能直接操作切片,需要先初始化</p><ul><li>注意:切片只能和nil进行判断是否相等<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">string</span>  <span class="comment">//切片</span></span><br><span class="line">fmt.Println(slice==<span class="literal">nil</span>)<span class="comment">//输出:true</span></span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>,slice)<span class="comment">//输出:0x0</span></span><br></pre></td></tr></table></figure><h1 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h1></li></ul></li><li><p>通过直接指定初始值定初始化一个切片变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names := []<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;</span><br><span class="line">fmt.Println(names)</span><br></pre></td></tr></table></figure></li><li><p>定义完切片后就可以通过<code>切片对象[脚标]</code>取出或修改切片中元素内容.语法和数组相同</p></li></ul><h1 id="切片是引用类型"><a href="#切片是引用类型" class="headerlink" title="切片是引用类型"></a>切片是引用类型</h1><ul><li>引用类型在变量之间赋值时传递的是地址.引用类型变量就是这个类型的指针.切片就是引用类型</li><li>值类型在变量之间赋值时传递的是值的副本<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names := []<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;</span><br><span class="line">names1 := names</span><br><span class="line">names1[<span class="number">0</span>] = <span class="string">"a"</span></span><br><span class="line">fmt.Println(names, names1)<span class="comment">//输出:[a world] [a world]</span></span><br><span class="line">fmt.Printf(<span class="string">"%p %p"</span>,names,names1)<span class="comment">//地址相同</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h1><ul><li><p>Go语言中可以使用make函数创建slice 、 map、 channel、 interface</p></li><li><p>使用make函数定义无内容,但是不是nil的切片,意味着切片已经申请了内存空间</p><ul><li><code>make(类型,初始长度[,初始容量])</code></li><li>初始容量可以省略,默认和长度相等<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)     <span class="comment">//长度为0的切片,没有第三个参数表示容量和长度相等</span></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="comment">//长度为0,容量为2</span></span><br><span class="line">fmt.Println(slice, slice1)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>长度表示切片中元素的实际个数,容量表示切片占用空间大小,且切片容量成倍增加.当增加到1024后按照一定百分比增加.</p><ul><li>len(slice) 查看切片的长度</li><li>cap(slice) 查看切片的容量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)     <span class="comment">//长度为0的切片,没有第三个参数表示容量和长度相等</span></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">3</span>) <span class="comment">//长度为0,容量为2</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice1), <span class="built_in">cap</span>(slice1))</span><br></pre></td></tr></table></figure><h1 id="append-函数"><a href="#append-函数" class="headerlink" title="append()函数"></a>append()函数</h1></li></ul></li><li><p>append()在Go语言标准库中源码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The append built-in function appends elements to the end of a slice. If</span></span><br><span class="line"><span class="comment">// it has sufficient capacity, the destination is resliced to accommodate the</span></span><br><span class="line"><span class="comment">// new elements. If it does not, a new underlying array will be allocated.</span></span><br><span class="line"><span class="comment">// Append returns the updated slice. It is therefore necessary to store the</span></span><br><span class="line"><span class="comment">// result of append, often in the variable holding the slice itself:</span></span><br><span class="line"><span class="comment">//slice = append(slice, elem1, elem2)</span></span><br><span class="line"><span class="comment">//slice = append(slice, anotherSlice...)</span></span><br><span class="line"><span class="comment">// As a special case, it is legal to append a string to a byte slice, like this:</span></span><br><span class="line"><span class="comment">//slice = append([]byte("hello "), "world"...)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span> []<span class="title">Type</span></span></span><br></pre></td></tr></table></figure></li><li><p>可以向切片中添加一个或多个值,添加后必须使用切片接收append()函数返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))<span class="comment">//输出:0 0</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"老张"</span>, <span class="string">"佳明哥"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))<span class="comment">//输出:2 2</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"smallming"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))<span class="comment">//输出:3 4</span></span><br></pre></td></tr></table></figure></li><li><p>如果添加一次添加多个值,且添加后的长度大于扩容一次的大小,容量和长度相等.等到下次添加内容时如果不超出扩容大小,在现在的基础上进行翻倍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//输出:0 0</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"老张"</span>, <span class="string">"佳明哥"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//输出:2 2</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"smallming"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//输出:3 4</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//输出:9 9</span></span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="string">"10"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//输出:10 18</span></span><br></pre></td></tr></table></figure></li><li><p>也可以把一个切片的内容直接添加到另一个切片中.需要注意语法中有三个点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">s1 := []<span class="keyword">string</span>&#123;<span class="string">"smallming"</span>, <span class="string">"佳明哥"</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, s1...) <span class="comment">//注意此处,必须有三个点</span></span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></table></figure></li></ul><h1 id="通过数组产生切片"><a href="#通过数组产生切片" class="headerlink" title="通过数组产生切片"></a>通过数组产生切片</h1><ul><li><p>定义数组后,取出数组中一个片段,这个片段就是切片类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"老张"</span>, <span class="string">"佳明哥"</span>, <span class="string">"smallming"</span>&#125;</span><br><span class="line">s := names[<span class="number">0</span>:<span class="number">2</span>]     <span class="comment">//包前不包后</span></span><br><span class="line">fmt.Printf(<span class="string">"%T"</span>, s) <span class="comment">//输出:[]string</span></span><br><span class="line">fmt.Println(s)      <span class="comment">//输出:[老张 佳明哥]</span></span><br></pre></td></tr></table></figure></li><li><p>切片是指针,指向数组元素地址,修改切片的内容,数组的内容会跟随变化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"老张"</span>, <span class="string">"佳明哥"</span>, <span class="string">"smallming"</span>&#125;</span><br><span class="line">s := names[<span class="number">0</span>:<span class="number">2</span>] <span class="comment">//包前不包后</span></span><br><span class="line">fmt.Printf(<span class="string">"%p %p"</span>,s,&amp;names[<span class="number">0</span>])<span class="comment">//输出的地址是相同的</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">"Go语言"</span></span><br><span class="line">fmt.Println(s)     <span class="comment">//输出:[Go语言 佳明哥]</span></span><br><span class="line">fmt.Println(names) <span class="comment">//输出:[Go语言 佳明哥 smallming]</span></span><br></pre></td></tr></table></figure></li><li><p>当切片内容在增加时</p><ul><li>如果增加后切片的长度没有超出数组,修改切片也是在修改数组</li><li>如果增加后切片的长度超出数组,会重新开辟一块空间放切片的内容</li><li>通过下面代码也正面了切片中内容存在一块连续空间(和数组一样)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">names := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"老张"</span>, <span class="string">"佳明哥"</span>, <span class="string">"smallming"</span>&#125;</span><br><span class="line">s := names[<span class="number">0</span>:<span class="number">2</span>] <span class="comment">//包前不包后</span></span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>,s,&amp;names[<span class="number">0</span>])</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">"Go语言"</span></span><br><span class="line">s=<span class="built_in">append</span>(s,<span class="string">"区块链"</span>)</span><br><span class="line">fmt.Println(s)     <span class="comment">//输出:[Go语言 佳明哥 区块链]</span></span><br><span class="line">fmt.Println(names) <span class="comment">//输出:[Go语言 佳明哥 区块链]</span></span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>,s,&amp;names[<span class="number">0</span>])<span class="comment">//地址相同</span></span><br><span class="line"></span><br><span class="line">s=<span class="built_in">append</span>(s,<span class="string">"超出了数组长度"</span>)</span><br><span class="line">fmt.Println(s)     <span class="comment">//输出:[Go语言 佳明哥 区块链 超出了数组长度]</span></span><br><span class="line">fmt.Println(names) <span class="comment">//输出:[Go语言 佳明哥 区块链]</span></span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>,s,&amp;names[<span class="number">0</span>])<span class="comment">//切片地址改变</span></span><br></pre></td></tr></table></figure><h1 id="删除实现"><a href="#删除实现" class="headerlink" title="删除实现"></a>删除实现</h1></li></ul></li><li><p>Go语言标准库中没有提供删除的函数</p></li><li><p>切片也可以取其中的一段形成子切片,利用这个特性可以实现删除效果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num := []<span class="keyword">int</span> &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">//要删除脚标为n的元素</span></span><br><span class="line">n:= <span class="number">2</span></span><br><span class="line">num1 :=num[<span class="number">0</span>:n]</span><br><span class="line">num1= <span class="built_in">append</span>(num1,num[n+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(num1)</span><br></pre></td></tr></table></figure></li></ul><h1 id="copy函数"><a href="#copy函数" class="headerlink" title="copy函数"></a>copy函数</h1><ul><li>通过copy函数可以把一个切片内容复制到另一个切片中</li><li>Go语言标准库源码定义如下<ul><li>第一个参数是目标切片,接收第二个参数内容</li><li>第二个参数是源切片,把内容拷贝到第一个参数中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The copy built-in function copies elements from a source slice into a</span></span><br><span class="line"><span class="comment">// destination slice. (As a special case, it also will copy bytes from a</span></span><br><span class="line"><span class="comment">// string to a slice of bytes.) The source and destination may overlap. Copy</span></span><br><span class="line"><span class="comment">// returns the number of elements copied, which will be the minimum of</span></span><br><span class="line"><span class="comment">// len(src) and len(dst).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(dst, src []Type)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li>拷贝时严格按照脚标进行拷贝.且不会对目标切片进行扩容</li></ul><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><ul><li>把短切片拷贝到长切片中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1:=[]<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">s2:=[]<span class="keyword">int</span> &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s2,s1)</span><br><span class="line">fmt.Println(s1)<span class="comment">//输出:[1 2]</span></span><br><span class="line">fmt.Println(s2)<span class="comment">//输出:[1 2 5 6]</span></span><br></pre></td></tr></table></figure></li><li>把长切片拷贝到短切片中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1:=[]<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">s2:=[]<span class="keyword">int</span> &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s1,s2)</span><br><span class="line">fmt.Println(s1)<span class="comment">//输出:[3 4]</span></span><br><span class="line">fmt.Println(s2)<span class="comment">//输出:[3 4 5 6]</span></span><br></pre></td></tr></table></figure></li><li>把切片片段拷贝到切片中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1:=[]<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">s2:=[]<span class="keyword">int</span> &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s1,s2[<span class="number">1</span>:])</span><br><span class="line">fmt.Println(s1)<span class="comment">//输出:[4 5]</span></span><br><span class="line">fmt.Println(s2)<span class="comment">//输出:[3 4 5 6]</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="使用copy完成删除元素"><a href="#使用copy完成删除元素" class="headerlink" title="使用copy完成删除元素"></a>使用copy完成删除元素</h1><ul><li>使用copy函数可以保证原切片内容不变<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">n := <span class="number">2</span> <span class="comment">//要删除元素的索引</span></span><br><span class="line">newSlice := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line"><span class="built_in">copy</span>(newSlice, s[<span class="number">0</span>:n])</span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, s[n+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(s)        <span class="comment">//原切片不变</span></span><br><span class="line">fmt.Println(newSlice) <span class="comment">//删除指定元素后的切片</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习七：goto和label</title>
    <link href="http://www.maishuren.top/posts/golang/202006131037-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006131037-index.html</id>
    <published>2020-06-13T02:37:05.000Z</published>
    <updated>2020-06-13T02:37:58.879Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h1><ul><li>goto是Go语言中的一个关键字</li><li>goto让编译器执行时跳转到特定位置<ul><li>Loop是标记名(Label),名称任意,习惯上名称为Loop<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"执行程序"</span>)</span><br><span class="line">i := <span class="number">6</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">6</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> Loop</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"if下面输出"</span>)</span><br><span class="line">Loop:</span><br><span class="line">fmt.Println(<span class="string">"loop"</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li>可以有多个,但是标签(Labal)定义了就必须使用<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"执行程序"</span>)</span><br><span class="line">i := <span class="number">6</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">6</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> Loop</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"if下面输出"</span>)</span><br><span class="line">Loop:</span><br><span class="line">fmt.Println(<span class="string">"loop"</span>)</span><br><span class="line">Loop1: <span class="comment">//报错:label Loop1 defined and not used</span></span><br><span class="line">fmt.Println(<span class="string">"Loop1"</span>)</span><br></pre></td></tr></table></figure></li><li>goto也可以用于跳出循环,执行指定标签位置代码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> abc</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"for循环执行结束"</span>)</span><br><span class="line">abc:</span><br><span class="line">fmt.Println(<span class="string">"abc"</span>)</span><br><span class="line">fmt.Println(<span class="string">"程序结束"</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习六：for循环</title>
    <link href="http://www.maishuren.top/posts/golang/202006131031-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006131031-index.html</id>
    <published>2020-06-13T02:31:47.000Z</published>
    <updated>2020-06-13T02:34:43.038Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><ul><li>循环:让程序多次执行相同的代码块</li><li>for循环是Go语言中唯一一个循环结构</li><li>for循环经典语法<ul><li>先执行表达式1</li><li>执行表达式判断是否成立,如果成立执行循环体</li><li>循环体执行完成后,执行表达式3</li><li>再次执行表达式2,判断是否成立.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for 表达式1;表达式2;表达式3&#123;</span><br><span class="line">  &#x2F;&#x2F;循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>for循环用的最多的地方就是遍历数组或切片等<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2></li><li>经典for循环结构中 , for关键字后面有三个表达式,且每个表达式都可以省略<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; j &lt; <span class="number">5</span>; &#123;</span><br><span class="line">fmt.Println(j)</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>for关键字后面也可以只有一个表达式,表示如果条件成立执行循环体代码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j &lt; <span class="number">5</span> &#123;</span><br><span class="line">fmt.Println(j)</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用for循环遍历数组"><a href="#使用for循环遍历数组" class="headerlink" title="使用for循环遍历数组"></a>使用for循环遍历数组</h2></li><li>可以通过数组的长度判断循环结束条件遍历整个数组<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"smallming"</span>, <span class="string">"张"</span>, <span class="string">"佳明哥"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">fmt.Println(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>for循环遍历数组等时常与range结合使用<ul><li>range函数返回两个值,第一个是脚标,第二个是内容<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"smallming"</span>, <span class="string">"张"</span>, <span class="string">"佳明哥"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, n := <span class="keyword">range</span> arr &#123;</span><br><span class="line"><span class="comment">//其中n=arr[i]</span></span><br><span class="line">fmt.Println(i, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="双重for循环"><a href="#双重for循环" class="headerlink" title="双重for循环"></a>双重for循环</h1><ul><li>可以在循环中执行循环,称为双重for循环</li><li>代码示例<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>上面代码中注意:<ul><li>只有当子循环完全执行结束才能再次执行外侧循环.因为循环体执行完才能执行表达式3<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1></li></ul></li><li>排序就是把一组数据按照特定的顺序重新排列.可以是升序,降序等</li><li>冒泡排序利用双重for循环把最大(小)的值移动到一侧,每次可以判断出一个数据,如果有n个数组,执行n-1次循环就可以完成排序</li><li>排序代码(升序还是降序主要是看if判断是大于还是小于)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(arr)-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(arr)</span><br></pre></td></tr></table></figure></li></ul><h1 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h1><ul><li>continue关键字控制结束本次 *<em>循环体 *</em>结束,执行表达式三.<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"开始"</span>)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> || i == <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在双重for循环中continue默认影响最内侧循环,与最外层循环无关<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="number">2</span>; k++ &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(k, i, <span class="string">"结束"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Go语言执行标签写法,可以通过定义标签让continue控制影响哪个for循环<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myfor:<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="number">2</span>; k++ &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> myfor</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(k, i, <span class="string">"结束"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="break"><a href="#break" class="headerlink" title="break"></a>break</h1></li><li>break可以中断for循环,无论for循环还有几次执行,立即停止<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在双重for循环中,break默认也影响到最近的for循环<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>break也可以通过定义标签,控制break对哪个for循环生效<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myfor:<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">break</span> myfor</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习五：常用数学函数与数组</title>
    <link href="http://www.maishuren.top/posts/golang/202006131027-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006131027-index.html</id>
    <published>2020-06-13T02:27:58.000Z</published>
    <updated>2020-06-13T02:30:55.227Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h1><ul><li>math包提供了基本数学常数和数学函数</li><li>math包提供的数学常数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mathematical constants.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">E   = <span class="number">2.71828182845904523536028747135266249775724709369995957496696763</span> </span><br><span class="line">Pi  = <span class="number">3.14159265358979323846264338327950288419716939937510582097494459</span> </span><br><span class="line">Phi = <span class="number">1.61803398874989484820458683436563811772030917980576286213544862</span> </span><br><span class="line">Sqrt2   = <span class="number">1.41421356237309504880168872420969807856967187537694807317667974</span></span><br><span class="line">SqrtE   = <span class="number">1.64872127070012814684865078781416357165377610071014801157507931</span> </span><br><span class="line">SqrtPi  = <span class="number">1.77245385090551602729816748334114518279754945612238712821380779</span> </span><br><span class="line">SqrtPhi = <span class="number">1.27201964951406896425242246173749149171560804184009624861664038</span> </span><br><span class="line">Ln2    = <span class="number">0.693147180559945309417232121458176568075500134360255254120680009</span> </span><br><span class="line">Log2E  = <span class="number">1</span> / Ln2</span><br><span class="line">Ln10   = <span class="number">2.30258509299404568401799145468436420760110148862877297603332790</span> </span><br><span class="line">Log10E = <span class="number">1</span> / Ln10</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Floating-point limit values.</span></span><br><span class="line"><span class="comment">// Max is the largest finite value representable by the type.</span></span><br><span class="line"><span class="comment">// SmallestNonzero is the smallest positive, non-zero value representable by the type.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MaxFloat32= <span class="number">3.40282346638528859811704183484516925440e+38</span>  <span class="comment">// 2**127 * (2**24 - 1) / 2**23</span></span><br><span class="line">SmallestNonzeroFloat32 = <span class="number">1.401298464324817070923729583289916131280e-45</span> <span class="comment">// 1 / 2**(127 - 1 + 23)</span></span><br><span class="line"></span><br><span class="line">MaxFloat64= <span class="number">1.797693134862315708145274237317043567981e+308</span> <span class="comment">// 2**1023 * (2**53 - 1) / 2**52</span></span><br><span class="line">SmallestNonzeroFloat64 = <span class="number">4.940656458412465441765687928682213723651e-324</span> <span class="comment">// 1 / 2**(1023 - 1 + 52)</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer limit values.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MaxInt8   = <span class="number">1</span>&lt;&lt;<span class="number">7</span> - <span class="number">1</span></span><br><span class="line">MinInt8   = <span class="number">-1</span> &lt;&lt; <span class="number">7</span></span><br><span class="line">MaxInt16  = <span class="number">1</span>&lt;&lt;<span class="number">15</span> - <span class="number">1</span></span><br><span class="line">MinInt16  = <span class="number">-1</span> &lt;&lt; <span class="number">15</span></span><br><span class="line">MaxInt32  = <span class="number">1</span>&lt;&lt;<span class="number">31</span> - <span class="number">1</span></span><br><span class="line">MinInt32  = <span class="number">-1</span> &lt;&lt; <span class="number">31</span></span><br><span class="line">MaxInt64  = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">MinInt64  = <span class="number">-1</span> &lt;&lt; <span class="number">63</span></span><br><span class="line">MaxUint8  = <span class="number">1</span>&lt;&lt;<span class="number">8</span> - <span class="number">1</span></span><br><span class="line">MaxUint16 = <span class="number">1</span>&lt;&lt;<span class="number">16</span> - <span class="number">1</span></span><br><span class="line">MaxUint32 = <span class="number">1</span>&lt;&lt;<span class="number">32</span> - <span class="number">1</span></span><br><span class="line">MaxUint64 = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>列举出常用的数学函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j <span class="keyword">float64</span> = <span class="number">12.3</span>, <span class="number">9.6</span></span><br><span class="line"><span class="comment">//向下取整,</span></span><br><span class="line">fmt.Println(math.Floor(i)) <span class="comment">//输出:12</span></span><br><span class="line"><span class="comment">//向上取整</span></span><br><span class="line">fmt.Println(math.Ceil(i)) <span class="comment">//输出:13</span></span><br><span class="line"><span class="comment">//绝对值</span></span><br><span class="line">fmt.Println(math.Abs(i)) <span class="comment">//输出:12.3</span></span><br><span class="line"><span class="comment">//返回值分别整数位和小数位,小数位可能出现误差</span></span><br><span class="line">num, decimal := math.Modf(i)</span><br><span class="line">fmt.Println(num, decimal)</span><br><span class="line"><span class="comment">//返回两个变量中大的值</span></span><br><span class="line">fmt.Println(math.Max(i, j)) <span class="comment">//输出:12.3</span></span><br><span class="line"><span class="comment">//返回两个变量中小的值</span></span><br><span class="line">fmt.Println(math.Min(i, j)) <span class="comment">//输出:9.6</span></span><br><span class="line"><span class="comment">//x的y次方</span></span><br><span class="line">fmt.Println(math.Pow(<span class="number">3</span>, <span class="number">2</span>)) <span class="comment">//输出:输出9</span></span><br><span class="line"><span class="comment">//四舍五入</span></span><br><span class="line">fmt.Println(math.Round(i)) <span class="comment">//输出:12</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><ul><li>math/rand实现了伪随机数生成器</li><li>在Go语言中随机数需要设置种子,如果不设置种子随机数的结果每次运行都相同。</li><li>默认种子是1,且相同种子产生的随机数是相同的.</li><li>可以使用当前时间的纳秒差计算随机数,在一定程度上保证了种子的唯一性<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">fmt.Println(rand.Int63n(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h2><ul><li><p>数组:具有固定长度相同类型元素序列</p></li><li><p>声明数组的语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var 对象名 [长度]元素类型</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(arr) <span class="comment">//输出:[0 0 0 0 0]</span></span><br></pre></td></tr></table></figure></li><li><p>数组就是内存中一段固定长度的连续空间.</p></li><li><p>声明数组后数组就会在内存中开辟一块连续空间,每个值称为数组的元素,且元素值为类型对应的默认值.例如int类型默认值为0,string类型默认值为空字符串</p></li><li><p>数组中每个元素按照顺序都有自己整数类型的脚标,脚标从第一个元素为0向后依次加1<br><img src="images/05_03_array.png" alt=""></p></li><li><p>数组中实际开发中主要作用是充当临时容器,因为声明一个数组变量比声明多个相同类型变量在操作时更加方便</p><h2 id="数组的创建和赋值"><a href="#数组的创建和赋值" class="headerlink" title="数组的创建和赋值"></a>数组的创建和赋值</h2></li><li><p>可以在声明数组时可以同时给数组赋值,赋值时要求长度必须大于等于初始值个数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:完整写法</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//方式二:短变量方式</span></span><br><span class="line">arr2 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//方式三:长度大于初始值个数.长度为4,只给前三个元素赋值,其余元素为默认值</span></span><br><span class="line">arr3 := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//方式四:赋值时不写长度,数组长度根据元素个数确定</span></span><br><span class="line">arr4 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以通过:<strong>数组名[脚标]</strong>对数组中元素进行操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(arr)</span><br><span class="line"><span class="comment">//通过脚标对数组中元素进行重新赋值</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">7</span></span><br><span class="line">fmt.Println(arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>])</span><br></pre></td></tr></table></figure></li><li><p>通过len(数组变量)获取数组长度,数组脚标最大值为长度减一,如果超出这个范围将会报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(arr))<span class="comment">//输出:3</span></span><br><span class="line">arr[<span class="number">3</span>]=<span class="number">5</span><span class="comment">//错误信息:invalid array index 3 (out of bounds for 3-element array)</span></span><br></pre></td></tr></table></figure><h2 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h2></li><li><p>在Go语言中数组是值类型,和之前学习的int或float64等类型相同,把一个数组变量赋值给另一个数组变量时为复制副本,重新开辟一块空间</p></li><li><p>使用==比较数组中值是否相等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr2:=arr</span><br><span class="line">fmt.Println(arr,arr2)</span><br><span class="line">fmt.Printf(<span class="string">"%p %p"</span>,&amp;arr,&amp;arr2)<span class="comment">//地址不同</span></span><br><span class="line">fmt.Println(arr==arr2)</span><br></pre></td></tr></table></figure></li></ul><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ul><li><p>二维数组表示一个数组变量中每个元素又是一个数组变量</p></li><li><p>声明二维数组的语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr [n][m]int</span><br></pre></td></tr></table></figure></li><li><p>使用 arr[n]时返回一个 arr[m]类型的数组</p></li><li><p>图示<br><img src="images/2_5_4_erweishuzu.png" alt="二维数组"></p></li></ul><h2 id="二维数组的使用"><a href="#二维数组的使用" class="headerlink" title="二维数组的使用"></a>二维数组的使用</h2><ul><li><p>声明并创建二维数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写在同一行,最后一个元素后面不需要有逗号</span></span><br><span class="line"><span class="comment">//arr6:=[3][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;</span></span><br><span class="line">arr := [<span class="number">3</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;, <span class="comment">//每个元素分行写,最后一个必须有逗号</span></span><br><span class="line">&#125;</span><br><span class="line">arr0 := arr[<span class="number">0</span>]</span><br><span class="line">fmt.Println(arr0[<span class="number">0</span>], arr0[<span class="number">1</span>], arr[<span class="number">2</span>])</span><br><span class="line"><span class="comment">//上面等效于下面的写法.习惯上多下下面的方式</span></span><br><span class="line">fmt.Println(arr[<span class="number">0</span>][<span class="number">0</span>], arr[<span class="number">0</span>][<span class="number">1</span>], arr[<span class="number">0</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2></li><li><p>理论上支持无限多维数组(只要内存够用)</p></li><li><p>三维数组可以理解成,一维数组中每个元素都是二维数组.四维数组理解成,一个一维数组中每个元素都是三维数组</p></li><li><p>无论是几维数组,都符号元素类型是相同的</p></li><li><p>实际开发中多维数组使用并不多,在一定程度上,程序员使用多维数组很容易出错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(arr)</span><br><span class="line"><span class="comment">//几维数组在操作元素时,数组变量后面就有几个[]</span></span><br><span class="line">fmt.Println(arr[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习四：流程控制</title>
    <link href="http://www.maishuren.top/posts/golang/202006131013-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006131013-index.html</id>
    <published>2020-06-13T02:13:40.000Z</published>
    <updated>2020-06-13T02:20:40.685Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="条件判断if"><a href="#条件判断if" class="headerlink" title="条件判断if"></a>条件判断if</h1><ul><li><p>在程序开发中经常需要判断.根据情况不同,程序执行的分支也不同.这个时候就可以使用if</p></li><li><p>if在程序中代表<strong>如果</strong>，如果条件成立就执行,否则就不执行</p></li><li><p>if的语法结构,在编译器中表达式两侧可以写小括号,但是通常省略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;单独使用</span><br><span class="line">if 表达式 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在if语法结构中所有表达式最终结果都是bool类型,true代表成立执行对应代码</p></li></ul><h2 id="if单独使用"><a href="#if单独使用" class="headerlink" title="if单独使用"></a>if单独使用</h2><ul><li>if单独使用时只影响到自己对应的代码块<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">score := <span class="number">65</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"及格"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以在if 表达式中声明变量,这个变量的范围只在if中能够使用<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> score:=<span class="number">60</span>; score&gt;=<span class="number">60</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"及格了"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>多个单独if使用时相互没有影响<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">score := <span class="number">65</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"及格"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> score &lt; <span class="number">60</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"不及格"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h2></li><li>程序调试,俗称:debug,通过特定的手段,一个语句一个语句的观察程序执行过程</li><li>debug经常用在调错中,当结果不符合预期,代码又很多时,debug可以找出哪行出现问题</li><li>程序调试步骤<ul><li>在程序中某行前面单击出现红色圆形</li><li>右键,选择Debug ‘文件名’</li><li>通过点击按钮或使用快捷键选择:向下执行(F6),进入调用(F5),向上跳出(F7)观察程序 </li></ul></li></ul><h2 id="if-…-else-结构"><a href="#if-…-else-结构" class="headerlink" title="if … else 结构"></a>if … else 结构</h2><ul><li><p>if 可以单独使用也可以结合else使用,当满足互斥条件时使用if…else结构</p></li><li><p>if..else结构中如果if成立执行if否则执行else</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">59</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">60</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"及格"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"不及格"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if多重嵌套"><a href="#if多重嵌套" class="headerlink" title="if多重嵌套"></a>if多重嵌套</h2></li><li><p>if每种结构都可以相互嵌套</p></li><li><p>理论讲if可以很多层嵌套</p></li><li><p>两层嵌套代码示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">score := <span class="number">77</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span> &#123;</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">70</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"及格"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">70</span> &amp;&amp; score &lt; <span class="number">80</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"中等"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">80</span> &amp;&amp; score &lt; <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"良好"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> &amp;&amp; score &lt;= <span class="number">100</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"优秀"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"不及格"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if-…-else-if-…-else结构"><a href="#if-…-else-if-…-else结构" class="headerlink" title="if … else if …. else结构"></a>if … else if …. else结构</h2></li><li><p>当需要判断多个条件时使用这种结构</p></li><li><p>这个结构是一个整体.只要有一个条件成立后面的都不判断,立即结束</p></li><li><p>else可以没有</p></li><li><p>改写嵌套代码,修改如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">score := <span class="number">77</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"优秀"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt;= <span class="number">80</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"良好"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt;= <span class="number">70</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"中等"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt;= <span class="number">60</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"及格"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"不及格"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="switch条件判断"><a href="#switch条件判断" class="headerlink" title="switch条件判断"></a>switch条件判断</h1><h2 id="switch结构介绍"><a href="#switch结构介绍" class="headerlink" title="switch结构介绍"></a>switch结构介绍</h2><ul><li>switch也属于条件判断的语句</li><li>支持多种写法,和if .. else if …else 结构的功能类似,但是里面的细节需要注意的地方更多</li><li>switch基本语法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch [定义变量;] [变量]&#123;</span><br><span class="line">  case [条件&#x2F;具体值]:</span><br><span class="line">  &#x2F;&#x2F;代码</span><br><span class="line">  case [条件&#x2F;具体值]:</span><br><span class="line">  &#x2F;&#x2F;代码</span><br><span class="line">  default:</span><br><span class="line">    &#x2F;&#x2F;代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>switch每个case分支默认只执行一个且是从上向下执行</li><li>default上下位置没有影响,当且仅当所有case都不成立时才执行default</li></ul><h2 id="switch用法-一"><a href="#switch用法-一" class="headerlink" title="switch用法(一)"></a>switch用法(一)</h2><ul><li>当变量只有固定的几个值时可以使用switch结构<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">16</span></span><br><span class="line"><span class="keyword">switch</span> num &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"2进制"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">fmt.Println(<span class="string">"8进制"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">fmt.Println(<span class="string">"10进制"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">fmt.Println(<span class="string">"16进制"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"内容不正确"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>switch也支持在条件位置定义变量,变量有效范围为当前switch<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> num := <span class="number">16</span>; num &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"2进制"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">fmt.Println(<span class="string">"8进制"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">fmt.Println(<span class="string">"10进制"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">fmt.Println(<span class="string">"16进制"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"内容不正确"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch用法-二"><a href="#switch用法-二" class="headerlink" title="switch用法(二)"></a>switch用法(二)</h2></li><li>当条件是范围而不是固定值时<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">score := <span class="number">71</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">fmt.Println(<span class="string">"优秀"</span>)</span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">fmt.Println(<span class="string">"良好"</span>)</span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">fmt.Println(<span class="string">"中等"</span>)</span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">fmt.Println(<span class="string">"及格"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"不及格"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch用法-三"><a href="#switch用法-三" class="headerlink" title="switch用法(三)"></a>switch用法(三)</h2></li><li>case条件支持多个值,每个值使用逗号分开<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">month := <span class="number">5</span></span><br><span class="line"><span class="keyword">switch</span> month &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">"31天"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"28或29天"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"30天"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="穿透和中断"><a href="#穿透和中断" class="headerlink" title="穿透和中断"></a>穿透和中断</h2></li><li>switch结构中某个最多只能执行一个case,使用fallthrough可以让下一个case/default继续执行<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> num := <span class="number">1</span>; num &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">"3"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">fmt.Println(<span class="string">"4"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"不是1,2,3,4"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>break可以用在switch和循环中,表示立即结束,无论当前结构后面还有多少代码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> num := <span class="number">1</span>; num &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">fmt.Println(<span class="string">"break后面代码都不执行"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">"3"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">fmt.Println(<span class="string">"4"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"不是1,2,3,4"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习三：golang基础语法</title>
    <link href="http://www.maishuren.top/posts/golang/202006122240-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006122240-index.html</id>
    <published>2020-06-12T14:40:57.000Z</published>
    <updated>2020-06-13T05:18:29.816Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h1><ul><li>在程序中输出使用频率很高,使用输出语句可以在程序执行过程中把一些结果输出到控制台中,程序员通过控制台中输出结果判断是否符合预期</li><li>在Go语言中有多种输出方式,不同的输出适用场景不同.归纳起来三种,每种还分为3种方式(原内容,原内容+ln,原内容+f)<ul><li>PrintXX()</li><li>FprintXX()</li><li>SprintXX()<h2 id="FprintXX"><a href="#FprintXX" class="headerlink" title="FprintXX"></a>FprintXX</h2></li></ul></li><li>FprintXX在Go Web中使用比较多,把内容写到响应流中.</li><li>以Fprintln()举例,源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fprintln formats using the default formats for its operands and writes to w.</span></span><br><span class="line"><span class="comment">// Spaces are always added between operands and a newline is appended.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes  written and any write error encountered.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">p := newPrinter()</span><br><span class="line">p.doPrintln(a)</span><br><span class="line">n, err = w.Write(p.buf)</span><br><span class="line">p.free()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>函数参数中第一个参数是输出流,后面参数是内容,表示把内容写入到输出流中</li><li>第一个返回值表示输出内容长度(字节数),第二个返回值表示错误,如果没有错误取值nil<ul><li>Fprintln()输出后会添加换行符,所以长度比内容多1个</li><li>Fprintln()源码中p.doPrintln(a)的源码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doPrintln is like doPrint but always adds a space between arguments</span></span><br><span class="line"><span class="comment">// and a newline after the last argument.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span> <span class="title">doPrintln</span><span class="params">(a []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> argNum, arg := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="keyword">if</span> argNum &gt; <span class="number">0</span> &#123;</span><br><span class="line">p.buf.WriteByte(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line">p.printArg(arg, <span class="string">'v'</span>)</span><br><span class="line">&#125;</span><br><span class="line">p.buf.WriteByte(<span class="string">'\n'</span>)<span class="comment">//此处多添加了换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>FprintXX()支持下面三种方式<ul><li>os.Stdout 表示控制台输出流<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Fprint(os.Stdout, <span class="string">"内容1"</span>)<span class="comment">//向流中写入内容,多个内容之间没有空格</span></span><br><span class="line">fmt.Fprintln(os.Stdout, <span class="string">"内容2"</span>)<span class="comment">//向流中写入内容后额外写入换行符,多个内容之间空格分割</span></span><br><span class="line">fmt.Fprintf(os.Stdout, <span class="string">"%s"</span>, <span class="string">"内容3"</span>)<span class="comment">//根据verb格式向流中写入内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PrintXX"><a href="#PrintXX" class="headerlink" title="PrintXX"></a>PrintXX</h2></li></ul></li><li>PrintXX支持下面三种方式<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"内容"</span>,<span class="string">"内容"</span>)<span class="comment">//输出内容后换行</span></span><br><span class="line">fmt.Print(<span class="string">"内容"</span>,<span class="string">"内容"</span>)<span class="comment">//输出内容后不换行</span></span><br><span class="line">fmt.Printf(<span class="string">"verb"</span>,<span class="string">"内容"</span>)<span class="comment">//根据verb输出指定格式内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>以Println()举例,源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Println formats using the default formats for its operands and writes to standard output.</span></span><br><span class="line"><span class="comment">// Spaces are always added between operands and a newline is appended.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written and any write error encountered.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以看出Println()底层实际是Fprintln(),返回值依然是内容长度和错误信息<h2 id="SPrintXX"><a href="#SPrintXX" class="headerlink" title="SPrintXX"></a>SPrintXX</h2></li><li>以Sprintln()举例,和Println()主要的区别是:<ul><li>Sprintln()把形成结果以字符串返回,并没有打印到控制台</li><li>Println()把结果打印到控制台,返回内容长度和错误</li></ul></li><li>所以从严格意义角度讲SprintXX不是打印输出,而更像字符串转换</li><li>源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sprintln formats using the default formats for its operands and returns the resulting string.</span></span><br><span class="line"><span class="comment">// Spaces are always added between operands and a newline is appended.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">p := newPrinter()</span><br><span class="line">p.doPrintln(a)</span><br><span class="line">s := <span class="keyword">string</span>(p.buf)</span><br><span class="line">p.free()</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>依然支持三种写法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Sprint(<span class="string">"内容1"</span>, <span class="string">"内容12"</span>)</span><br><span class="line">fmt.Sprintln(<span class="string">"内容2"</span>)</span><br><span class="line">fmt.Sprintf(<span class="string">"%s"</span>, <span class="string">"内容3"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><ul><li><p>在Go语言中可以使用<code>%+特定字母</code>或<code>/+特定字母</code>形成转义字符,这个表示特定含义的组合称为转义字符.</p></li><li><p>在Go语言中又称为verb</p></li><li><p>转义字符在Go语言中在以下两种情况使用频率较高</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"verb"</span>,内容)<span class="comment">//输出</span></span><br><span class="line">fmt.Scanf(<span class="string">"verb"</span>,接收变量)<span class="comment">//输入</span></span><br></pre></td></tr></table></figure><h2 id="进制简述"><a href="#进制简述" class="headerlink" title="进制简述"></a>进制简述</h2><ul><li>进制数在编程中经常遇见,进制数分为二进制,八进制,十进制和十六进制.其中十进制就是平时我们接触最多的</li><li>X进制数都满足:<ul><li>满X进一位</li><li>每位最大为X-1</li><li>第N位代表的X的(N-1)次方</li></ul></li><li>其中十六进制中a=10,b=11,c=12,d=13,e=14,f=15</li><li>举例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">十进制 18</span><br><span class="line">二进制 10010</span><br><span class="line">八进制 22</span><br><span class="line">十六进制 12</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用转义字符汇总"><a href="#常用转义字符汇总" class="headerlink" title="常用转义字符汇总"></a>常用转义字符汇总</h2><ul><li>以下为常用转义字符</li></ul><table><thead><tr><th>verb</th><th align="center">含义</th></tr></thead><tbody><tr><td>%d</td><td align="center">十进制整数</td></tr><tr><td>%x,%X</td><td align="center">大小写方式显示十六进制整数</td></tr><tr><td>%o</td><td align="center">八进制整数</td></tr><tr><td>%b</td><td align="center">二进制整数</td></tr><tr><td>%f,%g,%e</td><td align="center">浮点数</td></tr><tr><td>%t</td><td align="center">布尔值</td></tr><tr><td>%c</td><td align="center">字符</td></tr><tr><td>%s</td><td align="center">字符串</td></tr><tr><td>%q</td><td align="center">带双引号字符串</td></tr><tr><td>%v</td><td align="center">内置格式内容</td></tr><tr><td>%T</td><td align="center">类型</td></tr><tr><td>%p</td><td align="center">内存地址</td></tr><tr><td>%%</td><td align="center">字符%</td></tr><tr><td>\n</td><td align="center">换行</td></tr><tr><td>\t</td><td align="center">缩进</td></tr></tbody></table><h1 id="用户输入简介"><a href="#用户输入简介" class="headerlink" title="用户输入简介"></a>用户输入简介</h1><ul><li><p>用户输入在平时练习中使用频率较高.</p></li><li><p>程序运行时,运行到接收用户输入语句,程序阻塞,用户在控制台输入内容后,把内容赋值给对应的变量,程序继续运行.</p></li><li><p>在Go语言中有多种接收用户输入的方式,其中使用fmt包的Scan函数使用最简单</p><h2 id="接收用户输入的几种方式"><a href="#接收用户输入的几种方式" class="headerlink" title="接收用户输入的几种方式"></a>接收用户输入的几种方式</h2></li><li><p>使用<code>Scanln(&amp;变量名,&amp;变量名)</code>的方式接收.</p><ul><li>输入的内容必须都在同一行</li><li>每个内容之间使用空格分割</li><li>回车换行后表示停止输入.</li><li>如果希望接收3个值,而在控制台只输入2个值,回车后也停止接收</li><li>如果希望接收2个值,而在控制台输入3个,回车后只能接收两个值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name, age <span class="keyword">string</span> <span class="comment">//声明两个字符串变量,变量在本章节后面讲解</span></span><br><span class="line">fmt.Print(<span class="string">"请输入姓名和姓名:"</span>)</span><br><span class="line">fmt.Scanln(&amp;name, &amp;age) <span class="comment">//此处&amp;变量名是地址.指针地址在后面章节境界</span></span><br><span class="line">fmt.Println(<span class="string">"接收到内容为:"</span>, name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>也可以使用<code>fmt.Scanf(verb,&amp;变量)</code>按照特定的格式进行输入.</p><ul><li>下面例子演示的每次换行输入一个内容<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a,b <span class="keyword">string</span></span><br><span class="line">fmt.Scanf(<span class="string">"%s\n%s"</span>,&amp;a,&amp;b);</span><br><span class="line">fmt.Printf(<span class="string">"%s\n%s"</span>,a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>需要注意,如果同行输入两个字符串,中间使用空格,否则编译器无法对输入内容拆分</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line"><span class="comment">//输入时必须输入: aaa bbb</span></span><br><span class="line"><span class="comment">//如果中间没有空格则把所有内容都赋值给了a</span></span><br><span class="line">fmt.Scanf(<span class="string">"%s%s"</span>,&amp;a,&amp;b)</span><br><span class="line">fmt.Println(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态语言和动态语言"><a href="#静态语言和动态语言" class="headerlink" title="静态语言和动态语言"></a>静态语言和动态语言</h1><ul><li>静态类型语言和强类型语言是同一个意思,表示在编译期就确定了类型,而且类型是不可以改变的</li><li>动态类型语言和弱类型语言是同一个意思,表示在运行过程中才能确定,且内容是什么类型变量类型跟随变化</li></ul><h2 id="Go语言变量简介"><a href="#Go语言变量简介" class="headerlink" title="Go语言变量简介"></a>Go语言变量简介</h2><ul><li><p>Go语言和其他语言一样都有基本存储容器.可以存储一个或多个值在程序中,方便程序中多次使用容器中内容,这个容器称为:<strong>变量</strong></p></li><li><p>Go语言虽然是静态类型语言,但是支持动态类型语言语法,因为Go语言希望程序员少声明变量,增加GC效率</p><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2></li><li><p>以字母或下划线开头(Go语言中多不以_开头)</p></li><li><p>后面可以是任意数量的字符、数字和下划线</p></li><li><p>区分大小写</p></li><li><p>不能是关键字(关键字具备特定含义),下面是Go语言的关键字</p><table><thead><tr><th align="center">关键字如下</th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">break</td><td align="center">default</td><td align="center">func</td><td align="center">interface</td><td align="center">select</td></tr><tr><td align="center">case</td><td align="center">defer</td><td align="center">go</td><td align="center">map</td><td align="center">struct</td></tr><tr><td align="center">chan</td><td align="center">else</td><td align="center">goto</td><td align="center">package</td><td align="center">switch</td></tr><tr><td align="center">const</td><td align="center">fallthrough</td><td align="center">if</td><td align="center">range</td><td align="center">type</td></tr><tr><td align="center">continue</td><td align="center">for</td><td align="center">import</td><td align="center">return</td><td align="center">var</td></tr></tbody></table></li><li><p>可以是保留字,但是建议不使用保留字做为变量名,下面是Go语言的保留字</p><table><thead><tr><th align="center">保留字如下</th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">true</td><td align="center">false</td><td align="center">iota</td><td align="center">nil</td><td align="center">int</td></tr><tr><td align="center">int8</td><td align="center">int16</td><td align="center">int32</td><td align="center">int64</td><td align="center">unit</td></tr><tr><td align="center">unit8</td><td align="center">unit16</td><td align="center">unit32</td><td align="center">unitptr</td><td align="center">float32</td></tr><tr><td align="center">float64</td><td align="center">complex128</td><td align="center">complex64</td><td align="center">bool</td><td align="center">byte</td></tr><tr><td align="center">rune</td><td align="center">string</td><td align="center">error</td><td align="center">make</td><td align="center">len</td></tr><tr><td align="center">cap</td><td align="center">new</td><td align="center">append</td><td align="center">copy</td><td align="center">close</td></tr><tr><td align="center">deletecomplex</td><td align="center">real</td><td align="center">imag</td><td align="center">panic</td><td align="center"></td></tr><tr><td align="center">recover</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li><li><p>在同一范围内不允许出现同名变量</p></li><li><p>Go语言要求变量声明后至少使用一次(赋值不属于使用)</p></li></ul><h2 id="单个变量声明及赋值"><a href="#单个变量声明及赋值" class="headerlink" title="单个变量声明及赋值"></a>单个变量声明及赋值</h2><ul><li>先声明后赋值(声明后开辟内存,不同类型变量都有不同初值)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法:</span></span><br><span class="line"><span class="comment">//1. 声明</span></span><br><span class="line"><span class="keyword">var</span> 变量名 类型</span><br><span class="line"><span class="comment">//2. 赋值</span></span><br><span class="line">变量名=值</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例:</span></span><br><span class="line"><span class="keyword">var</span> smallming <span class="keyword">string</span></span><br><span class="line">smallming = <span class="string">"英文名"</span></span><br></pre></td></tr></table></figure></li><li>声明并赋值(此方式不建议)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法:</span></span><br><span class="line"><span class="keyword">var</span> 变量名 类型 = 值</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">var</span> smallming <span class="keyword">string</span> = <span class="string">"英文名"</span></span><br></pre></td></tr></table></figure></li><li>声明并赋值(省略类型,变量类型取决于值的类型)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法:</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = 值</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例:</span></span><br><span class="line"><span class="keyword">var</span> smallming = <span class="string">"英文名"</span></span><br></pre></td></tr></table></figure></li><li>短变量(只能在函数内使用)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法:</span></span><br><span class="line">变量名 := 值</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例:</span></span><br><span class="line">smallming := <span class="string">"英文名"</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="声明多个变量和赋值"><a href="#声明多个变量和赋值" class="headerlink" title="声明多个变量和赋值"></a>声明多个变量和赋值</h2><ul><li>先声明后赋值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="keyword">int</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">fmt.Println(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明时赋值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a, b, c, d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">false</span></span><br><span class="line">fmt.Println(a, b, c, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明并赋值,推荐方式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="literal">true</span></span><br><span class="line">c = <span class="string">"测试"</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用短变量给多个变量赋值时,必须要保证至少有个变量是没有声明的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="literal">true</span></span><br><span class="line">c = <span class="string">"测试"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//短变量操作多个值时只要保证里面至少有一个新变量</span></span><br><span class="line">b, c, d := <span class="literal">false</span>, <span class="string">"smallming"</span>, <span class="number">3</span></span><br><span class="line">fmt.Println(a, b, c, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h1><h2 id="整型概述"><a href="#整型概述" class="headerlink" title="整型概述"></a>整型概述</h2><ul><li>在Go语言中可以进行<strong>数学运算</strong>的类型分为整型和浮点型</li><li>所有的整数数字存储到整型中就可以进行数学运算<ul><li>整型和整型运算的结果还是整型.(5/2=2)</li><li>都是整型,但是int8和int16之间不可以进行运算,必须进行类型转换</li></ul></li><li>整型分为有符号整型和无符号整型<ul><li>有符号整型有正数和负数.其二进制最高位表示符号,0为正数1为负数.int和intx为有符号整型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;int8 举例</span><br><span class="line">0000 0010&#x3D;2</span><br><span class="line">1000 0010&#x3D;-2</span><br></pre></td></tr></table></figure></li><li>无符号整型只能取大于等于0的整数.其二进制最高位表示真实数字.unit和unitx为无符号整型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;uint8 举例</span><br><span class="line">0000 0010&#x3D;2</span><br><span class="line">1000 0010&#x3D;130</span><br></pre></td></tr></table></figure></li></ul></li><li>整型取值范围和作用<ul><li>有符号整数统一公式为:-2的n-1次幂到2的n-1次幂减一</li><li>无符号整数统一公式为:0到2的n次幂减一<table><thead><tr><th align="right">类型</th><th align="left">取值范围</th></tr></thead><tbody><tr><td align="right">int8</td><td align="left">[-128 , 127]</td></tr><tr><td align="right">int16</td><td align="left">[-32768 , 32767]</td></tr><tr><td align="right">int32</td><td align="left">[-2147483648 , 2147483647] Go语言中没有字符类型,所有字符都使用int32存储</td></tr><tr><td align="right">int64</td><td align="left">[-9223372036854775808 , 9223372036854775807]</td></tr><tr><td align="right">int</td><td align="left">受限于计算机系统,系统是多少位,int为多少位</td></tr><tr><td align="right">uint8</td><td align="left">[0 , 255]</td></tr><tr><td align="right">uint16</td><td align="left">[0 , 65535]</td></tr><tr><td align="right">uint32</td><td align="left">[0 , 4294967295]</td></tr><tr><td align="right">uint64</td><td align="left">[0 , 18446744073709551615]</td></tr><tr><td align="right">uint</td><td align="left">受限于计算机系统,系统是多少位,uint为多少位</td></tr><tr><td align="right">rune</td><td align="left">与int32类似,常用在获取值的Unicode码</td></tr><tr><td align="right">byte</td><td align="left">与uint8类似.强调值为原始数据.一个字节占用8个二进制</td></tr><tr><td align="right">uintptr</td><td align="left">大小不确定,类型取决于底层编程</td></tr></tbody></table></li></ul></li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li><p>Go语言是静态类型语言,并且不具备低精度向高精度自动转换功能,所以不同类型变量之间相互赋值需要进行类型转换.</p></li><li><p>例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//声明3个类型变量</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int32</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int64</span> = <span class="number">3</span></span><br><span class="line">fmt.Println(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="comment">//把int32转换为int64</span></span><br><span class="line">a = <span class="keyword">int</span>(b)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把int64转换成int32</span></span><br><span class="line">b = <span class="keyword">int32</span>(c)</span><br><span class="line">fmt.Println(b, c)</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把int转换为int64</span></span><br><span class="line">c = <span class="keyword">int64</span>(a)</span><br><span class="line">fmt.Println(a, c)</span><br><span class="line">c = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同进制整数"><a href="#不同进制整数" class="headerlink" title="不同进制整数"></a>不同进制整数</h2></li><li><p>支持八进制,十进制,十六进制数字创建整型,最后由系统转换为十进制</p></li><li><p>不支持二进制值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//默认表示十进制</span></span><br><span class="line">d := <span class="number">17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0开头表示八进制</span></span><br><span class="line">o := <span class="number">021</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0x开头表示十六进制</span></span><br><span class="line">x := <span class="number">0x11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//e2表示10的2次方</span></span><br><span class="line">e := <span class="number">11e2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">fmt.Println(d, o, x, e)</span><br><span class="line"></span><br><span class="line"><span class="comment">//把变量d中内容转换为二进制</span></span><br><span class="line">b := fmt.Sprintf(<span class="string">"%b"</span>, d)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h1><h2 id="字符型概述"><a href="#字符型概述" class="headerlink" title="字符型概述"></a>字符型概述</h2><ul><li>字符型存放单个字母或单个文字</li><li>Go语言不支持字符类型,在Go语言中所有字符值都转换为对应的编码表中int32值</li><li>Go语言默认使用UTF-8编码<h2 id="编码发展历史"><a href="#编码发展历史" class="headerlink" title="编码发展历史"></a>编码发展历史</h2></li><li>最开始使用8个可开合晶体管表示世界万物,这就是<strong>字节</strong>的由来.后来生产出可以控制字节的机器,出现了<strong>计算机</strong></li><li>把字节中32以下情况称为<strong>控制码</strong>,后在控制码基础上添加空格、标点符号、数字、大小写字母等直到127,最终形成了<strong>ANSI</strong>的ASCII码(American Standard Code for Information Interchange，美国信息交换标准代码),这时已经较好的支持英文了</li><li>随机计算机在全球的应用,在原ASCII基础上添加了新的字母、符号、横线竖线等直到255号,从128到255被称为<strong>扩展字符集</strong>但是此时计算机还是在只支持英文</li><li>等中国开始使用计算机,为了支持中文,保留了前127号,称这些为<strong>半角</strong>,把后面的内容以两个字节拼接形成中文汉字和表单符号,这后半部分就是<strong>全角</strong>,其中汉字6763个满足中文大部分情况的要求,称这个编码为<strong>GB2312</strong></li><li>随着计算机在中国的普及,使用GB2312时有的汉字无法打出,又在GB2312基础上添加了近20000个汉字(包括繁体和符号等)形成<strong>GBK</strong>,后来为支持少数民族又在GBK基础上推出<strong>GB18080</strong></li><li>全球中每个国家都有着自己的一套编码,ISO国际为了统一标准,重新定义一套编码,希望包含全球所有的文字和符号,俗称<strong>Unicode</strong></li><li>随着互联网的快速发展,为解决Unicode网络传输中流浪浪费问题,出现了<strong>UTF</strong>编码,有UTF-8(8位传输)和UTF-16(16为传输)两种.其中UTF-8使用最多,为变长编码方式,中文占3个自己.</li></ul><h2 id="字符示例"><a href="#字符示例" class="headerlink" title="字符示例"></a>字符示例</h2><ul><li>示例<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义数字</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">rune</span>=<span class="number">0x5F20</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出汉字张</span></span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>,i)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取转换后的内容</span></span><br><span class="line">c:=fmt.Sprintf(<span class="string">"%c"</span>,i)</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>也可以使用单引号表示一个字符类型,但是本质还是正数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="string">'张'</span></span><br><span class="line">fmt.Println(c)      <span class="comment">//24352</span></span><br><span class="line">fmt.Printf(<span class="string">"%T"</span>, c) <span class="comment">//int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h1><h2 id="浮点数概述"><a href="#浮点数概述" class="headerlink" title="浮点数概述"></a>浮点数概述</h2><ul><li><p>浮点类型用于存储带有小数点的数字</p></li><li><p>一个整数数值可以赋值给浮点类型但是一个整型变量不可以赋值给浮点类型</p></li><li><p>浮点数进行运算的结果是浮点数</p></li><li><p>Go语言中浮点类型有两个</p><ul><li>float32</li><li>float64<h2 id="浮点数取值范围"><a href="#浮点数取值范围" class="headerlink" title="浮点数取值范围"></a>浮点数取值范围</h2></li></ul></li><li><p>float32和float64取值范围</p><table><thead><tr><th align="center">类型</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">float32</td><td align="center">3.40282346638528859811704183484516925440e+38</td></tr><tr><td align="center">float64</td><td align="center">1.797693134862315708145274237317043567981e+308</td></tr></tbody></table></li><li><p>可以通过math或中常量快速获取浮点数的最大值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(math.MaxFloat32)</span><br><span class="line">fmt.Println(math.MaxFloat64)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2></li><li><p>float32和float64之间不可以相互运算,需要进行类型转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">1.5</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float64</span> = <span class="number">3.3</span>         <span class="comment">//默认是float64类型</span></span><br><span class="line">fmt.Println(a + <span class="keyword">float32</span>(b)) <span class="comment">//float64向float32转换</span></span><br><span class="line">fmt.Println(<span class="keyword">float64</span>(a) + b) <span class="comment">//float32向float64转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>建议使用float64,虽然占用空间多,但是float32在累计运算时可能出现误差</p></li><li><p>整型运算和浮点型运算结果类型为本身类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> c, d <span class="keyword">float64</span> = <span class="number">3</span>, <span class="number">2</span></span><br><span class="line">fmt.Println(a / b) <span class="comment">//结果为int,舍去小数部分(向下取整)</span></span><br><span class="line">fmt.Println(c / d) <span class="comment">//结果为float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h1><h2 id="布尔类型介绍"><a href="#布尔类型介绍" class="headerlink" title="布尔类型介绍"></a>布尔类型介绍</h2><ul><li>布尔类型关键字<strong>bool</strong></li><li>布尔类型可取值只有两个<ul><li>true :代表真,表示成立,二进制表示时1表示真</li><li>false:代表假,表示不成立,二进制表示时0表示假</li></ul></li><li>布尔类型不能与其他类型相互转换</li><li>布尔类型占用1个byte</li><li>布尔类型单独使用较少,多用在判断中<h2 id="布尔类型代码示例"><a href="#布尔类型代码示例" class="headerlink" title="布尔类型代码示例"></a>布尔类型代码示例</h2></li><li>创建bool类型变量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span></span><br><span class="line">d := <span class="literal">false</span></span><br><span class="line">fmt.Println(a, b, c, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用unsafe包下的Sizeof()可以查看类型占用字节<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="literal">false</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>虽然bool类型占用一个byte,但是bool不能和byte或int8相互转换<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int8</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">byte</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line">fmt.Println(a, b, c)</span><br><span class="line">a = <span class="keyword">int8</span>(c) <span class="comment">//cannot convert c (type bool) to type int8</span></span><br><span class="line">b = <span class="keyword">byte</span>(c) <span class="comment">//cannot convert c (type bool) to type byte</span></span><br><span class="line">c = <span class="keyword">bool</span>(a) <span class="comment">//cannot convert a (type int8) to type bool</span></span><br><span class="line">c = <span class="keyword">bool</span>(b) <span class="comment">//cannot convert b (type byte) to type bool</span></span><br><span class="line">b = <span class="keyword">byte</span>(a) <span class="comment">//可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>布尔类型除了直接赋值true或false以外,还是可以表达式赋值,借助比较运算符、逻辑运算符等<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">5</span> &gt; <span class="number">3</span></span><br><span class="line">fmt.Println(a)      <span class="comment">//输出:true</span></span><br><span class="line">fmt.Printf(<span class="string">"%T"</span>, a) <span class="comment">//输出:bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="运算符概述"><a href="#运算符概述" class="headerlink" title="运算符概述"></a>运算符概述</h2><ul><li>Go语言支持运算符,算数运算符、比较运算符、逻辑运算符、赋值运算符、关系运算符、位运算符等</li><li>不同的运算符使用场景不同,运算符一起使用时还需要注意优先级问题</li></ul><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><ul><li>算数运算符对浮点类型和整型进行数学运算</li><li>乘法、除法优先级高于取余,取余高于加法、减法<table><thead><tr><th align="right">运算符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="right">+</td><td align="left">加法</td></tr><tr><td align="right">-</td><td align="left">减法</td></tr><tr><td align="right">*</td><td align="left">乘法</td></tr><tr><td align="right">/</td><td align="left">除法</td></tr><tr><td align="right">%</td><td align="left">取余. 例如 12%5=2  8%4=0</td></tr><tr><td align="right">++</td><td align="left">自增一,只能单独使用,没有返回值</td></tr><tr><td align="right">–</td><td align="left">自减一,和++语法相同</td></tr></tbody></table></li></ul><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ul><li>比较运算符用于比较两个内容的大小,判断和分支中使用频率较高<table><thead><tr><th align="right">运算符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="right">==</td><td align="left">是否等于,返回值为bool类型,判断是否成立</td></tr><tr><td align="right">!=</td><td align="left">不等于</td></tr><tr><td align="right">&gt;</td><td align="left">大于</td></tr><tr><td align="right">&gt;=</td><td align="left">大于等于</td></tr><tr><td align="right">&lt;</td><td align="left">小于</td></tr><tr><td align="right">&lt;=</td><td align="left">小于等于</td></tr></tbody></table></li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul><li>逻辑运算符在判断和分支中使用频率较高<table><thead><tr><th align="right">运算符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="right">!</td><td align="left">逻辑非,取结果的反</td></tr><tr><td align="right">&amp;&amp;</td><td align="left">逻辑与,只有两侧同时为真时总体结果为真</td></tr><tr><td align="right">||</td><td align="left">逻辑或,两侧只要有一个为真时整体为真</td></tr></tbody></table></li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul><li>赋值运算符目的给变量赋值</li><li>提供了很多运算的简单方式<table><thead><tr><th align="right">运算符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="right">=</td><td align="left">右侧内容赋值给左侧变量.例如:A=B 把B赋值给A</td></tr><tr><td align="right">+=</td><td align="left">A+=B 相当于 A=A+B</td></tr><tr><td align="right">-+</td><td align="left">A-=B 相当于 A=A-B</td></tr><tr><td align="right">*=</td><td align="left">A *= B相当于 A等于A乘以B</td></tr><tr><td align="right">/=</td><td align="left">A/=B 相当于A=A/B</td></tr><tr><td align="right">%=</td><td align="left">A%=B 相当于 A=A%B</td></tr><tr><td align="right">&lt;&lt;=</td><td align="left">A&lt;&lt;=B 相当于 A=A&lt;&lt;B</td></tr><tr><td align="right">&gt;&gt;=</td><td align="left">A&gt;&gt;=B 相当于 A=A&gt;&gt;B</td></tr><tr><td align="right">&amp;=</td><td align="left">A&amp;=B 相当于 A=A&amp;B</td></tr><tr><td align="right">|=</td><td align="left">A|=B 相当于 A=A|B</td></tr><tr><td align="right">^=</td><td align="left">A^=B 相当于 A=A^B</td></tr></tbody></table></li></ul><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><ul><li><p>位运算时,需要知道几个概念,原码、反码、补码.正数在计算机中二进制还是原值,负数在计算机中存储的是补码</p></li><li><p>原码</p><ul><li>正数的原码还是正数</li><li>负数的原码是负数绝对值的二进制表示</li><li>以8位二进制方式表示<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原码为:0000 0011</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int8</span>=<span class="number">3</span></span><br><span class="line"><span class="comment">//原码为:0000 0010</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int8</span>=<span class="number">-2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>反码</p><ul><li>正数的反码还是正数</li><li>负数的反码是所有位取反<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反码为:0000 0011</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int8</span>=<span class="number">3</span></span><br><span class="line"><span class="comment">//反码为:1111 1101</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int8</span>=<span class="number">-2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>补码</p><ul><li>正数的补码还是正数</li><li>负数的补码为负数的反码加一 . <strong>负数的补码就是负数在计算机中二进制表示方式</strong></li><li>想要知道负数二进制对应十进制数字就是补码–&gt;反码–&gt;原码–&gt;添加负号</li><li>如果是16位只需要在负数前面添加8个1 ,正数前面添加8个零<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//补码为:0000 0011</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int8</span>=<span class="number">3</span></span><br><span class="line"><span class="comment">//补码为:1111 1110</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int8</span>=<span class="number">-2</span></span><br></pre></td></tr></table></figure><h3 id="Go语言中位运算符"><a href="#Go语言中位运算符" class="headerlink" title="Go语言中位运算符"></a>Go语言中位运算符</h3></li></ul></li><li><p>位运算在算法中使用频率较高</p></li><li><p>区块链学习中密码学部分的很多算法都是使用的位运算</p></li></ul><table><thead><tr><th align="right">运算符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="right">&lt;&lt;</td><td align="left">二进制左移</td></tr><tr><td align="right">&gt;&gt;</td><td align="left">二进制右移</td></tr><tr><td align="right">|</td><td align="left">位运算或OR,有1取1”</td></tr><tr><td align="right">&amp;</td><td align="left">位运算与AND.转换二进制,都为1取1</td></tr><tr><td align="right">^</td><td align="left">位运算异或XOR,二阶运算相同为0不同为1.一阶运算加一后正数交互(正数变负数,负数变正数)</td></tr><tr><td align="right">&amp;^</td><td align="left">位清空(AND NOT),如果右侧0左侧不变,如果右侧为1,左侧一定清零.a&amp;^b=a&amp;(^b)</td></tr></tbody></table><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串概述"><a href="#字符串概述" class="headerlink" title="字符串概述"></a>字符串概述</h2><ul><li>字符串是一段不可变的字符序列.内容是任意内容,可以是一段文字也可以是一串数字,但是字符串类型数字不能进行数学运算,必须转换成整型或浮点型</li><li>字符串类型关键字:string</li><li>创建字符串类型变量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"smallming"</span></span><br><span class="line">s1 := <span class="string">"smallming"</span></span><br></pre></td></tr></table></figure></li><li>字符串类型的值使用双引号””扩上,内容支持转义字符串.两侧使用反单引号时原格式输出<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="string">"a\tbc"</span></span><br><span class="line">b := <span class="string">`a\tbc`</span></span><br><span class="line">fmt.Println(a) <span class="comment">//输出:aabc</span></span><br><span class="line">fmt.Println(b) <span class="comment">//输出a\tabc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串和数值转换"><a href="#字符串和数值转换" class="headerlink" title="字符串和数值转换"></a>字符串和数值转换</h2><ul><li><p>包strconv提供了字符串和其他类型相互转换的函数,下面以字符串和数值类型转换为例</p></li><li><p>int和string相互转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"11"</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数:需要转换的字符串变量</span></span><br><span class="line"><span class="comment">第二个参数:这个数字是几进制,常用取值:2,8,10,16</span></span><br><span class="line"><span class="comment">第三个参数:认为这个数字的整数类型.可取值:0,8,16,32,64.</span></span><br><span class="line"><span class="comment">但是由于方法最后返回值是int64,所以第三个参数无论设置什么最终结果都是int64</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">i, _ := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">8</span>)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单写法,相当于strconv.ParseInt(s,10,64)</span></span><br><span class="line">i1, _ := strconv.Atoi(s)</span><br><span class="line">fmt.Println(i1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Int转换成string</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">11</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数:必须是int64类型</span></span><br><span class="line"><span class="comment">第二个参数:进制数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">s := strconv.FormatInt(<span class="keyword">int64</span>(i), <span class="number">10</span>)</span><br><span class="line">fmt.Println(s)        <span class="comment">//输出:11</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, s) <span class="comment">//输出:string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由于平时常用int,且使用短变量时整数默认是int类型</span></span><br><span class="line"><span class="comment">所以下面方式较常用,把int转换为string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">s1 := strconv.Itoa(i)</span><br><span class="line">fmt.Println(s1)      <span class="comment">//输出:11</span></span><br><span class="line">fmt.Printf(<span class="string">"%T"</span>, s1) <span class="comment">//输出:string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>string转换为floatXX类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"1.5"</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">把字符串转换为指定类型</span></span><br><span class="line"><span class="comment">第一个参数:字符串</span></span><br><span class="line"><span class="comment">第二个参数:可取值为32和64,分别表示float32和float64</span></span><br><span class="line"><span class="comment">返回值是float64</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">f, _ := strconv.ParseFloat(s, <span class="number">64</span>)</span><br><span class="line">fmt.Println(f)</span><br><span class="line">fmt.Printf(<span class="string">"%T"</span>, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>floatXX转换为string类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := <span class="number">1.5</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">把浮点型转换为字符串类型</span></span><br><span class="line"><span class="comment">第一个参数:浮点型变量</span></span><br><span class="line"><span class="comment">第二个参数:</span></span><br><span class="line"><span class="comment">'f'（-ddd.dddd）</span></span><br><span class="line"><span class="comment">'b'（-ddddp±ddd，指数为二进制）</span></span><br><span class="line"><span class="comment">'e'（-d.dddde±dd，十进制指数）</span></span><br><span class="line"><span class="comment">'E'（-d.ddddE±dd，十进制指数）</span></span><br><span class="line"><span class="comment">'g'（指数很大时用'e'格式，否则'f'格式）</span></span><br><span class="line"><span class="comment">'G'（指数很大时用'E'格式，否则'f'格式）</span></span><br><span class="line"><span class="comment">第三个参数:小数点精度,精度不够使用0补全,超出精度四舍五入</span></span><br><span class="line"><span class="comment">第四个参数:浮点型变量类型,64表示float64,32表示float32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">s := strconv.FormatFloat(f, <span class="string">'g'</span>, <span class="number">5</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><ul><li>可以使用<strong>len(字符串变量)</strong>获取字符串的字节长度,其中英文占1个字节长度,中文占用3个字节长度</li><li>可以使用<strong>变量名[n]</strong>获取到字符串第n+1个字节,返回这个字节对应的Unicode码值(uint8类型).注意n的取值范围是[0,长度)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"smallming张"</span></span><br><span class="line">a := s[<span class="number">0</span>]</span><br><span class="line">fmt.Println(a)        <span class="comment">//输出:115</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, a) <span class="comment">//输出uint8</span></span><br><span class="line">b := fmt.Sprintf(<span class="string">"%c"</span>, a)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, b) <span class="comment">//输出:string</span></span><br><span class="line">fmt.Println(b)        <span class="comment">//输出s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以使用变量名[n:m]取出大于等于n小于m的字符序列</p><ul><li>n和m都可以省略,省略时认为n为0,m为长度</li><li>因为中文占用三个字节,如果没有把中文完整取出,会出现乱码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"smallming张"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">//输出:12,字节长度</span></span><br><span class="line">fmt.Println(s[<span class="number">1</span>:<span class="number">4</span>]) <span class="comment">//输出:mal</span></span><br><span class="line">fmt.Println(s[:<span class="number">2</span>])  <span class="comment">//输出:sm</span></span><br><span class="line">fmt.Println(s[<span class="number">5</span>:])  <span class="comment">//输出:ming张</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可以通过把字符串转换为切片获取长度,并获取里面内容. 也可以直接使用for循环结合range获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"smallming张"</span></span><br><span class="line">s1 := []<span class="keyword">rune</span>(s)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1))    <span class="comment">//输出:10</span></span><br><span class="line">fmt.Println(s1[<span class="number">9</span>])      <span class="comment">//输出24352</span></span><br><span class="line">fmt.Printf(<span class="string">"%c"</span>, s1[<span class="number">9</span>]) <span class="comment">//输出:张</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历字符串中内容</span></span><br><span class="line"><span class="keyword">for</span> i, n := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Println(i, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2></li><li><p>在strings包中提供了字符串常用的函数</p></li><li><p>常用函数整理如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"smallming"</span></span><br><span class="line"><span class="comment">//第一次出现的索引</span></span><br><span class="line">fmt.Println(strings.Index(s, <span class="string">"l"</span>))</span><br><span class="line"><span class="comment">//最后一次出现的索引</span></span><br><span class="line">fmt.Println(strings.LastIndex(s, <span class="string">"l"</span>))</span><br><span class="line"><span class="comment">//是否以指定内容开头</span></span><br><span class="line">fmt.Println(strings.HasPrefix(s, <span class="string">"small"</span>))</span><br><span class="line"><span class="comment">//是否以指定内容结尾</span></span><br><span class="line">fmt.Println(strings.HasSuffix(s, <span class="string">"ming"</span>))</span><br><span class="line"><span class="comment">//是否包含指定字符串</span></span><br><span class="line">fmt.Println(strings.Contains(s, <span class="string">"mi"</span>))</span><br><span class="line"><span class="comment">//全变小写</span></span><br><span class="line">fmt.Println(strings.ToLower(s))</span><br><span class="line"><span class="comment">//全大写</span></span><br><span class="line">fmt.Println(strings.ToUpper(s))</span><br><span class="line"><span class="comment">//把字符串中前n个old子字符串替换成new字符串,如果n小于0表示全部替换.</span></span><br><span class="line"><span class="comment">//如果n大于old个数也表示全部替换</span></span><br><span class="line">fmt.Println(strings.Replace(s, <span class="string">"m"</span>, <span class="string">"k"</span>, <span class="number">-1</span>))</span><br><span class="line"><span class="comment">//把字符串重复count遍</span></span><br><span class="line">fmt.Println(strings.Repeat(s, <span class="number">2</span>))</span><br><span class="line"><span class="comment">//去掉字符串前后指定字符</span></span><br><span class="line">fmt.Println(strings.Trim(s, <span class="string">" "</span>)) <span class="comment">//去空格可以使用strings.TrimSpace(s)</span></span><br><span class="line"><span class="comment">//根据指定字符把字符串拆分成切片</span></span><br><span class="line">fmt.Println(strings.Split(s, <span class="string">"m"</span>))</span><br><span class="line"><span class="comment">//使用指定分隔符把切片内容合并成字符串</span></span><br><span class="line">arr := []<span class="keyword">string</span>&#123;<span class="string">"small"</span>, <span class="string">"ming"</span>&#125;</span><br><span class="line">fmt.Println(strings.Join(arr, <span class="string">""</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="常量和iota"><a href="#常量和iota" class="headerlink" title="常量和iota"></a>常量和iota</h1><h2 id="常量概述"><a href="#常量概述" class="headerlink" title="常量概述"></a>常量概述</h2><ul><li><p>常量是一个固定值,在编译器就确定结果.声明时必须赋值且结果不可以改变.</p></li><li><p>因为常量在编译器就确定,可以防止程序运行过程中意外修改</p></li><li><p>常量关键字const</p></li><li><p>常量定义完可以不使用</p></li><li><p>Go语言中常量定义没有明确语法要求,可以不全大写,驼峰即可.</p></li><li><p>很多内容可以定义成常量</p><ul><li>人名</li><li>圆周率</li><li>电话号</li><li>等<h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2></li></ul></li><li><p>定义常量时如果不是必须指定特定类型,可以省略类型,使用默认类型.且数值类型常量(不定义类型)可以直接进行运算</p></li><li><p>常量的值可以是表达式,但是不允许出现变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> a <span class="keyword">string</span> = <span class="string">"smallming"</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">3</span>*<span class="number">2</span> + <span class="number">5</span><span class="comment">//不要指定类型</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="number">1.5</span><span class="comment">//不要指定类型</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%T %T"</span>,c,d)<span class="comment">//int float</span></span><br><span class="line"></span><br><span class="line">fmt.Println(c+d)<span class="comment">//12.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这种方式是错误的</span></span><br><span class="line">i := <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> e = i*<span class="number">2</span> + <span class="number">5</span> <span class="comment">//const initializer i * 2 + 5 is not a constant</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当定义多个常量时官方推荐的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>定义多常量时后一个常量如果没有赋值,与前一个常量值相同.</p><ul><li>第一个常量必须赋值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">)</span><br><span class="line">fmt.Println(a,b,c)<span class="comment">//输出:1 1 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量生成器"><a href="#常量生成器" class="headerlink" title="常量生成器"></a>常量生成器</h2></li></ul></li><li><p>当一组常量都是数值类型,可以使用常量生成器iota指定这组常量按照特定规则变化</p></li><li><p>iota起始值为0,每次增加1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="literal">iota</span></span><br><span class="line">b </span><br><span class="line">c </span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c) <span class="comment">//输出: 0 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">d = <span class="literal">iota</span> &lt;&lt; <span class="number">1</span></span><br><span class="line">e </span><br><span class="line">f </span><br><span class="line">)</span><br><span class="line">fmt.Println(d, e, f) <span class="comment">//输出:0 2 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无论是否使用iota,一组常量中每个的iota值是固定的,iota按照顺序自增1</p></li><li><p>每组iota之间无影响</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="number">5</span>    <span class="comment">//iota=0</span></span><br><span class="line">b = <span class="number">3</span>    <span class="comment">//iota=1</span></span><br><span class="line">c = <span class="literal">iota</span> <span class="comment">//iota=2</span></span><br><span class="line">d        <span class="comment">//iota=3</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d) <span class="comment">//输出5 3 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">e = <span class="literal">iota</span> <span class="comment">//iota=0</span></span><br><span class="line">f        <span class="comment">//iota=1</span></span><br><span class="line">g = <span class="number">10</span>   <span class="comment">//iota=2</span></span><br><span class="line">h        <span class="comment">//iota=3</span></span><br><span class="line">i = <span class="literal">iota</span> <span class="comment">//iota=4</span></span><br><span class="line">j        <span class="comment">//iota=5</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(e, f, g, h, i, j) <span class="comment">// 0 1 10 10 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="变量地址"><a href="#变量地址" class="headerlink" title="变量地址"></a>变量地址</h2><ul><li>变量本质就是内存中一块数据的标记.把值存储到变量中实质是把值存储到内存中</li><li>每次对变量重新赋值就是在修改变量地址中的内容</li><li>在Go语言中可以通过 <code>&amp;+变量名</code> 获取到变量地址值</li><li>重新创建一个非引用型变量(即使是把已有变量直接赋值给新变量)也会新开辟内存地址.<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">3</span></span><br><span class="line">fmt.Println(&amp;a) <span class="comment">//输出:地址</span></span><br><span class="line">a = <span class="number">4</span></span><br><span class="line">fmt.Println(&amp;a) <span class="comment">//输出的地址不变</span></span><br><span class="line"></span><br><span class="line">b := a</span><br><span class="line">b = <span class="number">5</span></span><br><span class="line">fmt.Println(&amp;b, &amp;a) <span class="comment">//两个值不相同</span></span><br><span class="line">fmt.Println(b, a)   <span class="comment">//输出:5 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h2><ul><li>指针变量指向一个值的内存地址</li><li>使用&amp;+变量 返回值就是一个指针类型</li><li>使用<code>var 变量名 *类型</code> 声明指针类型变量</li><li>声明指针不会开辟内存地址,只是准备要指向内存某个空间,而声明变量会开辟内存地址,准备存放内容.所以指针类型变量都是把一个变量的地址赋值给指针变量</li><li>使用<code>*+指针</code>能够获取内存地址中的值.所以<code>*+指针</code>就和直接使用变量是相同的</li><li>应用指针可以实现多个地方操作同一个内存地址的值(在方法参数应用指针较多)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建变量</span></span><br><span class="line">a := <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> point *<span class="keyword">int</span></span><br><span class="line">point = &amp;a <span class="comment">//此时point和&amp;a是相等的</span></span><br><span class="line">fmt.Println(point)</span><br><span class="line">*point = <span class="number">3</span>             <span class="comment">//等价于a=3</span></span><br><span class="line">fmt.Println(*point, a) <span class="comment">//*point和a是相当的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2></li><li>指针目的就是指向内存中一块地址</li><li>声明指针后指针不会指向任何内存地址,所以此时指针是空.在Go语言中空用nil表示<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">fmt.Println(a)        <span class="comment">//输出:&lt;nil&gt;</span></span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>) <span class="comment">//输出true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h2><ul><li><p>在上一小节中学习了指针,每次创建一个指针必须在额外创建一个变量,操作比较麻烦.</p></li><li><p>可以通过new函数直接创建一个类型的指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名:&#x3D;new(Type)</span><br></pre></td></tr></table></figure></li><li><p>使用new函数创建的指针已有指向,可以使用<code>*指针对象</code>进行赋值.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(a) <span class="comment">//输出:指针地址</span></span><br><span class="line">*a = <span class="number">123</span></span><br><span class="line">fmt.Println(*a) <span class="comment">//输出:123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只声明的指针变量不能直接赋值.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">*a = <span class="number">123</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal 0xc0000005 code&#x3D;0x1 addr&#x3D;0x0 pc&#x3D;0x48b576]</span><br></pre></td></tr></table></figure></li></ul><h1 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h1><h2 id="时间类型概述"><a href="#时间类型概述" class="headerlink" title="时间类型概述"></a>时间类型概述</h2><ul><li>时间类型在实际开发中使用频率很高,代表现实世界的时间</li><li>在Go语言中时间类型不是关键字而是使用time包下Time结构体</li><li>时间类型默认显示为UTC,所以经常需要把时间类型转换为字符串,显示成我们所熟悉的格式</li></ul><h2 id="Time的使用"><a href="#Time的使用" class="headerlink" title="Time的使用"></a>Time的使用</h2><ul><li><p>声明Time时,默认时间是无意义的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t time.Time</span><br><span class="line">fmt.Println(t)<span class="comment">//输出:0001-01-01 00:00:00 +0000 UTC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以通过time包下的Now()函数获取操作系统当前时间</p><ul><li>+0800 CST 表示北京时间,东八区<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line">fmt.Println(t) <span class="comment">//输出:年-月-日 小时:分钟:秒.纳秒 +0800 CST m=+0.003012301</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>也可以通过时间戳创建时间类型变量(距离1970年1月1日的纳秒差)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1秒(s)=1000毫秒(ms)</span></span><br><span class="line"><span class="comment">1秒(s)=1000000微秒(μs)</span></span><br><span class="line"><span class="comment">1秒(s)=1000000000纳秒(ns)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t := time.Now()</span><br><span class="line">t1 := time.Unix(<span class="number">0</span>, t.UnixNano()) <span class="comment">//根据时间戳创建时间.第二个值[0, 999999999]外合法</span></span><br><span class="line">fmt.Println(t.String())</span><br><span class="line">fmt.Println(t1)</span><br></pre></td></tr></table></figure></li><li><p>可以根据自己要求创建时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//time.Local取到本地时间位置对象,东八区</span></span><br><span class="line">t := time.Date(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>, time.Local)</span><br><span class="line">fmt.Println(t) <span class="comment">//输出:2020-05-06 07:08:09 +0800 CST</span></span><br></pre></td></tr></table></figure></li><li><p>在time包下提供了大量的函数或方法获取时间的某一项</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line">fmt.Println(t)</span><br><span class="line">fmt.Println(t.Year())       <span class="comment">//年</span></span><br><span class="line">fmt.Println(<span class="keyword">int</span>(t.Month())) <span class="comment">//月</span></span><br><span class="line">fmt.Println(t.Day())        <span class="comment">//日</span></span><br><span class="line">fmt.Println(t.Date())       <span class="comment">//三个参数,分别是:年,月,日</span></span><br><span class="line">fmt.Println(t.Hour())       <span class="comment">//小时</span></span><br><span class="line">fmt.Println(t.Minute())     <span class="comment">//分钟</span></span><br><span class="line">fmt.Println(t.Second())     <span class="comment">//秒</span></span><br><span class="line">fmt.Println(t.Clock())      <span class="comment">//三个参数,分别是:小时,分钟,秒</span></span><br><span class="line">fmt.Println(t.Nanosecond()) <span class="comment">//纳秒</span></span><br><span class="line">fmt.Println(t.Unix())       <span class="comment">//秒差</span></span><br><span class="line">fmt.Println(t.UnixNano())   <span class="comment">//纳秒差</span></span><br></pre></td></tr></table></figure><h2 id="时间和string相互转换"><a href="#时间和string相互转换" class="headerlink" title="时间和string相互转换"></a>时间和string相互转换</h2></li><li><p>时间转换为string</p><ul><li>参数必须是这个时间,为Go语言出现时间<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line"><span class="comment">//参数必须是这个时间,格式任意</span></span><br><span class="line">s := t.Format(<span class="string">"2006-01-02 15:04:05"</span>, )</span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>string转换为Time</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s:=<span class="string">"2022-02-04 22:02:04"</span></span><br><span class="line">t,err:=time.Parse(<span class="string">"2006-01-02 15:04:05"</span>,s)</span><br><span class="line">fmt.Println(t,err)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      golang的基本语法和数据类型
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习二：golang自带的工具</title>
    <link href="http://www.maishuren.top/posts/golang/202006122229-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006122229-index.html</id>
    <published>2020-06-12T14:29:44.000Z</published>
    <updated>2020-06-13T02:16:47.244Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="解压版Go语言安装包中自带工具"><a href="#解压版Go语言安装包中自带工具" class="headerlink" title="解压版Go语言安装包中自带工具"></a>解压版Go语言安装包中自带工具</h1><ul><li><p>在%GOROOT%/bin中有三个工具</p><ul><li>go.exe 编译、运行、构建等都可以使用这个命令</li><li>godoc.exe 查看包或函数的源码</li><li>gofmt.exe 格式化文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--bin</span><br><span class="line">--go.exe</span><br><span class="line">--godoc.exe</span><br><span class="line">--gofmt.exe</span><br></pre></td></tr></table></figure><h2 id="go-exe参数列表"><a href="#go-exe参数列表" class="headerlink" title="go.exe参数列表"></a>go.exe参数列表</h2></li></ul></li><li><p>在命令行中通过<code>go help</code>查看go参数如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">        go command [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">        build       compile packages and dependencies</span><br><span class="line">        clean       remove object files and cached files</span><br><span class="line">        doc         show documentation for package or symbol</span><br><span class="line">        env         print Go environment information</span><br><span class="line">        bug         start a bug report</span><br><span class="line">        fix         update packages to use new APIs</span><br><span class="line">        fmt         gofmt (reformat) package sources</span><br><span class="line">        generate    generate Go files by processing source</span><br><span class="line">        get         download and install packages and dependencies</span><br><span class="line">        install     compile and install packages and dependencies</span><br><span class="line">        list        list packages</span><br><span class="line">        run         compile and run Go program</span><br><span class="line">        test        test packages</span><br><span class="line">        tool        run specified go tool</span><br><span class="line">        version     print Go version</span><br><span class="line">vet         report likely mistakes in packages</span><br></pre></td></tr></table></figure></li></ul><h3 id="常用参数解释"><a href="#常用参数解释" class="headerlink" title="常用参数解释"></a>常用参数解释</h3><ul><li><code>go version</code>查看Go语言版本</li><li><code>go env</code>查看Go语言详细环境</li><li><code>go list</code>查看Go语言文件目录</li><li><code>go build</code>把源码文件构建成系统可执行文件</li><li><code>go clean</code>清空生成的可执行文件</li><li><code>go vet</code>静态解析文件,检查是否有语法错误等</li><li><code>go get</code>从远程下载第三方Go语言库</li><li><code>go bug</code>提交bug</li><li><code>go test</code>测试(在后面章节中讲解)</li><li><code>go run</code>运行文件</li></ul><h2 id="godoc-命令介绍"><a href="#godoc-命令介绍" class="headerlink" title="godoc 命令介绍"></a>godoc 命令介绍</h2><ul><li>可以使用<code>godoc [包] [函数名]</code>查看包或函数的详细源码</li><li>源码在学习中非常重要,经常查看源码方便理解GO的原理</li></ul><h3 id="godoc使用"><a href="#godoc使用" class="headerlink" title="godoc使用"></a>godoc使用</h3><ul><li>查看包的源码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zhang&gt;godoc fmt</span><br><span class="line">use <span class="string">'godoc cmd/fmt'</span> <span class="keyword">for</span> documentation on the fmt command</span><br><span class="line"></span><br><span class="line">PACKAGE DOCUMENTATION</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line">    <span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">FUNCTIONS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br><span class="line">    Errorf formats according to a format specifier and returns the <span class="keyword">string</span> as</span><br><span class="line">    a value that satisfies error.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Fprint formats using the <span class="keyword">default</span> formats <span class="keyword">for</span> its operands and writes to</span><br><span class="line">    w. Spaces are added between operands when neither is a <span class="keyword">string</span>. It</span><br><span class="line">    returns the number of bytes written and any write error encountered.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Fprintf formats according to a format specifier and writes to w. It</span><br><span class="line">    returns the number of bytes written and any write error encountered.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Fprintln formats using the <span class="keyword">default</span> formats <span class="keyword">for</span> its operands and writes</span><br><span class="line">    to w. Spaces are always added between operands and a newline is</span><br><span class="line">    appended. It returns the number of bytes written and any write error</span><br><span class="line">    encountered.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscan</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Fscan scans text read from r, storing successive space-separated values</span><br><span class="line">    into successive arguments. Newlines count as space. It returns the</span><br><span class="line">    number of items successfully scanned. If that is less than the number of</span><br><span class="line">    arguments, err will report why.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanf</span><span class="params">(r io.Reader, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Fscanf scans text read from r, storing successive space-separated values</span><br><span class="line">    into successive arguments as determined by the format. It returns the</span><br><span class="line">    number of items successfully parsed. Newlines in the input must match</span><br><span class="line">    newlines in the format.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanln</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Fscanln is similar to Fscan, but stops scanning at a newline and after</span><br><span class="line">    the final item there must be a newline or EOF.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Print formats using the <span class="keyword">default</span> formats <span class="keyword">for</span> its operands and writes to</span><br><span class="line">    standard output. Spaces are added between operands when neither is a</span><br><span class="line">    <span class="keyword">string</span>. It returns the number of bytes written and any write error</span><br><span class="line">    encountered.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Printf formats according to a format specifier and writes to standard</span><br><span class="line">    output. It returns the number of bytes written and any write error</span><br><span class="line">    encountered.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Println formats using the <span class="keyword">default</span> formats <span class="keyword">for</span> its operands and writes to</span><br><span class="line">    standard output. Spaces are always added between operands and a newline</span><br><span class="line">    is appended. It returns the number of bytes written and any write error</span><br><span class="line">    encountered.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scan</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Scan scans text read from standard input, storing successive</span><br><span class="line">    space-separated values into successive arguments. Newlines count as</span><br><span class="line">    space. It returns the number of items successfully scanned. If that is</span><br><span class="line">    less than the number of arguments, err will report why.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Scanf scans text read from standard input, storing successive</span><br><span class="line">    space-separated values into successive arguments as determined by the</span><br><span class="line">    format. It returns the number of items successfully scanned. If that is</span><br><span class="line">    less than the number of arguments, err will report why. Newlines in the</span><br><span class="line">    input must match newlines in the format. The one exception: the verb %c</span><br><span class="line">    always scans the next <span class="keyword">rune</span> in the input, even <span class="keyword">if</span> it is a space (or tab</span><br><span class="line">    etc.) or newline.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Scanln is similar to Scan, but stops scanning at a newline and after the</span><br><span class="line">    final item there must be a newline or EOF.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line">    Sprint formats using the <span class="keyword">default</span> formats <span class="keyword">for</span> its operands and returns</span><br><span class="line">    the resulting <span class="keyword">string</span>. Spaces are added between operands when neither is</span><br><span class="line">    a <span class="keyword">string</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line">    Sprintf formats according to a format specifier and returns the</span><br><span class="line">    resulting <span class="keyword">string</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line">    Sprintln formats using the <span class="keyword">default</span> formats <span class="keyword">for</span> its operands and returns</span><br><span class="line">    the resulting <span class="keyword">string</span>. Spaces are always added between operands and a</span><br><span class="line">    newline is appended.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscan</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Sscan scans the argument <span class="keyword">string</span>, storing successive space-separated</span><br><span class="line">    values into successive arguments. Newlines count as space. It returns</span><br><span class="line">    the number of items successfully scanned. If that is less than the</span><br><span class="line">    number of arguments, err will report why.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanf</span><span class="params">(str <span class="keyword">string</span>, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Sscanf scans the argument <span class="keyword">string</span>, storing successive space-separated</span><br><span class="line">    values into successive arguments as determined by the format. It returns</span><br><span class="line">    the number of items successfully parsed. Newlines in the input must</span><br><span class="line">    match newlines in the format.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanln</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    Sscanln is similar to Sscan, but stops scanning at a newline and after</span><br><span class="line">    the final item there must be a newline or EOF.</span><br><span class="line"></span><br><span class="line">TYPES</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Formatter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Format(f State, c <span class="keyword">rune</span>)</span><br><span class="line">&#125;</span><br><span class="line">    Formatter is the <span class="keyword">interface</span> implemented by values with a custom</span><br><span class="line">    formatter. The implementation of Format may call Sprint(f) or Fprint(f)</span><br><span class="line">    etc. to generate its output.</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GoStringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    GoString() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">    GoStringer is implemented by any value that has a GoString method, which</span><br><span class="line">    defines the Go syntax <span class="keyword">for</span> that value. The GoString method is used to</span><br><span class="line">    <span class="built_in">print</span> values passed as an operand to a %#v format.</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li>查看某个包中某个函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zhang&gt;godoc fmt Println</span><br><span class="line">use &#39;godoc cmd&#x2F;fmt&#39; for documentation on the fmt command</span><br><span class="line"></span><br><span class="line">func Println(a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">    Println formats using the default formats for its operands and writes to</span><br><span class="line">    standard output. Spaces are always added between operands and a newline</span><br><span class="line">    is appended. It returns the number of bytes written and any write error</span><br><span class="line">    encountered.</span><br></pre></td></tr></table></figure></li></ul><h2 id="gofmt工具介绍"><a href="#gofmt工具介绍" class="headerlink" title="gofmt工具介绍"></a>gofmt工具介绍</h2><ul><li>规范的代码方便自己的阅读也方便别人的阅读.编写规范代码是每个程序的必修课</li><li>gofmt工具可以帮助程序员把代码进行格式化,按照规范进行格式化</li><li>使用gofmt前提是文件编译通过</li></ul><h3 id="不规范代码示例"><a href="#不规范代码示例" class="headerlink" title="不规范代码示例"></a>不规范代码示例</h3><ul><li>查看下面代码中不规范的地方有几处</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main ( )&#123;</span><br><span class="line">fmt.Println(&quot;hello word&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用gofmt的步骤"><a href="#使用gofmt的步骤" class="headerlink" title="使用gofmt的步骤"></a>使用gofmt的步骤</h3><ul><li>在命令行输入<code>gofmt 文件名</code>就可以对文件进行格式化,格式化后输出<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D:\go\0201&gt;gofmt main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        fmt.Println(&quot;hello word&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过运行gofmt后发现规范的代码和不规范代码的几处区别<ul><li>package关键字和import关键字和func main之间有空行</li><li>main和括号之间没有空格</li><li>main后面()之间没有空格</li><li>()和{之间有空格</li><li>fmt.Println()前面有缩进</li><li>fmt.Println()后面没有分号</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      golang开发包自带的工具go.exe、godoc.exe、gofmt.exe
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习一：从环境配置开始到HelloWorld入门</title>
    <link href="http://www.maishuren.top/posts/golang/202006111106-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006111106-index.html</id>
    <published>2020-06-11T03:06:47.000Z</published>
    <updated>2020-06-13T02:18:22.224Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Golang介绍"><a href="#Golang介绍" class="headerlink" title="Golang介绍"></a>Golang介绍</h1><ul><li>Go语言是谷歌公司于2009年11月发布的编程语言,其发明人Robert Griesemer、Rob Pike、Ken Thompson<ul><li>Robert Griesemer:罗伯特·格瑞史莫参与开发Java的Hotspot编译器和Javascript V8引擎</li><li>Rob Pike:罗布·派克曾是Unix团队成员,与Thompson一起创造了UTF-8</li><li>Ken Thompson:肯·汤普森,IT行业殿堂级人物.1983年图灵奖和1998年美国国家技术奖.创造出C语言和Unix系统</li></ul></li><li>官方解释:Go语言是一种开源的程序设计语言,它的目的使得开发者可以方便地构建简单、可靠、高效的软件<h2 id="Go语言优势"><a href="#Go语言优势" class="headerlink" title="Go语言优势"></a>Go语言优势</h2></li><li>语法简单<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">a,b=b,a</span><br><span class="line">fmt.Println(a,b)</span><br></pre></td></tr></table></figure></li><li>可以直接编译成机器码</li><li>静态数据类型和编译语言<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="number">1</span></span><br><span class="line">b:=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li>内置支持并发<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li><li>内置垃圾回收</li><li>部署简单</li><li>强大的标准库</li></ul><h2 id="Go语言适用场景"><a href="#Go语言适用场景" class="headerlink" title="Go语言适用场景"></a>Go语言适用场景</h2><ul><li>服务器编程.实现日志处理,虚拟机处理,文件处理等</li><li>分布式系统或数据库代理</li><li>网络编程,包含web应用</li><li>云平台</li></ul><h2 id="市场占有率"><a href="#市场占有率" class="headerlink" title="市场占有率"></a>市场占有率</h2><ul><li>根据Tiobe中Go语言的排行在逐年上升.</li></ul><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/Tiobe2019-2020.jpeg" alt="tiobe"></p><h1 id="环境配置—windows"><a href="#环境配置—windows" class="headerlink" title="环境配置—windows"></a>环境配置—windows</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li>由于Google退出中国,所以国内无法直接访问到Go语言的官网</li><li>但是可以通过Go语言中文网进行加载资源和交流Go语言技术<blockquote><p><a href="https://studygolang.com/" target="_blank" rel="noopener">https://studygolang.com/</a></p></blockquote><h2 id="下载步骤"><a href="#下载步骤" class="headerlink" title="下载步骤"></a>下载步骤</h2></li><li>直接进入到Go语言中文网下载页面</li></ul><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/goxiazai.png" alt="进入下载页面"></p><ul><li>选择要下载的版本<ul><li>首先要确定版本号,本套视频使用的Go1.10.1</li><li>然后确定自己的操作系统,windows或linux等,本阶段使用Window操作系统进行讲解</li><li>如果是windows确定自己系统位数,32位系统选择386,64位系统选择amd64</li><li>扩展名.msi表示安装版.zip为解压版(推荐使用解压版,所有的配置都自己操作,心中有数)</li></ul></li></ul><p><img src="images/goxuanzebanben.png" alt="进入下载页面"></p><h2 id="Go语言库文件夹解释"><a href="#Go语言库文件夹解释" class="headerlink" title="Go语言库文件夹解释"></a>Go语言库文件夹解释</h2><ul><li><strong>api</strong> : 每个版本更新说明</li><li><strong>bin</strong> : 自带工具. <strong>重点记忆</strong></li><li><strong>blog</strong>:博客</li><li><strong>doc</strong>:文档</li><li><strong>misc</strong>: 代码配置</li><li><strong>lib</strong>:额外引用</li><li><strong>src</strong>:标准库源码,以后第三方库放入到这个文件夹中. <strong>重点记忆</strong></li><li><strong>test</strong>:测试</li></ul><h2 id="配置步骤-Windows举例"><a href="#配置步骤-Windows举例" class="headerlink" title="配置步骤(Windows举例)"></a>配置步骤(Windows举例)</h2><ul><li>把下载好的go1.10.1.windows-amd64进行解压,解压后出现go文件夹</li></ul><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/goanzhuangbaojieya.png" alt=""></p><ul><li>把解压后的go文件夹复制到任意非中文目录中(例如: D:\mysoftware\go\soft\go)<ul><li>如果没有配置环境变量默认去C:\go找Go语言库  </li></ul></li></ul><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/jieyacunfang.png" alt=""></p><ul><li>配置环境变量<ul><li>“我的电脑” –&gt; 右键”属性”–&gt; “高级” –&gt; “环境变量” –&gt; “系统变量”–&gt; “新建”按钮后输入</li></ul></li></ul><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/goroot.png" alt=""></p><ul><li>在”系统变量”中PATH属性里面添加<code>%GOROOT%\bin;</code></li></ul><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/gopath.png" alt=""></p><ul><li>启动”命令行”输入<code>go version</code>如果出现下面效果说明配置成功<ul><li>也可以使用<code>go env</code>命令查看全部环境</li></ul></li></ul><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/jieguo.png" alt=""></p><h2 id="环境变量参数解释"><a href="#环境变量参数解释" class="headerlink" title="环境变量参数解释"></a>环境变量参数解释</h2><ul><li><strong>GOROOT</strong> 表示Go语言库的根目录的完整路径</li><li><strong>PATH</strong> 中配置内容方便在命令行快速调用Go语言库中工具</li><li><strong>GOPATH</strong> 可以先不配置,在做项目时需要配置,表示项目路径</li></ul><h1 id="Hello-World入门"><a href="#Hello-World入门" class="headerlink" title="Hello World入门"></a>Hello World入门</h1><p>程序员的Hello World情怀，学习一门新语言第一行输出代码：Hello World！</p><ul><li>新建txt文件,并修改扩展名后名称为<strong>main.go</strong></li><li>在文件中输入以下代码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用Windows命令行工具,在go文件所在的目录下，输入以下命令运行观察结果<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure></li><li>程序结果应该是输出<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此Golang的入门就到这了，今后还有漫长的Golang之旅要去探索！</p>]]></content>
    
    <summary type="html">
    
      golang入门第一步，window开发环境配置，&quot;Hello World&quot;入门
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码学习：Spring运行原理分析</title>
    <link href="http://www.maishuren.top/posts/spring/202006081449-index.html"/>
    <id>http://www.maishuren.top/posts/spring/202006081449-index.html</id>
    <published>2020-06-08T06:49:19.000Z</published>
    <updated>2020-06-13T08:44:20.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Spring模块组成"><a href="#Spring模块组成" class="headerlink" title="Spring模块组成"></a>Spring模块组成</h1><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/springframework.jpg" alt=""></p><table><thead><tr><th>模块名称</th><th>主要功能</th></tr></thead><tbody><tr><td>spring-core</td><td>依赖注入IOC与DI的最基本实现</td></tr><tr><td>spring-beans</td><td>Bean工厂与Bean的装配</td></tr><tr><td>spring-context</td><td>定义基础的Spring的Context上下文即IOC容器</td></tr><tr><td>spring-context-support</td><td>对Spring IOC容器的扩展支持，以及IOC子容器</td></tr><tr><td>spring-context-indexer</td><td>Spring的类管理组件和Classpath扫描</td></tr><tr><td>spring-expression</td><td>Spring表达式语言</td></tr><tr><td>spring-aop</td><td>面向切面编程的应用模块，整合Asm，CGLIb、JDKProxy</td></tr><tr><td>spring-aspects</td><td>集成AspectJ，AOP应用框架</td></tr><tr><td>spring-instrument</td><td>动态Class Loading模块</td></tr><tr><td>spring-jdbc</td><td>Spring 提供的JDBC抽象框架的主要实现模块，用于简化Spring JDBC操作</td></tr><tr><td>spring-tx</td><td>Spring JDBC事务控制实现模块</td></tr><tr><td>spring-orm</td><td>主要集成 Hibernate, Java Persistence API (JPA) 和 Java Data Objects (JDO)</td></tr><tr><td>spring-oxm</td><td>将Java对象映射成XML数据，或者将XML数据映射成Java对象</td></tr><tr><td>spring-jms</td><td>Java Messaging Service能够发送和接收信息</td></tr><tr><td>spring-web</td><td>提供了最基础Web支持，主要建立于核心容器之上，通过Servlet或者Listeners来初始化IOC容器</td></tr><tr><td>spring-webmvc</td><td>实现了Spring MVC（model-view-Controller）的Web应用</td></tr><tr><td>spring-websocket</td><td>主要是与Web前端的全双工通讯的协议</td></tr><tr><td>spring-webflux</td><td>一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务</td></tr><tr><td>spring-messaging</td><td>从Spring4开始新加入的一个模块，主要职责是为Spring 框架集成一些基础的报文传送应用</td></tr><tr><td>spring-test</td><td>主要为测试提供支持的</td></tr><tr><td>spring-framework-bom</td><td>Bill of Materials.解决Spring的不同模块依赖版本不同问题</td></tr></tbody></table><h1 id="Spring各模块之间的依赖"><a href="#Spring各模块之间的依赖" class="headerlink" title="Spring各模块之间的依赖"></a>Spring各模块之间的依赖</h1><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/springmodel.png" alt=""></p><h1 id="Spring关键类图"><a href="#Spring关键类图" class="headerlink" title="Spring关键类图"></a>Spring关键类图</h1><p>BeanFactory类图</p><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/spring/BeanFactory.png" alt=""></p><p>BeanDefinition类图</p><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/spring/BeanDefinition.png" alt=""></p><h1 id="Spring中IOC的运行时序图"><a href="#Spring中IOC的运行时序图" class="headerlink" title="Spring中IOC的运行时序图"></a>Spring中IOC的运行时序图</h1><p>IOC(Inversion of Control)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们所看到的配置文件。<br>Spring IOC 定位配置文件并扫描相关注解—&gt;加载配置信息到内存—根据加载的信息将对象初始化到IOC容器中。</p><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/spring/locationconfig.png" alt=""></p><ul><li>通用职责</li><li>依赖职责<ul><li>依赖查找</li><li>依赖注入</li></ul></li><li>声明周期管理<ul><li>容器</li><li>托管的资源（Java Bean）</li></ul></li><li>配置<ul><li>容器</li><li>外部化配置</li><li>托管的资源（Java Bean）</li></ul></li></ul><h1 id="Spring-IOC依赖查找"><a href="#Spring-IOC依赖查找" class="headerlink" title="Spring IOC依赖查找"></a>Spring IOC依赖查找</h1><p>根据Bean名称查找</p><p>​    实时查找</p><p>​    延迟查找</p><p>根据类型查找</p><p>​    单个Bean对象</p><p>​    集合Bean对象</p><p>根据名称+类型查找</p><p>根据Java注解查找</p><p>​    查找单个Bean对象</p><p>​    查找集合Bean对象</p><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><h1 id="配置元信息"><a href="#配置元信息" class="headerlink" title="配置元信息"></a>配置元信息</h1><h1 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h1><h1 id="Spring应用上下文"><a href="#Spring应用上下文" class="headerlink" title="Spring应用上下文"></a>Spring应用上下文</h1><h1 id="使用IOC容器"><a href="#使用IOC容器" class="headerlink" title="使用IOC容器"></a>使用IOC容器</h1><h1 id="Spring-IOC容器生命周期"><a href="#Spring-IOC容器生命周期" class="headerlink" title="Spring IOC容器生命周期"></a>Spring IOC容器生命周期</h1><h1 id="Spring中DI的运行时序图"><a href="#Spring中DI的运行时序图" class="headerlink" title="Spring中DI的运行时序图"></a>Spring中DI的运行时序图</h1><p>DI(Dependency Injection)依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就<br>是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。</p><h1 id="Spring中AOP的运行时序图"><a href="#Spring中AOP的运行时序图" class="headerlink" title="Spring中AOP的运行时序图"></a>Spring中AOP的运行时序图</h1><h1 id="Spring中MVC的运行时序图"><a href="#Spring中MVC的运行时序图" class="headerlink" title="Spring中MVC的运行时序图"></a>Spring中MVC的运行时序图</h1>]]></content>
    
    <summary type="html">
    
      spring的运行原理
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="spring" scheme="http://www.maishuren.top/tags/spring/"/>
    
      <category term="源码学习" scheme="http://www.maishuren.top/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="http://www.maishuren.top/tags/java/"/>
    
  </entry>
  
</feed>
