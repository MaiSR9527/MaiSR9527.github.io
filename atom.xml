<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>maiBlog</title>
  
  <subtitle>maishuren blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.maishuren.top/"/>
  <updated>2020-06-20T03:50:49.453Z</updated>
  <id>http://www.maishuren.top/</id>
  
  <author>
    <name>maishuren</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang学习二十一：select和GC</title>
    <link href="http://www.maishuren.top/posts/golang/202006201149-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006201149-index.html</id>
    <published>2020-06-20T03:49:52.000Z</published>
    <updated>2020-06-20T03:50:49.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="select简介"><a href="#select简介" class="headerlink" title="select简介"></a>select简介</h1><ul><li>Golang中select和switch结构特别像,但是select中case的条件只能是I/O</li><li>select 的语法(condition是条件)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">  <span class="keyword">case</span> condition:</span><br><span class="line">  <span class="keyword">case</span> condition:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>select执行过程:<ul><li>每个case必须是一个IO操作</li><li>哪个case可以执行就执行哪个</li><li>多个case都可以执行,随机执行一个</li><li>所有case都不能执行时,执行default</li><li>所有case都不能执行,且没有default,将会阻塞</li></ul></li><li>代码示例<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">   ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">   ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">   ch1 &lt;- <span class="number">1</span></span><br><span class="line">   ch2 &lt;- <span class="string">"hello"</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> value := &lt;-ch1:</span><br><span class="line">      fmt.Println(value)</span><br><span class="line">   <span class="keyword">case</span> value := &lt;-ch2:</span><br><span class="line">      fmt.Println(value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>select多和for循环结合使用,下面例子演示出了一直在接收消息的例子<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">ch &lt;- arg</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//如果是一直接受消息,应该是死循环for&#123;&#125;,下面代码中是明确知道消息个数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c := &lt;-ch:</span><br><span class="line">fmt.Println(<span class="string">"取出数据"</span>, c)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//没有default会出现死锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"程序执行结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>break可以对select生效,如果for中嵌套select,break选择最近结构</li></ul><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><ul><li>GC英文全称 garbage collector</li><li>Go语言GC是相对C/C++语言非常重要的改进</li><li>一些常用GC算法<ul><li>引用计算法.当对象被引用时计算器加一.不被引用计数器减一<ul><li>PHP和Object-C使用</li><li>相互引用无法回收</li><li>计数增加消耗</li></ul></li><li>Mark And Sweep 标记和清除算法.停止程序运行,递归遍历对象,进行标记.标记完成后将所有没有引用的对象进行清除<ul><li>由于标记需要停止程序(Stop the world),当对象特别多时,标记和清除过程比较耗时(可能几百毫秒),很难接受</li></ul></li><li>三色标记法:是Mark And Sweep的改进版.从逻辑上分为白色区(未搜索),灰色区(正搜索),黑色区(已搜索).灰色区内容是子引用没有进行搜索,黑色区表示子引用存在</li><li>分代收集.一般情况都有三代,例如java中新生代,老年代,永久代.当新生代中带有阈值时会把对象放入到老年代,相同道理老年代内容达到阈值会放入到永久代</li></ul></li></ul><h1 id="Go语言中的GC"><a href="#Go语言中的GC" class="headerlink" title="Go语言中的GC"></a>Go语言中的GC</h1><ul><li>Go语言中采用Stop The World方式</li><li>Golang每个版本基本上都会对GC进行优化,从Golang1.5开始支持并发(concurrent )收集,从1.8版本已经把STW时间优化到了100微妙,通常只需要10微妙以下.且在1.10版本时再次优化减少GC对CPU占用</li><li>Go语言中GC是自动运行的,在下列情况下会触发GC<ul><li>当需要申请内存时,发现GC是上次GC两倍时会触发</li><li>每2分钟自动运行一次GC</li></ul></li><li>GC调优<ul><li>小对象复用,局部变量尽量少声明,多个小对象可以放入到结构体,方便GC扫描</li><li>少用string的”+”</li></ul></li><li>在runtime包下mgc.go中明确的说明了Golang的GC的解释<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Garbage collector (GC).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The GC runs concurrently with mutator threads, is type accurate (aka precise), allows multiple</span></span><br><span class="line"><span class="comment">// GC thread to run in parallel. It is a concurrent mark and sweep that uses a write barrier. It is</span></span><br><span class="line"><span class="comment">// non-generational and non-compacting. Allocation is done using size segregated per P allocation</span></span><br><span class="line"><span class="comment">// areas to minimize fragmentation while eliminating locks in the common case.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The algorithm decomposes into several steps.</span></span><br><span class="line"><span class="comment">// This is a high level description of the algorithm being used. For an overview of GC a good</span></span><br><span class="line"><span class="comment">// place to start is Richard Jones' gchandbook.org.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The algorithm's intellectual heritage includes Dijkstra's on-the-fly algorithm, see</span></span><br><span class="line"><span class="comment">// Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. 1978.</span></span><br><span class="line"><span class="comment">// On-the-fly garbage collection: an exercise in cooperation. Commun. ACM 21, 11 (November 1978),</span></span><br><span class="line"><span class="comment">// 966-975.</span></span><br><span class="line"><span class="comment">// For journal quality proofs that these steps are complete, correct, and terminate see</span></span><br><span class="line"><span class="comment">// Hudson, R., and Moss, J.E.B. Copying Garbage Collection without stopping the world.</span></span><br><span class="line"><span class="comment">// Concurrency and Computation: Practice and Experience 15(3-5), 2003.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 1. GC performs sweep termination.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. Stop the world. This causes all Ps to reach a GC safe-point.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. Sweep any unswept spans. There will only be unswept spans if</span></span><br><span class="line"><span class="comment">//    this GC cycle was forced before the expected time.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 2. GC performs the "mark 1" sub-phase. In this sub-phase, Ps are</span></span><br><span class="line"><span class="comment">// allowed to locally cache parts of the work queue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. Prepare for the mark phase by setting gcphase to _GCmark</span></span><br><span class="line"><span class="comment">//    (from _GCoff), enabling the write barrier, enabling mutator</span></span><br><span class="line"><span class="comment">//    assists, and enqueueing root mark jobs. No objects may be</span></span><br><span class="line"><span class="comment">//    scanned until all Ps have enabled the write barrier, which is</span></span><br><span class="line"><span class="comment">//    accomplished using STW.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. Start the world. From this point, GC work is done by mark</span></span><br><span class="line"><span class="comment">//    workers started by the scheduler and by assists performed as</span></span><br><span class="line"><span class="comment">//    part of allocation. The write barrier shades both the</span></span><br><span class="line"><span class="comment">//    overwritten pointer and the new pointer value for any pointer</span></span><br><span class="line"><span class="comment">//    writes (see mbarrier.go for details). Newly allocated objects</span></span><br><span class="line"><span class="comment">//    are immediately marked black.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    c. GC performs root marking jobs. This includes scanning all</span></span><br><span class="line"><span class="comment">//    stacks, shading all globals, and shading any heap pointers in</span></span><br><span class="line"><span class="comment">//    off-heap runtime data structures. Scanning a stack stops a</span></span><br><span class="line"><span class="comment">//    goroutine, shades any pointers found on its stack, and then</span></span><br><span class="line"><span class="comment">//    resumes the goroutine.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    d. GC drains the work queue of grey objects, scanning each grey</span></span><br><span class="line"><span class="comment">//    object to black and shading all pointers found in the object</span></span><br><span class="line"><span class="comment">//    (which in turn may add those pointers to the work queue).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 3. Once the global work queue is empty (but local work queue caches</span></span><br><span class="line"><span class="comment">// may still contain work), GC performs the "mark 2" sub-phase.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. GC stops all workers, disables local work queue caches,</span></span><br><span class="line"><span class="comment">//    flushes each P's local work queue cache to the global work queue</span></span><br><span class="line"><span class="comment">//    cache, and reenables workers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. GC again drains the work queue, as in 2d above.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 4. Once the work queue is empty, GC performs mark termination.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. Stop the world.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. Set gcphase to _GCmarktermination, and disable workers and</span></span><br><span class="line"><span class="comment">//    assists.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    c. Drain any remaining work from the work queue (typically there</span></span><br><span class="line"><span class="comment">//    will be none).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    d. Perform other housekeeping like flushing mcaches.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 5. GC performs the sweep phase.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. Prepare for the sweep phase by setting gcphase to _GCoff,</span></span><br><span class="line"><span class="comment">//    setting up sweep state and disabling the write barrier.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. Start the world. From this point on, newly allocated objects</span></span><br><span class="line"><span class="comment">//    are white, and allocating sweeps spans before use if necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    c. GC does concurrent sweeping in the background and in response</span></span><br><span class="line"><span class="comment">//    to allocation. See description below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 6. When sufficient allocation has taken place, replay the sequence</span></span><br><span class="line"><span class="comment">// starting with 1 above. See discussion of GC rate below.</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习二十：golang并发编程入门</title>
    <link href="http://www.maishuren.top/posts/golang/202006201134-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006201134-index.html</id>
    <published>2020-06-20T03:34:59.000Z</published>
    <updated>2020-06-20T03:50:15.449Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h1><ul><li>Go语言中main()函数为主线程(协程),程序是从上向下执行的</li><li>可以通过time包下的Sleep(n)让程序阻塞多少纳秒<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"1"</span>)</span><br><span class="line"><span class="comment">//单位是纳秒,表示阻塞多长时间</span></span><br><span class="line"><span class="comment">//e9表示10的9次方</span></span><br><span class="line">time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">fmt.Println(<span class="string">"2"</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h1><ul><li>延迟指定时间后执行一次,但是需要注意在触发时程序没有结束<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"开始"</span>)</span><br><span class="line"> <span class="comment">//2秒后执行匿名函数</span></span><br><span class="line"> time.AfterFunc(<span class="number">2e9</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"延迟延迟触发"</span>)</span><br><span class="line"> &#125;)</span><br><span class="line"> time.Sleep(<span class="number">10e9</span>)<span class="comment">//一定要休眠,否则程序结束了</span></span><br><span class="line"> fmt.Println(<span class="string">"结束"</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="goroutine简介"><a href="#goroutine简介" class="headerlink" title="goroutine简介"></a>goroutine简介</h1><ul><li><p>Golang中最迷人的一个优点就是从语言层面就支持并发</p></li><li><p>在Golang中的goroutine(协程)类似于其他语言的线程</p></li><li><p>并发和并行</p><ul><li>并行(parallelism)指不同的代码片段同时在不同的物理处理器上支持</li><li>并发(concurrency)指同时管理多个事情,物理处理器上可能运行某个内容一半后就处理其他事情</li><li>在一般看来并发的性能要好于并行.因为计算机的物理资源是固定的,较少的,而程序需要执行的内容是很多的.所以并发是”以较少的资源去去做更多事情”</li></ul></li><li><p>几种主流并发模型</p><ul><li>多线程,每个线程只处理一个请求,只有请求结束后,对应的线程才会接收下一个请求.这种模式在高并发下,性能开销极大.</li><li>基于回调的异步IO.在程序运行过程中可能产生大量回调导致维护成本加大,程序执行流程也不便于思维</li><li>协程.不需要抢占式调用,可以有效提升线程任务的并发性,弥补了多线程模式的缺点;Golang在语言层面就支持,而其他语言很少支持</li></ul></li><li><p>goroutine的语法</p><ul><li>表达式可以是一条语句</li><li>表达式也可以是函数,函数返回值即使有,也无效,当函数执行完成此goroutine自动结束<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 表达式</span><br></pre></td></tr></table></figure><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2></li></ul></li><li><p>对比多次调用函数和使用goroutine的效果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//正常调用,输出3遍1 2 3 4 5(每个数字后换行)</span></span><br><span class="line">   <span class="comment">//for i:=1; i&lt;=3; i++ &#123;</span></span><br><span class="line">   <span class="comment">// go demo()</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   添加go关键字后发现控制台什么也没有输出</span></span><br><span class="line"><span class="comment">   原因:把demo()设置到协程后没等到函数执行,主</span></span><br><span class="line"><span class="comment">   线程执行结束</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> demo(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"第%d次执行,i的值为:%d\n"</span>, index, i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加休眠等待goroutine执行结束</p></li><li><p>这种方式很大的问题就是休眠时间,如果休眠时间设置过小,可能goroutine并没有执行完成,如果休眠时间设置过大,影响程序执行执行.找到的本次执行的休眠时间,下次程序执行时这个休眠时间可能”过大”或”过小”</p></li><li><p>通过程序运行结果发现每次执行结果都不一定是一样的,因为每个demo()都是并发执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//正常调用,输出3遍1 2 3 4 5(每个数字后换行)</span></span><br><span class="line">   <span class="comment">//for i:=1; i&lt;=3; i++ &#123;</span></span><br><span class="line">   <span class="comment">// go demo()</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   添加go关键字后发现控制台什么也没有输出</span></span><br><span class="line"><span class="comment">   原因:把demo()设置到协程后没等到函数执行,主</span></span><br><span class="line"><span class="comment">   线程执行结束</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> demo(i)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   添加休眠,让主线程等待协程执行结束.</span></span><br><span class="line"><span class="comment">   具体休眠时间需要根据计算机性能去估计</span></span><br><span class="line"><span class="comment">   次数没有固定值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   time.Sleep(<span class="number">3e9</span>)</span><br><span class="line">   fmt.Println(<span class="string">"程序执行结束"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"第%d次执行,i的值为:%d\n"</span>, index, i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="WaitGroup简介"><a href="#WaitGroup简介" class="headerlink" title="WaitGroup简介"></a>WaitGroup简介</h1><ul><li>Golang中sync包提供了基本同步基元,如互斥锁等.除了Once和WaitGroup类型,    大部分都只适用于低水平程序线程,高水平同步线程使用channel通信更好一些</li><li>WaitGroup直译为等待组,其实就是计数器,只要计数器中有内容将一直阻塞</li><li>在Golang中WaitGroup存在于sync包中,在sync包中类型都是不应该被拷贝的.源码定义如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A WaitGroup waits for a collection of goroutines to finish.</span></span><br><span class="line"><span class="comment">// The main goroutine calls Add to set the number of</span></span><br><span class="line"><span class="comment">// goroutines to wait for. Then each of the goroutines</span></span><br><span class="line"><span class="comment">// runs and calls Done when finished. At the same time,</span></span><br><span class="line"><span class="comment">// Wait can be used to block until all goroutines have finished.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A WaitGroup must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy noCopy</span><br><span class="line"></span><br><span class="line"><span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></span><br><span class="line"><span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></span><br><span class="line"><span class="comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span></span><br><span class="line"><span class="comment">// the aligned 8 bytes in them as state.</span></span><br><span class="line">state1 [<span class="number">12</span>]<span class="keyword">byte</span></span><br><span class="line">sema   <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Go语言标准库中WaitGroup只有三个方法<ul><li>Add(delta int)表示向内部计数器添加增量(delta),其中参数delta可以是负数</li><li>Done()表示减少WaitGroup计数器的值,应当在程序最后执行.相当于Add(-1)</li><li>Wait()表示阻塞直到WaitGroup计数器为0<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li>使用WaitGroup可以有效解决goroutine未执行完成主协程执行完成,导致程序结束,goroutine未执行问题<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> demo(i)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//阻塞,知道WaitGroup队列中所有任务执行结束时自动解除阻塞</span></span><br><span class="line">   fmt.Println(<span class="string">"开始阻塞"</span>)</span><br><span class="line">   wg.Wait()</span><br><span class="line">   fmt.Println(<span class="string">"任务执行结束,解除阻塞"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"第%d次执行,i的值为:%d\n"</span>, index, i)</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><ul><li>Go语言中多个协程操作一个变量时会出现冲突的问题</li><li>go run -race 可以查看竞争</li><li>可以使用<code>sync.Mutex</code>对内容加锁</li><li>互斥锁的使用场景<ul><li>多个goroutine访问同一个函数(代码段)</li><li>这个函数操作一个全局变量</li><li>为了保证共享变量安全性,值合法性</li></ul></li><li>使用互斥锁模拟售票窗口<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">   <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   <span class="comment">//票数</span></span><br><span class="line">   num = <span class="number">100</span></span><br><span class="line">   wg  sync.WaitGroup</span><br><span class="line">   <span class="comment">//互斥锁</span></span><br><span class="line">   mu sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sellTicker</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> wg.Done()</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">//加锁,多个goroutine互斥</span></span><br><span class="line">      mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> num &gt;= <span class="number">1</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">"第"</span>, i, <span class="string">"个窗口卖了"</span>, num)</span><br><span class="line">         num = num - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//解锁</span></span><br><span class="line">      mu.Unlock()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> num &lt;= <span class="number">0</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//添加休眠,防止结果可能出现在一个goroutine中</span></span><br><span class="line">      time.Sleep(time.Duration(rand.Int63n(<span class="number">1000</span>) * <span class="number">1e6</span>))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//设置随机数种子</span></span><br><span class="line">   rand.Seed(time.Now().UnixNano())</span><br><span class="line">   <span class="comment">//计算器的起始值和票数相同</span></span><br><span class="line">   wg.Add(<span class="number">4</span>)</span><br><span class="line">   <span class="keyword">go</span> sellTicker(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">go</span> sellTicker(<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">go</span> sellTicker(<span class="number">3</span>)</span><br><span class="line">   <span class="keyword">go</span> sellTicker(<span class="number">4</span>)</span><br><span class="line">   wg.Wait()</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"所有票卖完"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="RWMutex读写锁"><a href="#RWMutex读写锁" class="headerlink" title="RWMutex读写锁"></a>RWMutex读写锁</h1><ul><li>RWMutex 源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// There is a modified copy of this file in runtime/rwmutex.go.</span></span><br><span class="line"><span class="comment">// If you make any changes here, see if you should make them there.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A RWMutex is a reader/writer mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The lock can be held by an arbitrary number of readers or a single writer.</span></span><br><span class="line"><span class="comment">// The zero value for a RWMutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A RWMutex must not be copied after first use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If a goroutine holds a RWMutex for reading and another goroutine might</span></span><br><span class="line"><span class="comment">// call Lock, no goroutine should expect to be able to acquire a read lock</span></span><br><span class="line"><span class="comment">// until the initial read lock is released. In particular, this prohibits</span></span><br><span class="line"><span class="comment">// recursive read locking. This is to ensure that the lock eventually becomes</span></span><br><span class="line"><span class="comment">// available; a blocked Lock call excludes new readers from acquiring the</span></span><br><span class="line"><span class="comment">// lock.</span></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">writerSem   <span class="keyword">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers</span></span><br><span class="line">readerSem   <span class="keyword">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers</span></span><br><span class="line">readerCount <span class="keyword">int32</span>  <span class="comment">// number of pending readers</span></span><br><span class="line">readerWait  <span class="keyword">int32</span>  <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Go语言标准库中API如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span>//禁止其他协程读写</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span>//禁止其他协程写入,只能读取</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLocker</span><span class="params">()</span> <span class="title">Locker</span></span></span><br></pre></td></tr></table></figure></li><li>Go语言中的map不是线程安全的,多个goroutine同时操作会出现错误.</li><li>RWMutex可以添加多个读锁或一个写锁.读写锁不能同时存在.<ul><li>map在并发下读写就需要结合读写锁完成</li><li>互斥锁表示锁的代码同一时间只能有一个人goroutine运行,而读写锁表示在锁范围内数据的读写操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">   <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> rwm sync.RWMutex</span><br><span class="line">   m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">10</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">         <span class="comment">//没有锁在map时可能出现问题</span></span><br><span class="line">         rwm.Lock()</span><br><span class="line">         m[<span class="string">"key"</span>+strconv.Itoa(j)] = <span class="string">"value"</span> + strconv.Itoa(j)</span><br><span class="line">         fmt.Println(m)</span><br><span class="line">         rwm.Unlock()</span><br><span class="line">         wg.Done()</span><br><span class="line">      &#125;(i)</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">   fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><ul><li>线程通信在每个编程语言中都是重难点,在Golang中提供了语言级别的goroutine之间通信:channel</li><li>channel不同的翻译资料叫法不一样.常见的几种叫法<ul><li>管道</li><li>信道</li><li>通道</li></ul></li><li>channel是进程内通信方式,每个channel只能传递一个类型的值.这个类型需要在声明channel时指定</li><li>channel在Golang中主要的两个作用<ul><li>同步</li><li>通信</li></ul></li><li>Go语言中channel的关键字是chan</li><li>声明channel的语法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 名称 <span class="keyword">chan</span> 类型</span><br><span class="line"><span class="keyword">var</span> 名称 <span class="keyword">chan</span> &lt;- 类型 <span class="comment">//只写</span></span><br><span class="line"><span class="keyword">var</span> 名称 &lt;- <span class="keyword">chan</span> 类型<span class="comment">//只读</span></span><br><span class="line">名称:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//无缓存channel</span></span><br><span class="line">名称:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">0</span>)<span class="comment">//无缓存channel</span></span><br><span class="line">名称:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">100</span>)<span class="comment">//有缓存channel</span></span><br></pre></td></tr></table></figure></li><li>操作channel的语法:(假设定义一个channel名称为ch)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- 值 <span class="comment">//向ch中添加一个值</span></span><br><span class="line">&lt;- ch <span class="comment">//从ch中取出一个值</span></span><br><span class="line">a:=&lt;-ch <span class="comment">//从ch中取出一个值并赋值给a</span></span><br><span class="line">a,b:=&lt;-ch<span class="comment">//从ch中取出一个值赋值给a,如果ch已经关闭或ch中没有值,b为false</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li>简单无缓存通道代码示例<ul><li>此代码中如果没有从channel中取值c,d=&lt;-ch语句,程序结束时go func并没有执行</li><li>下面代码示例演示了同步操作,类似与WaitGroup功能,保证程序结束时goroutine已经执行完成</li><li>向goroutine中添加内容的代码会阻塞goroutine执行,所以要把ch&lt;-1放入到goroutine有效代码最后一行</li><li>无论是向channel存数据还是取数据都会阻塞</li><li>close(channel)关闭channel,关闭后只读不可写<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"进入goroutine"</span>)</span><br><span class="line">      <span class="comment">// 添加一个内容后控制台输出:1 true</span></span><br><span class="line">      <span class="comment">//ch&lt;-1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//关闭ch控制台输出:0 false</span></span><br><span class="line">      <span class="built_in">close</span>(ch)</span><br><span class="line">   &#125;()</span><br><span class="line">   c, d := &lt;-ch </span><br><span class="line">   fmt.Println(c, d)</span><br><span class="line">   fmt.Println(<span class="string">"程序执行结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>使用channel实现goroutine之间通信<ul><li>channel其实就是消息通信机制实现方案,在Golang中没有使用共享内存完成线程通信,而是使用channel实现goroutine之间通信.<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//用于goroutine之间传递数据</span></span><br><span class="line">   ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">   <span class="comment">//用于控制程序执行</span></span><br><span class="line">   ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"执行第一个goroutine,等待第二个goroutine传递数据"</span>)</span><br><span class="line">      content := &lt;-ch</span><br><span class="line">      fmt.Println(<span class="string">"接收到的数据为:"</span>, content)</span><br><span class="line">      ch2 &lt;- <span class="string">"第一个"</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"进入到第二个,开始传递数据"</span>)</span><br><span class="line">      ch &lt;- <span class="string">"内容随意"</span></span><br><span class="line">      <span class="built_in">close</span>(ch)</span><br><span class="line">      fmt.Println(<span class="string">"发送数据完成"</span>)</span><br><span class="line">      ch2 &lt;- <span class="string">"第二个"</span></span><br><span class="line">   &#125;()</span><br><span class="line">   result1 := &lt;-ch2</span><br><span class="line">   fmt.Println(result1, <span class="string">"执行完成"</span>)</span><br><span class="line">   result2 := &lt;-ch2</span><br><span class="line">   fmt.Println(result2, <span class="string">"执行完成"</span>)</span><br><span class="line">   fmt.Println(<span class="string">"程序执行结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>可以使用for range获取channel中内容<ul><li>不需要确定channel中数据个数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">   ch2:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> i:=<span class="number">97</span>;i&lt;<span class="number">97</span>+<span class="number">26</span>;i++&#123;</span><br><span class="line">         ch &lt;- strconv.Itoa(i)</span><br><span class="line">      &#125;</span><br><span class="line">      ch2&lt;<span class="number">-1</span></span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> c := <span class="keyword">range</span> ch&#123;</span><br><span class="line">         fmt.Println(<span class="string">"取出来的"</span>,c)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   &lt;-ch2</span><br><span class="line">   fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>channel是安全的.多个goroutine同时操作时,同一时间只能有一个goroutine存取数据<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">         fmt.Println(j, <span class="string">"开始"</span>)</span><br><span class="line">         ch &lt;- j</span><br><span class="line">         fmt.Println(j, <span class="string">"结束"</span>)</span><br><span class="line">      &#125;(i)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">      time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">      &lt;-ch</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ul><li>在主goroutine中向无缓存channel添加内容或在主goroutine中向channel添加内容且添加内容的个数已经大于channel缓存个数就会产生死锁<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error : all goroutines are asleep -deadlock!</span><br></pre></td></tr></table></figure></li><li>死锁:在程序中多个进程(Golang中goroutine)由于相互竞争资源而产生的阻塞(等待)状态,而这种状态一直保持下去,此时称这个线程是死锁状态</li><li>在Golang中使用无缓存channel时一定要注意.以下是一个最简单的死锁程序<ul><li>主协程中有ch&lt;-1,无缓存channel无论添加还是取出数据都会阻塞goroutine,当前程序无其他代码,主goroutine会一直被阻塞下去,此时主goroutine就是死锁状态<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>而下面代码就不会产生死锁<ul><li>通过代码示例可以看出,在使用无缓存channel时,特别要注意的是在主协程中有操作channel代码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      ch &lt;- <span class="number">1</span></span><br><span class="line">      fmt.Println(<span class="string">"执行goroutine"</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   time.Sleep(<span class="number">5e9</span>)</span><br><span class="line">   fmt.Println(<span class="string">"程序执行结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="有缓存通道"><a href="#有缓存通道" class="headerlink" title="有缓存通道"></a>有缓存通道</h1><ul><li>创建一个有缓存通道<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">//缓存大小3,里面消息个数小于等于3时都不会阻塞goroutine</span></span><br><span class="line">   ch &lt;- <span class="number">1</span></span><br><span class="line">   ch &lt;- <span class="number">2</span></span><br><span class="line">   ch &lt;- <span class="number">3</span></span><br><span class="line">   ch &lt;- <span class="number">4</span> <span class="comment">//此行出现死锁,超过缓存大小数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在Golang中有缓存channel的缓存大小是不能改变的,但是只要不超过缓存数量大小,都不会出现阻塞状态<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">//缓存大小3,里面消息个数小于等于3时都不会阻塞goroutine</span></span><br><span class="line">   ch &lt;- <span class="number">1</span></span><br><span class="line">   fmt.Println(&lt;-ch)</span><br><span class="line">   ch &lt;- <span class="number">2</span></span><br><span class="line">   fmt.Println(&lt;-ch)</span><br><span class="line">   ch &lt;- <span class="number">3</span></span><br><span class="line">   ch &lt;- <span class="number">4</span></span><br><span class="line">   fmt.Println(<span class="built_in">len</span>(ch))<span class="comment">//输出2,表示channel中有两个消息</span></span><br><span class="line">   fmt.Println(<span class="built_in">cap</span>(ch))<span class="comment">//输出3,表示缓存大小总量为3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十九：日志</title>
    <link href="http://www.maishuren.top/posts/golang/202006201131-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006201131-index.html</id>
    <published>2020-06-20T03:31:14.000Z</published>
    <updated>2020-06-20T03:31:53.403Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="日志简介"><a href="#日志简介" class="headerlink" title="日志简介"></a>日志简介</h1><ul><li>使用开发工具时,控制台打印的信息就是日志信息</li><li>项目最终发布后是没有开发工具的,而需要记录日志应该把信息输出到文件中,这个功能也是日志的功能</li><li>在Go语言标准的log包提供了对日志的支持</li><li>有三种级别日志输出<ul><li>Print() 输出日志信息</li><li>Panic()  打印日志信息,并触发panic,日志信息为Panic信息</li><li>Fatal()  打印日志信息后调用os.Exit(1)</li></ul></li><li>所有日志信息打印时都带有时间,且颜色为红色</li><li>每种级别日志打印都提供了三个函数<ul><li>Println()</li><li>Print()</li><li>Printf()</li></ul></li><li>日志文件扩展名为log<h1 id="普通日志信息打印"><a href="#普通日志信息打印" class="headerlink" title="普通日志信息打印"></a>普通日志信息打印</h1></li><li>官方源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">std.Output(<span class="number">2</span>, fmt.Sprintln(v...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>直接使用log包调用Println()即可<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.Println(<span class="string">"打印日志信息"</span>)</span><br></pre></td></tr></table></figure><h1 id="Panic日志信息打印"><a href="#Panic日志信息打印" class="headerlink" title="Panic日志信息打印"></a>Panic日志信息打印</h1></li><li>通过源码可以看出在日志信息打印后调用了panic()函数,且日志信息为panic信息<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Panicln is equivalent to Println() followed by a call to panic().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Panicln</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">s := fmt.Sprintln(v...)</span><br><span class="line">std.Output(<span class="number">2</span>, s)</span><br><span class="line"><span class="built_in">panic</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>执行后输出日志信息,同时也会触发panic<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.Panicln(<span class="string">"打印日志信息"</span>)</span><br></pre></td></tr></table></figure><h1 id="致命日志信息"><a href="#致命日志信息" class="headerlink" title="致命日志信息"></a>致命日志信息</h1></li><li>打印日志后,终止程序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fatal is equivalent to Print() followed by a call to os.Exit(1).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fatal</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">std.Output(<span class="number">2</span>, fmt.Sprint(v...))</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>执行日志打印后,程序被终止<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.Fatal(<span class="string">"打印日志信息"</span>)</span><br></pre></td></tr></table></figure><h1 id="打印日志信息到文件中"><a href="#打印日志信息到文件中" class="headerlink" title="打印日志信息到文件中"></a>打印日志信息到文件中</h1></li><li>Go语言标准库支持输出日志信息到文件中.</li><li>输出日志时的几种状态<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Ldate         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">// the date in the local time zone: 2009/01/23</span></span><br><span class="line">Ltime                         <span class="comment">// the time in the local time zone: 01:23:23</span></span><br><span class="line">Lmicroseconds                 <span class="comment">// microsecond resolution: 01:23:23.123123.  assumes Ltime.</span></span><br><span class="line">Llongfile                     <span class="comment">// full file name and line number: /a/b/c/d.go:23</span></span><br><span class="line">Lshortfile                    <span class="comment">// final file name element and line number: d.go:23. overrides Llongfile</span></span><br><span class="line">LUTC                          <span class="comment">// if Ldate or Ltime is set, use UTC rather than the local time zone</span></span><br><span class="line">LstdFlags     = Ldate | Ltime <span class="comment">// initial values for the standard logger</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>代码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, _ := os.OpenFile(<span class="string">"D:/golog.log"</span>, os.O_APPEND|os.O_CREATE, <span class="number">07777</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">logger := log.New(f, <span class="string">"[info]\t"</span>, log.Ltime)</span><br><span class="line">logger.Println(<span class="string">"输出日志信息"</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十八：XML操作</title>
    <link href="http://www.maishuren.top/posts/goalng/202006201125-index.html"/>
    <id>http://www.maishuren.top/posts/goalng/202006201125-index.html</id>
    <published>2020-06-20T03:25:17.000Z</published>
    <updated>2020-06-20T03:30:20.578Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Go语言标准库提供的API"><a href="#Go语言标准库提供的API" class="headerlink" title="Go语言标准库提供的API"></a>Go语言标准库提供的API</h1><ul><li>在encoding/xml包下提供了对XML序列化和反序列化的API</li><li>使用Unmarshal可以直接把XML字节切片数据转换为结构体</li><li>转换时按照特定的转换规则进行转换,且数据类型可以自动转换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* 如果结构体字段的类型为字符串或者[]byte，且标签为&quot;,innerxml&quot;，</span><br><span class="line">  Unmarshal函数直接将对应原始XML文本写入该字段，其余规则仍适用。</span><br><span class="line">* 如果结构体字段类型为xml.Name且名为XMLName，Unmarshal会将元素名写入该字段</span><br><span class="line">* 如果字段XMLName的标签的格式为&quot;name&quot;或&quot;namespace-URL name&quot;，</span><br><span class="line">  XML元素必须有给定的名字（以及可选的名字空间），否则Unmarshal会返回错误。</span><br><span class="line">* 如果XML元素的属性的名字匹配某个标签&quot;,attr&quot;为字段的字段名，或者匹配某个标签为&quot;name,attr&quot;</span><br><span class="line">  的字段的标签名，Unmarshal会将该属性的值写入该字段。</span><br><span class="line">* 如果XML元素包含字符数据，该数据会存入结构体中第一个具有标签&quot;,chardata&quot;的字段中，</span><br><span class="line">  该字段可以是字符串类型或者[]byte类型。如果没有这样的字段，字符数据会丢弃。</span><br><span class="line">* 如果XML元素包含注释，该数据会存入结构体中第一个具有标签&quot;,comment&quot;的字段中，</span><br><span class="line">  该字段可以是字符串类型或者[]byte类型。如果没有这样的字段，字符数据会丢弃。</span><br><span class="line">* 如果XML元素包含一个子元素，其名称匹配格式为&quot;a&quot;或&quot;a&gt;b&gt;c&quot;的标签的前缀，反序列化会深入</span><br><span class="line">  XML结构中寻找具有指定名称的元素，并将最后端的元素映射到该标签所在的结构体字段。</span><br><span class="line">  以&quot;&gt;&quot;开始的标签等价于以字段名开始并紧跟着&quot;&gt;&quot; 的标签。</span><br><span class="line">* 如果XML元素包含一个子元素，其名称匹配某个结构体类型字段的XMLName字段的标签名，</span><br><span class="line">  且该结构体字段本身没有显式指定标签名，Unmarshal会将该元素映射到该字段。</span><br><span class="line">* 如果XML元素的包含一个子元素，其名称匹配够格结构体字段的字段名，且该字段没有任何模式选项</span><br><span class="line">  （&quot;,attr&quot;、&quot;,chardata&quot;等），Unmarshal会将该元素映射到该字段。</span><br><span class="line">* 如果XML元素包含的某个子元素不匹配以上任一条，而存在某个字段其标签为&quot;,any&quot;，</span><br><span class="line">  Unmarshal会将该元素映射到该字段。</span><br><span class="line">* 匿名字段被处理为其字段好像位于外层结构体中一样。</span><br><span class="line">* 标签为&quot;-&quot;的结构体字段永不会被反序列化填写。</span><br></pre></td></tr></table></figure></li></ul><h1 id="XML文件读取"><a href="#XML文件读取" class="headerlink" title="XML文件读取"></a>XML文件读取</h1><ul><li>给定XML文件内容如下<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">people</span> <span class="attr">id</span>=<span class="string">"888"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>msr<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span>中国上海<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>新建结构体,装载XML数据<ul><li>结构体中属性首字母必须大写,否则无法装配<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName xml.Name <span class="string">`xml:"people"`</span></span><br><span class="line">Id      <span class="keyword">int</span>      <span class="string">`xml:"id,attr"`</span></span><br><span class="line">Name    <span class="keyword">string</span>   <span class="string">`xml:"name"`</span></span><br><span class="line">Address <span class="keyword">string</span>   <span class="string">`xml:"address"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">peo := <span class="built_in">new</span>(People)</span><br><span class="line">b, err := ioutil.ReadFile(<span class="string">"demo.xml"</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">fmt.Println(<span class="string">"111:"</span>, err)</span><br><span class="line">err = xml.Unmarshal(b, peo)</span><br><span class="line">fmt.Println(<span class="string">"2222"</span>, err)</span><br><span class="line">fmt.Println(peo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多层嵌套XML文件读取"><a href="#多层嵌套XML文件读取" class="headerlink" title="多层嵌套XML文件读取"></a>多层嵌套XML文件读取</h1></li></ul></li><li>给定XML中数据如下<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">peoples</span> <span class="attr">version</span>=<span class="string">"0.9"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">people</span> <span class="attr">id</span>=<span class="string">"888"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>msr<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">address</span>&gt;</span>中国上海<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">people</span> <span class="attr">id</span>=<span class="string">"998"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>maishuren<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">address</span>&gt;</span>中国上海<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">peoples</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>编写读取XML数据代码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Peoples <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName xml.Name <span class="string">`xml:"peoples"`</span></span><br><span class="line">Version <span class="keyword">string</span>   <span class="string">`xml:"version,attr"`</span></span><br><span class="line">Peos    []People <span class="string">`xml:"people"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName xml.Name <span class="string">`xml:"people"`</span></span><br><span class="line">Id      <span class="keyword">int</span>      <span class="string">`xml:"id,attr"`</span></span><br><span class="line">Name    <span class="keyword">string</span>   <span class="string">`xml:"name"`</span></span><br><span class="line">Address <span class="keyword">string</span>   <span class="string">`xml:"address"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">peo := <span class="built_in">new</span>(Peoples)</span><br><span class="line">b, err := ioutil.ReadFile(<span class="string">"demo.xml"</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">fmt.Println(<span class="string">"111:"</span>, err)</span><br><span class="line">err = xml.Unmarshal(b, peo)</span><br><span class="line">fmt.Println(<span class="string">"2222"</span>, err)</span><br><span class="line">fmt.Println(peo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="生成XML"><a href="#生成XML" class="headerlink" title="生成XML"></a>生成XML</h1><ul><li>生成XML只要在学习下encoding/xml包下的Marshal()函数,结合输入流就可以完成xml文件生成</li><li>在encoding/xml中有常量,常量中是xml文档头<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Header is a generic XML header suitable for use with the output of Marshal.</span></span><br><span class="line"><span class="comment">// This is not automatically added to any output of this package,</span></span><br><span class="line"><span class="comment">// it is provided as a convenience.</span></span><br><span class="line">Header = <span class="string">`&lt;?xml version="1.0" encoding="UTF-8"?&gt;`</span> + <span class="string">"\n"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li>使用Marshal()函数生成的[]byte没有格式化</li><li>使用MarshalIndent()可以对内容进行格式化<ul><li>第一个参数:结构体对象</li><li>第二个参数:每行的前缀</li><li>第三个参数:层级缩进内容<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName xml.Name <span class="string">`xml:"people"`</span></span><br><span class="line">Id      <span class="keyword">int</span>      <span class="string">`xml:"id,attr"`</span></span><br><span class="line">Name    <span class="keyword">string</span>   <span class="string">`xml:"name"`</span></span><br><span class="line">Address <span class="keyword">string</span>   <span class="string">`xml:"address"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">peo := People&#123;Id: <span class="number">123</span>, Name: <span class="string">"maishuren"</span>, Address: <span class="string">"中国上海"</span>&#125;</span><br><span class="line">b, _ := xml.MarshalIndent(peo, <span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">b = <span class="built_in">append</span>([]<span class="keyword">byte</span>(xml.Header), b...)</span><br><span class="line">ioutil.WriteFile(<span class="string">"D:/peo.xml"</span>, b, <span class="number">0666</span>)</span><br><span class="line">fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十七：反射</title>
    <link href="http://www.maishuren.top/posts/goalng/202006201120-index.html"/>
    <id>http://www.maishuren.top/posts/goalng/202006201120-index.html</id>
    <published>2020-06-20T03:20:58.000Z</published>
    <updated>2020-06-20T03:24:47.374Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h1><ul><li>在Go语言标准库中reflect包提供了运行时反射,程序运行过程中动态操作结构体</li><li>当变量存储结构体属性名称,想要对结构体这个属性赋值或查看时,就可以使用反射.</li><li>反射还可以用作判断变量类型</li><li>整个reflect包中最重要的两个类型<ul><li>reflect.Type 类型</li><li>reflect.Value 值</li></ul></li><li>获取到Type和Value的函数<ul><li>reflect.TypeOf(interface{}) 返回Type</li><li>reflect.ValueOf(interface{}) 返回值Value</li></ul></li></ul><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><ul><li>判断变量类型<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="number">1.5</span></span><br><span class="line">fmt.Println(reflect.TypeOf(a))</span><br></pre></td></tr></table></figure></li><li>获取结构体属性的值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ype People <span class="keyword">struct</span> &#123;</span><br><span class="line">   Id   <span class="keyword">int</span></span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"asdf"</span>)</span><br><span class="line"></span><br><span class="line">   peo := People&#123;<span class="number">1</span>, <span class="string">"张三"</span>&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取peo的值</span></span><br><span class="line">   v := reflect.ValueOf(peo)</span><br><span class="line">   <span class="comment">//获取属性个数,如果v不是结构体类型panic</span></span><br><span class="line">   fmt.Println(v.NumField())</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取第0个属性,id,并转换为int64类型</span></span><br><span class="line">   fmt.Println(v.Field(<span class="number">0</span>).Int())</span><br><span class="line">   <span class="comment">//获取第1个属性,转换换为string类型</span></span><br><span class="line">   fmt.Println(v.Field(<span class="number">1</span>).String())</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据名字获取类型,并把类型名称转换为string类型</span></span><br><span class="line">   idValue := v.FieldByName(<span class="string">"Id"</span>)</span><br><span class="line">   fmt.Println(idValue.Kind().String())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>设置结构体属性的值时要传递结构体指针,否者无法获取设置的结构体对象<ul><li>反射直射结构体属性时,要求属性名首字母必须大写,否则无法设置<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">   Id   <span class="keyword">int</span></span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"asdf"</span>)</span><br><span class="line">   peo := People&#123;<span class="number">1</span>, <span class="string">"张三"</span>&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   反射时获取peo的地址.</span></span><br><span class="line"><span class="comment">   Elem()获取指针指向地址的封装.</span></span><br><span class="line"><span class="comment">   地址的值必须调用Elem()才可以继续操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   v := reflect.ValueOf(&amp;peo).Elem()</span><br><span class="line"></span><br><span class="line">   fmt.Println(v.FieldByName(<span class="string">"Id"</span>).CanSet())</span><br><span class="line">   v.FieldByName(<span class="string">"Id"</span>).SetInt(<span class="number">123</span>)</span><br><span class="line">   v.FieldByName(<span class="string">"Name"</span>).SetString(<span class="string">"李四"</span>)</span><br><span class="line">   fmt.Println(peo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>结构体支持标记(tag),标记通常都是通过反射技术获取到.结构体标记语法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type 结构体名称 struct&#123;</span><br><span class="line">  属性名 类型 &#96;key:&quot;Value&quot;&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>获取结构体标记(tag)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`xml:"name"`</span></span><br><span class="line">Address <span class="keyword">string</span> <span class="string">`xml:"address"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t:=reflect.TypeOf(People&#123;&#125;)</span><br><span class="line">name,_:=t.FieldByName(<span class="string">"Name"</span>)</span><br><span class="line">fmt.Println(name.Tag)<span class="comment">//获取完整标记</span></span><br><span class="line">fmt.Println(name.Tag.Get(<span class="string">"xml"</span>))<span class="comment">//获取标记中xml对应内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十六：文件操作</title>
    <link href="http://www.maishuren.top/posts/goalng/202006201116-index.html"/>
    <id>http://www.maishuren.top/posts/goalng/202006201116-index.html</id>
    <published>2020-06-20T03:16:19.000Z</published>
    <updated>2020-06-20T03:20:00.179Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="os包结构介绍"><a href="#os包结构介绍" class="headerlink" title="os包结构介绍"></a>os包结构介绍</h1><ul><li>Go语言标准库中os包提供了不依赖平台的操作系统接口</li><li>设计为Unix风格的，而错误处理是go风格的,失败的调用会返回错误值而非错误码。通常错误值里包含更多信息</li><li>os包及子包功能<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- os 包</span><br><span class="line">  --os&#x2F;exec 包,负责执行外部命令.</span><br><span class="line">  --os&#x2F;signal对输入信息的访问</span><br><span class="line">  --os&#x2F;user 通过名称或ID查询用户账户</span><br></pre></td></tr></table></figure></li><li>在os/user中提供了User结构体,表示操作系统用户<ul><li>Uid 用户id</li><li>Gid 所属组id</li><li>Username 用户名</li><li>Name 所属组名</li><li>HomeDir 用户对应文件夹路径<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User represents a user account.</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Uid is the user ID.</span></span><br><span class="line"><span class="comment">// On POSIX systems, this is a decimal number representing the uid.</span></span><br><span class="line"><span class="comment">// On Windows, this is a security identifier (SID) in a string format.</span></span><br><span class="line"><span class="comment">// On Plan 9, this is the contents of /dev/user.</span></span><br><span class="line">Uid <span class="keyword">string</span></span><br><span class="line"><span class="comment">// Gid is the primary group ID.</span></span><br><span class="line"><span class="comment">// On POSIX systems, this is a decimal number representing the gid.</span></span><br><span class="line"><span class="comment">// On Windows, this is a SID in a string format.</span></span><br><span class="line"><span class="comment">// On Plan 9, this is the contents of /dev/user.</span></span><br><span class="line">Gid <span class="keyword">string</span></span><br><span class="line"><span class="comment">// Username is the login name.</span></span><br><span class="line">Username <span class="keyword">string</span></span><br><span class="line"><span class="comment">// Name is the user's real or display name.</span></span><br><span class="line"><span class="comment">// It might be blank.</span></span><br><span class="line"><span class="comment">// On POSIX systems, this is the first (or only) entry in the GECOS field</span></span><br><span class="line"><span class="comment">// list.</span></span><br><span class="line"><span class="comment">// On Windows, this is the user's display name.</span></span><br><span class="line"><span class="comment">// On Plan 9, this is the contents of /dev/user.</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line"><span class="comment">// HomeDir is the path to the user's home directory (if they have one).</span></span><br><span class="line">HomeDir <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>在os/user中的Group表示用户所属组<ul><li>Gid 组的id</li><li>Name 组的名称<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group represents a grouping of users.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// On POSIX systems Gid contains a decimal number representing the group ID.</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">Gid  <span class="keyword">string</span> <span class="comment">// group ID</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="comment">// group name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>整个os/user包中内容比较少,提供了两个错误类型和获取当前用户,查找用户<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnknownUserError</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(e UnknownUserError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="keyword">type</span> UnknownUserIdError</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(e UnknownUserIdError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="keyword">type</span> User</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">Current</span><span class="params">()</span> <span class="params">(*User, error)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(username <span class="keyword">string</span>)</span> <span class="params">(*User, error)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">LookupId</span><span class="params">(uid <span class="keyword">string</span>)</span> <span class="params">(*User, error)</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li>可以获取当前用户或查找用户后获取用户信息<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前登录用户</span></span><br><span class="line"><span class="comment">//u,_:=user.Current()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Lookup()参数是用户名,按照用户名查找指定用户对象</span></span><br><span class="line"><span class="comment">注意:必须使用完整名称不可以只写zhang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u, _ := user.Lookup(<span class="string">`LAPTOP-APM56\maishuren`</span>)</span><br><span class="line">fmt.Println(u.Name)</span><br><span class="line">fmt.Println(u.Gid)</span><br><span class="line">fmt.Println(u.HomeDir)</span><br><span class="line">fmt.Println(u.Uid)</span><br><span class="line">fmt.Println(u.Username)</span><br></pre></td></tr></table></figure></li></ul><h1 id="os包内容介绍"><a href="#os包内容介绍" class="headerlink" title="os包内容介绍"></a>os包内容介绍</h1><ul><li><p>使用os包中内容进行操作系统文件或目录</p></li><li><p>File结构体表示操作系统文件(夹)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File represents an open file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">*file <span class="comment">// os specific</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file is the real representation of *File.</span></span><br><span class="line"><span class="comment">// The extra level of indirection ensures that no clients of os</span></span><br><span class="line"><span class="comment">// can overwrite this data, which could cause the finalizer</span></span><br><span class="line"><span class="comment">// to close the wrong file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">pfd     poll.FD</span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">dirinfo *dirInfo <span class="comment">// nil unless directory being read</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>操作系统的文件都是有权限控制的,包含可读,可写等,在os包中FileMode表示文件权限,本质是uint32,可取值都以常量形式提供</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FileMode represents a file's mode and permission bits.</span></span><br><span class="line"><span class="comment">// The bits have the same definition on all systems, so that</span></span><br><span class="line"><span class="comment">// information about files can be moved from one system</span></span><br><span class="line"><span class="comment">// to another portably. Not all bits apply to all systems.</span></span><br><span class="line"><span class="comment">// The only required bit is ModeDir for directories.</span></span><br><span class="line"><span class="keyword">type</span> FileMode <span class="keyword">uint32</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The defined file mode bits are the most significant bits of the FileMode.</span></span><br><span class="line"><span class="comment">// The nine least-significant bits are the standard Unix rwxrwxrwx permissions.</span></span><br><span class="line"><span class="comment">// The values of these bits should be considered part of the public API and</span></span><br><span class="line"><span class="comment">// may be used in wire protocols or disk representations: they must not be</span></span><br><span class="line"><span class="comment">// changed, although new bits might be added.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// The single letters are the abbreviations</span></span><br><span class="line"><span class="comment">// used by the String method's formatting.</span></span><br><span class="line">ModeDir        FileMode = <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - <span class="number">1</span> - <span class="literal">iota</span>) <span class="comment">// d: is a directory</span></span><br><span class="line">ModeAppend                                     <span class="comment">// a: append-only</span></span><br><span class="line">ModeExclusive                                  <span class="comment">// l: exclusive use</span></span><br><span class="line">ModeTemporary                                  <span class="comment">// T: temporary file; Plan 9 only</span></span><br><span class="line">ModeSymlink                                    <span class="comment">// L: symbolic link</span></span><br><span class="line">ModeDevice                                     <span class="comment">// D: device file</span></span><br><span class="line">ModeNamedPipe                                  <span class="comment">// p: named pipe (FIFO)</span></span><br><span class="line">ModeSocket                                     <span class="comment">// S: Unix domain socket</span></span><br><span class="line">ModeSetuid                                     <span class="comment">// u: setuid</span></span><br><span class="line">ModeSetgid                                     <span class="comment">// g: setgid</span></span><br><span class="line">ModeCharDevice                          <span class="comment">// c: Unix character device, when ModeDevice is set</span></span><br><span class="line">ModeSticky                                     <span class="comment">// t: sticky</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mask for the type bits. For regular files, none will be set.</span></span><br><span class="line">ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice</span><br><span class="line"></span><br><span class="line">ModePerm FileMode = <span class="number">0777</span> <span class="comment">// Unix permission bits</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>FIleInfo是一个interface表示文件的信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FileInfo describes a file and is returned by Stat and Lstat.</span></span><br><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span>       <span class="comment">// base name of the file</span></span><br><span class="line">Size() <span class="keyword">int64</span>        <span class="comment">// length in bytes for regular files; system-dependent for others</span></span><br><span class="line">Mode() FileMode     <span class="comment">// file mode bits</span></span><br><span class="line">ModTime() time.Time <span class="comment">// modification time</span></span><br><span class="line">IsDir() <span class="keyword">bool</span>        <span class="comment">// abbreviation for Mode().IsDir()</span></span><br><span class="line">Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// underlying data source (can return nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="资源路径"><a href="#资源路径" class="headerlink" title="资源路径"></a>资源路径</h2></li><li><p>在获取系统资源时资源路径分为相对路径和绝对路径</p></li><li><p>相对路径:在Go语言中相对路径用于是GOPATH,也就是项目的根目录</p></li><li><p>绝对路径:磁盘根目录开始表示资源详细路径的描述</p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2></li><li><p>Go语言标准库中提供了两种创建文件夹的方式</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要求文件夹不存在且父目录必须存在,才能创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//error := os.Mkdir("D:/godir", os.ModeDir)</span></span><br><span class="line"><span class="comment">//if error != nil &#123;</span></span><br><span class="line"><span class="comment">//fmt.Println("文件夹创建失败",error)</span></span><br><span class="line"><span class="comment">//return</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//fmt.Println("文件夹创建成功")</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果文件夹已经存在,不报错,保留原文件夹</span></span><br><span class="line"><span class="comment">如果父目录不存在帮助创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error := os.MkdirAll(<span class="string">"D:/godir/a/b"</span>, os.ModeDir)</span><br><span class="line"><span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件夹创建失败"</span>,error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"文件夹创建成功"</span>)</span><br></pre></td></tr></table></figure><ul><li>创建空文件<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建文件时要求文件目录必须已经存在</span></span><br><span class="line"><span class="comment">如果文件已经存在则会创建一个空文件覆盖之前的文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">file, err := os.Create(<span class="string">"D:/godir/test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件创建失败,"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"文件创建成功"</span>,file.Name())</span><br></pre></td></tr></table></figure></li><li>重命名文件或文件夹<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数:原文件夹名称,要求此路径是必须存在的</span></span><br><span class="line"><span class="comment">第二个参数:新文件夹名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err := os.Rename(<span class="string">"D:/godir"</span>, <span class="string">"D:/godir1"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"重命名文件夹失败,"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"文件夹重命名成功"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">重命名文件和重命名文件夹用法相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = os.Rename(<span class="string">"D:/godir1/test.txt"</span>, <span class="string">"D:/godir1/test1.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"重命名文件失败,"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"文件重命名成功"</span>)</span><br></pre></td></tr></table></figure></li><li>获取文件(夹)信息<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">"D:/godir1/test1.txt"</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close() <span class="comment">//文件打开后要关闭,释放资源</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"打开文件失败"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fileInfo, err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"获取文件信息失败"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(fileInfo.Name())    <span class="comment">//文件名</span></span><br><span class="line">fmt.Println(fileInfo.IsDir())   <span class="comment">//是否是文件夹,返回bool,true表示文件夹,false表示文件</span></span><br><span class="line">fmt.Println(fileInfo.Mode())    <span class="comment">//文件权限</span></span><br><span class="line">fmt.Println(fileInfo.ModTime()) <span class="comment">//修改时间</span></span><br><span class="line">fmt.Println(fileInfo.Size())    <span class="comment">//文件大小</span></span><br></pre></td></tr></table></figure></li><li>删除文件或文件夹<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除的内容只能是一个文件或空文件夹且必须存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//err := os.Remove("D:/godir1/a")</span></span><br><span class="line"><span class="comment">//if err != nil &#123;</span></span><br><span class="line"><span class="comment">//fmt.Println("文件删除失败", err)</span></span><br><span class="line"><span class="comment">//return</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//fmt.Println("删除成功")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">只要文件夹存在,删除文件夹.</span></span><br><span class="line"><span class="comment">无论文件夹是否有内容都会删除</span></span><br><span class="line"><span class="comment">如果删除目标是文件,则删除文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err := os.RemoveAll(<span class="string">"D:/godir1/a.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"删除失败"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"删除成功"</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h1><ul><li><p>流(stream)是应用程序和外部资源进行数据交互的纽带</p></li><li><p>流分为输入流和输出流,输入和输出都是相对于程序,把外部数据传入到程序中叫做输入,反之叫做输出流</p></li><li><p>输入流(Input Stream),输入流(Output Stream) 平时所说的I/O流</p></li><li><p>在Go语言标准库中io包下是Reader接口表示输入流,只要实现这个接口就属于输入流</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader is the interface that wraps the basic Read method.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Read reads up to len(p) bytes into p. It returns the number of bytes</span></span><br><span class="line"><span class="comment">// read (0 &lt;= n &lt;= len(p)) and any error encountered. Even if Read</span></span><br><span class="line"><span class="comment">// returns n &lt; len(p), it may use all of p as scratch space during the call.</span></span><br><span class="line"><span class="comment">// If some data is available but not len(p) bytes, Read conventionally</span></span><br><span class="line"><span class="comment">// returns what is available instead of waiting for more.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When Read encounters an error or end-of-file condition after</span></span><br><span class="line"><span class="comment">// successfully reading n &gt; 0 bytes, it returns the number of</span></span><br><span class="line"><span class="comment">// bytes read. It may return the (non-nil) error from the same call</span></span><br><span class="line"><span class="comment">// or return the error (and n == 0) from a subsequent call.</span></span><br><span class="line"><span class="comment">// An instance of this general case is that a Reader returning</span></span><br><span class="line"><span class="comment">// a non-zero number of bytes at the end of the input stream may</span></span><br><span class="line"><span class="comment">// return either err == EOF or err == nil. The next Read should</span></span><br><span class="line"><span class="comment">// return 0, EOF.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Callers should always process the n &gt; 0 bytes returned before</span></span><br><span class="line"><span class="comment">// considering the error err. Doing so correctly handles I/O errors</span></span><br><span class="line"><span class="comment">// that happen after reading some bytes and also both of the</span></span><br><span class="line"><span class="comment">// allowed EOF behaviors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Implementations of Read are discouraged from returning a</span></span><br><span class="line"><span class="comment">// zero byte count with a nil error, except when len(p) == 0.</span></span><br><span class="line"><span class="comment">// Callers should treat a return of 0 and nil as indicating that</span></span><br><span class="line"><span class="comment">// nothing happened; in particular it does not indicate EOF.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Implementations must not retain p.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><ul><li>可以使用strings包下的NewReader创建字符串流<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r := strings.NewReader(<span class="string">"hello 世界"</span>)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, r.Size())<span class="comment">//创建字节切片,存放流中数据,根据流数据大小创建切片大小</span></span><br><span class="line">n, err := r.Read(b)<span class="comment">//把流中数据读取到切片中</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"读取失败,"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"读取数据长度,"</span>, n)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"流中数据"</span>,<span class="keyword">string</span>(b))<span class="comment">//以字符串形式输入切片中数据</span></span><br></pre></td></tr></table></figure></li><li>最常用的是文件流,把外部文件中数据读取到程序中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">"D:/go.txt"</span>)<span class="comment">//打开文件</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件读取失败,"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fileInfo, err := f.Stat()<span class="comment">//获取文件信息</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件信息获取失败,"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, fileInfo.Size())<span class="comment">//根据文件中数据大小创建切片</span></span><br><span class="line">_, err = f.Read(b)<span class="comment">//读取数据到切片中</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件流读取失败:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"文件中内容为:"</span>, <span class="keyword">string</span>(b))<span class="comment">//以字符串形式输入切片中数据</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="输入流-1"><a href="#输入流-1" class="headerlink" title="输入流"></a>输入流</h1><ul><li>输入流就是把程序中数据写出到外部资源</li><li>Go语言标准库中输出流是Writer接口<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write writes len(p) bytes from p to the underlying data stream.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span></span><br><span class="line"><span class="comment">// and any error encountered that caused the write to stop early.</span></span><br><span class="line"><span class="comment">// Write must return a non-nil error if it returns n &lt; len(p).</span></span><br><span class="line"><span class="comment">// Write must not modify the slice data, even temporarily.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Implementations must not retain p.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="代码操作"><a href="#代码操作" class="headerlink" title="代码操作"></a>代码操作</h2><ul><li>注意:输入流时不要使用<code>os.Open()</code>因为这种方式获取的文件是只读的<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">fp := <span class="string">"D:/go.txt"</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第三个参数表示文件权限</span></span><br><span class="line"><span class="comment">第 1 位在权限中总是为 0</span></span><br><span class="line"><span class="comment">第 2 位为 0 表示文件不可以被读， 为 1 表示可以被读</span></span><br><span class="line"><span class="comment">第 3 位为 0 表示文件不可以被写， 为 1 表示可以被写</span></span><br><span class="line"><span class="comment">第 4 位为 0 表示文件不可以被执行， 为 1 表示可以被执行</span></span><br><span class="line"><span class="comment">整理如下:</span></span><br><span class="line"><span class="comment">   0(0000): 不可读写,不能被执行</span></span><br><span class="line"><span class="comment">   1(0001): 不可读写,能被执行</span></span><br><span class="line"><span class="comment">   2(0010): 可写不可读,不能被执行</span></span><br><span class="line"><span class="comment">   3(0011): 可写不可读,能被执行</span></span><br><span class="line"><span class="comment">   4(0100): 可读不可写,不能被执行</span></span><br><span class="line"><span class="comment">   5(0101): 可读不可写,能被执行</span></span><br><span class="line"><span class="comment">   6(0110): 可读写,不能执行</span></span><br><span class="line"><span class="comment">   7(0111): 可读写,可执行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0666:</span></span><br><span class="line"><span class="comment">第一个 0 表示这个数是 八进制</span></span><br><span class="line"><span class="comment">第一个 6 表示文件拥有者有读写权限，但没有执行权限</span></span><br><span class="line"><span class="comment">第二个 6 表示文件拥有者同组用户有读写权限，但没有执行权限</span></span><br><span class="line"><span class="comment">第三个 6 表示其它用户有读写权限，但没有执行权限</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个参数表示文件内容追加</span></span><br><span class="line"><span class="comment">//第三个参数表示创建文件时文件权限</span></span><br><span class="line">f, err := os.OpenFile(fp, os.O_APPEND, <span class="number">0660</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件不存在,创建文件"</span>)</span><br><span class="line">f, _ = os.Create(fp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内容中识别特殊字符</span></span><br><span class="line"><span class="comment">\r\n 换行</span></span><br><span class="line"><span class="comment">\t 缩进</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用文件对象重写的Writer接口,参数是[]byte</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">f.Write([]<span class="keyword">byte</span>(<span class="string">"使用Writer接口写数据\r\n"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用stringWriter接口的方法,参数是字符串,使用更方便</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">f.WriteString(<span class="string">"写了\t一段\r\n内容123"</span>)</span><br><span class="line">fmt.Println(<span class="string">"程序执行结束"</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="ioutil包"><a href="#ioutil包" class="headerlink" title="ioutil包"></a>ioutil包</h1><ul><li>ioutil包下提供了对文件读写的工具函数,通过这些函数快速实现文件的读写操作</li><li>ioutil包下提供的函数比较少,但是都是很方便使用的函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func NopCloser(r io.Reader) io.ReadCloser</span><br><span class="line">func ReadAll(r io.Reader) ([]byte, error)</span><br><span class="line">func ReadFile(filename string) ([]byte, error)</span><br><span class="line">func WriteFile(filename string, data []byte, perm os.FileMode) error</span><br><span class="line">func ReadDir(dirname string) ([]os.FileInfo, error)</span><br><span class="line">func TempDir(dir, prefix string) (name string, err error)</span><br><span class="line">func TempFile(dir, prefix string) (f *os.File, err error)</span><br></pre></td></tr></table></figure><h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2></li><li>打开完文件后可以使用ReadAll把文件中所有内容都读取到<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">"D:/go.txt"</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">b, err := ioutil.ReadAll(f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"文件中内容:\n"</span>, <span class="keyword">string</span>(b))</span><br></pre></td></tr></table></figure></li><li>也可以直接读取文件中内容<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b, err := ioutil.ReadFile(<span class="string">"D:/go.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br></pre></td></tr></table></figure></li><li>写文件也很简单,直接使用WriteFile函数即可,但是源码中已经规定此文件只能是可写状态,且不是尾加数据<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err := ioutil.WriteFile(<span class="string">"D:/abc.txt"</span>, []<span class="keyword">byte</span>(<span class="string">"内容123123"</span>), <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"数据写入成功"</span>)</span><br></pre></td></tr></table></figure></li><li>还提供了快速获取某个文件夹中所有文件信息的函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs,_:=ioutil.ReadDir(<span class="string">"D:/"</span>)</span><br><span class="line"><span class="keyword">for</span> _,n := <span class="keyword">range</span> fs &#123;</span><br><span class="line">fmt.Println(n.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十五：错误异常处理</title>
    <link href="http://www.maishuren.top/posts/goalng/202006201059-index.html"/>
    <id>http://www.maishuren.top/posts/goalng/202006201059-index.html</id>
    <published>2020-06-20T02:59:08.000Z</published>
    <updated>2020-06-20T03:15:28.488Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><ul><li><p>在程序执行过程中出现的不正常情况称为错误</p></li><li><p>Go语言中使用builtin包下error接口作为错误类型,官方源码定义如下</p><ul><li>只包含了一个方法,方法返回值是string,表示错误信息<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Go语言中错误都作为方法/函数的返回值,因为Go语言认为使用其他语言类似try…catch这种方式会影响到程序结构</p></li><li><p>在Go语言标准库的errors包中提供了error接口的实现结构体errorString,并重写了error接口的Error()方法.额外还提供了快速创建错误的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果错误信息由很多变量(小块)组成,可以借助<code>fmt.Errorf(&quot;verb&quot;,...)</code>完成错误信息格式化,因为底层还是errors.New()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Errorf formats according to a format specifier and returns the string</span></span><br><span class="line"><span class="comment">// as a value that satisfies error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(Sprintf(format, a...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h1></li><li><p>使用Go语言标准库创建错误,并返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i, k <span class="keyword">int</span>)</span> <span class="params">(d <span class="keyword">int</span>, e error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> k == <span class="number">0</span> &#123;</span><br><span class="line">e = errors.New(<span class="string">"初始不能为0"</span>)</span><br><span class="line">d=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">d = i / k</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">result,error:=demo(<span class="number">6</span>,<span class="number">0</span>)</span><br><span class="line">fmt.Println(result,error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果错误信息由多个内容组成,可以使用下面实现方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i, k <span class="keyword">int</span>)</span> <span class="params">(d <span class="keyword">int</span>, e error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> k == <span class="number">0</span> &#123;</span><br><span class="line">e = fmt.Errorf(<span class="string">"%s%d和%d"</span>, <span class="string">"除数不能是0,两个参数分别是:"</span>, i, k)</span><br><span class="line">d = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">d = i / k</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">result, error := demo(<span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Println(result, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Go语言中错误处理方式"><a href="#Go语言中错误处理方式" class="headerlink" title="Go语言中错误处理方式"></a>Go语言中错误处理方式</h1></li><li><p>可以忽略错误信息,使用占位符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i, k <span class="keyword">int</span>)</span> <span class="params">(d <span class="keyword">int</span>, e error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> k == <span class="number">0</span> &#123;</span><br><span class="line">e = fmt.Errorf(<span class="string">"%s%d和%d"</span>, <span class="string">"除数不能是0,两个参数分别是:"</span>, i, k)</span><br><span class="line">d = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">d = i / k</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">result, _ := demo(<span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用if处理错误,原则上每个错误都应该解决</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i, k <span class="keyword">int</span>)</span> <span class="params">(d <span class="keyword">int</span>, e error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> k == <span class="number">0</span> &#123;</span><br><span class="line">e = fmt.Errorf(<span class="string">"%s%d和%d"</span>, <span class="string">"除数不能是0,两个参数分别是:"</span>, i, k)</span><br><span class="line">d = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">d = i / k</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">result, error := demo(<span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"发生错误"</span>, error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"程序执行成功,结果为:"</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="defer使用"><a href="#defer使用" class="headerlink" title="defer使用"></a>defer使用</h1><ul><li>Go语言中defer可以完成延迟功能,当前函数执行完成后执行defer功能</li><li>defer最常用的就是关闭连接(数据库连接,文件等)可以打开连接后代码紧跟defer进行关闭,后面在执行其他功能<ul><li>在很多语言中要求必须按照顺序执行,也就是必须把关闭代码写在最后,但是经常会忘记关闭导致内存溢出,而Golang中defer很好的解决了这个问题.无论defer写到哪里都是最后执行<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"打开连接"</span>)</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"关闭连接"</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   fmt.Println(<span class="string">"进行操作"</span>)</span><br><span class="line">   <span class="comment">//输出:打开连接 进行操作 关闭连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="多个defer"><a href="#多个defer" class="headerlink" title="多个defer"></a>多个defer</h1><ul><li><p>多重defer采用栈结构执行,先产生后执行</p></li><li><p>在很多代码结构中都可能出现产生多个对象,而程序希望这些对象倒序关闭,多个defer正好可以解决这个问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"打开连接A"</span>)</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"关闭连接A"</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   fmt.Println(<span class="string">"打开连接B"</span>)</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"关闭连接B"</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   fmt.Println(<span class="string">"进行操作"</span>)</span><br><span class="line">   <span class="comment">//输出:打开连接A 打开连接B 进行操作 关闭连接B 关闭连接A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="defer和return结合"><a href="#defer和return结合" class="headerlink" title="defer和return结合"></a>defer和return结合</h1></li><li><p>defer与return同时存在时,要把return理解成两条执行结合(不是原子指令),一个指令是给返回值赋值,另一个指令返回跳出函数</p></li><li><p>defer和return时整体执行顺序</p><ul><li>先给返回值赋值</li><li>执行defer</li><li>返回跳出函数</li></ul></li><li><p>没有定义返回值接收变量,执行defer时返回值已经赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">i:=<span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">i=i+<span class="number">2</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f())<span class="comment">//输出:0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明接收返回值变量,执行defer时修改了返回值内容.</p><ul><li>由于return后面没有内容,就无法给返回值赋值,所以执行defer时返回值才有内容<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">i=i+<span class="number">2</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f())<span class="comment">//输出:2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h1><ul><li>panic是builtin中函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The panic built-in function stops normal execution of the current</span></span><br><span class="line"><span class="comment">// goroutine. When a function F calls panic, normal execution of F stops</span></span><br><span class="line"><span class="comment">// immediately. Any functions whose execution was deferred by F are run in</span></span><br><span class="line"><span class="comment">// the usual way, and then F returns to its caller. To the caller G, the</span></span><br><span class="line"><span class="comment">// invocation of F then behaves like a call to panic, terminating G's</span></span><br><span class="line"><span class="comment">// execution and running any deferred functions. This continues until all</span></span><br><span class="line"><span class="comment">// functions in the executing goroutine have stopped, in reverse order. At</span></span><br><span class="line"><span class="comment">// that point, the program is terminated and the error condition is reported,</span></span><br><span class="line"><span class="comment">// including the value of the argument to panic. This termination sequence</span></span><br><span class="line"><span class="comment">// is called panicking and can be controlled by the built-in function</span></span><br><span class="line"><span class="comment">// recover.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure></li><li>panic有点类似与其他编程语言的throw,抛出异常.当执行到panic后终止剩余代码执行.并打印错误栈信息<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"1"</span>)</span><br><span class="line">   <span class="built_in">panic</span>(<span class="string">"panic执行了,哈哈"</span>)</span><br><span class="line">   fmt.Println(<span class="string">"2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>执行结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">panic: panic执行了,哈哈</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">D:&#x2F;gowork&#x2F;c&#x2F;main.go:7 +0x80</span><br></pre></td></tr></table></figure></li><li>注意panic不是立即停止程序(os.Exit(0)),defer还是执行的.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"defer执行"</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   fmt.Println(<span class="string">"1"</span>)</span><br><span class="line">   <span class="built_in">panic</span>(<span class="string">"panic执行了,哈哈"</span>)</span><br><span class="line">   fmt.Println(<span class="string">"2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h1><ul><li><p>recover()表示恢复程序的panic(),让程序正常运行</p></li><li><p>recover()是和panic(v)一样都是builtin中函数,可以接收panic的信息,恢复程序的正常运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The recover built-in function allows a program to manage behavior of a</span></span><br><span class="line"><span class="comment">// panicking goroutine. Executing a call to recover inside a deferred</span></span><br><span class="line"><span class="comment">// function (but not any function called by it) stops the panicking sequence</span></span><br><span class="line"><span class="comment">// by restoring normal execution and retrieves the error value passed to the</span></span><br><span class="line"><span class="comment">// call of panic. If recover is called outside the deferred function it will</span></span><br><span class="line"><span class="comment">// not stop a panicking sequence. In this case, or when the goroutine is not</span></span><br><span class="line"><span class="comment">// panicking, or if the argument supplied to panic was nil, recover returns</span></span><br><span class="line"><span class="comment">// nil. Thus the return value from recover reports whether the goroutine is</span></span><br><span class="line"><span class="comment">// panicking.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>recover()一般用在defer内部,如果没有panic信息返回nil,如果有panic,recover会把panic状态取消</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> error:=<span class="built_in">recover</span>();error!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"出现了panic,使用reover获取信息:"</span>,error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">"11111111111"</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"出现panic"</span>)</span><br><span class="line">fmt.Println(<span class="string">"22222222222"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11111111111</span><br><span class="line">出现了panic,使用reover获取信息: 出现panic</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数调用过程中panic和recover"><a href="#函数调用过程中panic和recover" class="headerlink" title="函数调用过程中panic和recover()"></a>函数调用过程中panic和recover()</h1><ul><li>recover()只能恢复当前函数级或当前函数调用函数中的panic(),恢复后调用当前级别函数结束,但是调用此函数的函数可以继续执行.</li><li>panic会一直向上传递,如果没有recover()则表示终止程序,但是碰见了recover(),recover()所在级别函数表示没有panic,panic就不会向上传递<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"demo1上半部分"</span>)</span><br><span class="line">demo2()</span><br><span class="line">fmt.Println(<span class="string">"demo1下半部分"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>()<span class="comment">//此处进行恢复</span></span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">"demo2上半部分"</span>)</span><br><span class="line">demo3()</span><br><span class="line">fmt.Println(<span class="string">"demo2下半部分"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo3</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"demo3上半部分"</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"在demo3出现了panic"</span>)</span><br><span class="line">fmt.Println(<span class="string">"demo3下半部分"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"程序开始"</span>)</span><br><span class="line">demo1()</span><br><span class="line">fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang，入门" scheme="http://www.maishuren.top/tags/golang%EF%BC%8C%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>nginx实践：静态资源Web服务、代理服务、负载均衡调度器SLB和动态缓存</title>
    <link href="http://www.maishuren.top/posts/nginx/202006191422-index.html"/>
    <id>http://www.maishuren.top/posts/nginx/202006191422-index.html</id>
    <published>2020-06-19T06:22:02.000Z</published>
    <updated>2020-06-19T08:51:13.945Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="静态资源服务"><a href="#静态资源服务" class="headerlink" title="静态资源服务"></a>静态资源服务</h1><h2 id="核心配置和文件压缩"><a href="#核心配置和文件压缩" class="headerlink" title="核心配置和文件压缩"></a>核心配置和文件压缩</h2><ol><li><p>配置语法：文件读取</p><p>配置：sendfile on | off。默认：sendfile off。作用域：http, server, location，if in location</p><p>sendfile 是一种高效传输文件的模式。sendfile设置为on表示启动高效传输文件的模式。sendfile可以让Nginx在传输文件时直接在磁盘和tcp socket之间传输数据。如果这个参数不开启，会先在用户空间（Nginx进程空间）申请一个buffer，用read函数把数据从磁盘读到cache，再从cache读取到用户空间的buffer，再用write函数把数据从用户空间的buffer写入到内核的buffer，最后到tcp socket。开启这个参数后可以让数据不用经过用户buffer。</p></li><li><p>配置语法：tcp_nopush</p><p>配置：tcp_nopush on | off</p><p>默认：tcp_nopush off</p><p>作用域：http, server, location</p><p>tcp_nopush是在sendfile开启的情况下，提高网络包的传输效率。tcp_nopush指令，在连接套接字时启用Linux系统下的TCP_CORK。该选项告诉TCP堆栈附加数据包，并在它们已满或当应用程序通过显式删除TCP_CORK指示发送数据包时发送它们。 这使得发送的数据分组是最优量，并且因此提高了网络数据包的传输效率。<br>也就是说 tcp_nopush=on 时，结果就是数据包不会马上传送出去，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞，虽然有一点点延迟。</p></li><li><p>配置语法：tcp_nodelay</p><p>配置：tcp_nodelay on | off;</p><p>默认： tcp_nodelay on;</p><p>作用域：http, server, location</p><p>tcp_nodelay是在 keepalive 连接下，提高网络数据包的传输实时性。tcp_nodelay选项和tcp_nopush正好相反，数据包不等待，实时发送给用户。</p></li><li><p>配置语法：gzip压缩</p><p>压缩传输，提高传输效率。开启压缩，可以加快资源响应速度节省网络带宽资源</p><p>gizp配置语法：</p><p>​    配置：gzip on | off;</p><p>​    默认：gzip off;</p><p>​    作用域：http, server, location, if in location</p><p>配置压缩比：压缩等级配置（压缩等级越高，越消耗服务器资源）</p><p>​    配置：gzip_comp_level level;</p><p>​    默认：gzip_comp_level 1;</p><p>​    作用域： http, server, location</p><p>gzip协议版本配置：</p><p>​    配置：gzip_http_version 1.0 | 1.1;</p><p>​    默认：gzip_http_version 1.1;</p><p>​    作用域：http, server, location;</p><p>压缩扩展模块：预读gzip功能 ngx_http_gzip_static_module</p><p>​    配置： gzip_static on | off | always;</p><p>​    默认：gzip_static off;</p><p>​    作用域：http, server, location</p><p> gunzip的压缩方式 ngx_http_gunzip_module</p><p>​    配置：gunzip on | off;</p><p>​    默认：gunzip off;</p><p>​    作用域：http, server, location</p><p>​    </p><p>​    配置：gunzip_buffers number size;</p><p>​    默认：gunzip_buffers 32 4k|16 8k;</p><p>​    作用域：http, server, location;</p></li></ol><h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><p>配置图片压缩，在/opt/work/code/images目录下准备一张图片，第一次请求先关闭gzip，禁止Chrome缓存，打开开发者工具，然后请求图片，在network里查看图片的size。开启gzip，再次请求该图片，会发现图片被压缩变小了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(jpg|gif|png)$ &#123;</span><br><span class="line">            gzip on;</span><br><span class="line">            gzip_http_version 1.1;</span><br><span class="line">            gzip_comp_level 2;</span><br><span class="line">            gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">            root  /opt/work/code/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于txt，html等文件，与上述同理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(txt|xml)$ &#123;</span><br><span class="line">            gzip on;</span><br><span class="line">            gzip_http_version 1.1;</span><br><span class="line">            gzip_comp_level 1;</span><br><span class="line">            gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">            root  /opt/work/code/doc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置访问压缩的静态资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^&#x2F;download &#123;</span><br><span class="line">            gzip_static on;</span><br><span class="line">            tcp_nopush on;</span><br><span class="line">            root &#x2F;opt&#x2F;work&#x2F;code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/nginx/browser_cache.jpg" alt=""></p><p>过期检验机制</p><ol><li>检验是否过期：Expires、Cache-Controller(max-age)</li><li>协议中的Etag头信息校验：Etag</li><li>Last-Modified头信息校验：Last-Modified</li></ol><h3 id="expires配置"><a href="#expires配置" class="headerlink" title="expires配置"></a>expires配置</h3><p>配置：expires time</p><p>默认：expires off</p><p>作用域：http，server，location，if in lacation</p><h3 id="配置示例-1"><a href="#配置示例-1" class="headerlink" title="配置示例"></a>配置示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(txt|xml)$ &#123;</span><br><span class="line">expires 24h;</span><br><span class="line">root /opt/work/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于txt、html文件设置过期时间24小时。配置好之后再去访问这些配置了expires的文件，通过浏览器的开发工具观看，可以看到，第一次请求status是200，再次请求status就变成了304，说明读取了缓存。响应头就会出现如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age&#x3D;86400</span><br><span class="line">TETag: &quot;5ee9b0ef-12d&quot;</span><br><span class="line">Expires: Sat, 20 Jun 2020 08:11:21 GMT</span><br><span class="line">Last-Modified: Wed, 17 Jun 2020 05:58:07 GMT</span><br></pre></td></tr></table></figure><h2 id="跨域访问处理"><a href="#跨域访问处理" class="headerlink" title="跨域访问处理"></a>跨域访问处理</h2><p>通过add_header可以在响应头中添加Access-Controller-Allow-Origin头信息来允许客户端实现跨域访问。</p><h3 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h3><p>配置：add_header name value;</p><p>作用域：http，server，location，if in location;</p><h3 id="配置示例-2"><a href="#配置示例-2" class="headerlink" title="配置示例"></a>配置示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line"><span class="meta">#</span><span class="bash">允许跨域访问所有的域名，也可以指定域名如：http://www.baidu.com</span></span><br><span class="line">add_header Access-Controller-Allow-Origin *;</span><br><span class="line"><span class="meta">#</span><span class="bash">允许这些方法进行跨域访问</span></span><br><span class="line">add_header Access-Controller-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;</span><br><span class="line">root /opt/work/html;</span><br><span class="line">index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于跨域访问，也可以通过服务端的代码来实现，例如Java，golang等服务端语言都可以实现。</p><h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><p>防盗链可以防止网站的资源被盗用。nginx可以实现简单的防盗链功能。</p><h3 id="基于http-refer防盗链配置模块"><a href="#基于http-refer防盗链配置模块" class="headerlink" title="基于http_refer防盗链配置模块"></a>基于http_refer防盗链配置模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(txt|xml)$ &#123;</span><br><span class="line">valid_referers none blocked *.maishuren.top maishuren.top server_names ~\.google\. ~\.baidu\.;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">    return 403;</span><br><span class="line">    &#125;</span><br><span class="line">gzip on;</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line">gzip_comp_level 1;</span><br><span class="line">gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">root  html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本章介绍nginx在静态资源、代理服务、负载均衡和动态缓存的使用
    
    </summary>
    
    
      <category term="运维" scheme="http://www.maishuren.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="nginx" scheme="http://www.maishuren.top/tags/nginx/"/>
    
      <category term="实践" scheme="http://www.maishuren.top/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十四：golang中的面向对象</title>
    <link href="http://www.maishuren.top/posts/golang/202006182355-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006182355-index.html</id>
    <published>2020-06-18T15:55:09.000Z</published>
    <updated>2020-06-20T02:52:53.635Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Go语言中的面向对象"><a href="#Go语言中的面向对象" class="headerlink" title="Go语言中的面向对象"></a>Go语言中的面向对象</h1><ul><li><p>面向对象是一种思想,到目前为止还没有一个非常明确的定义,老程序员在不同时期对面向对象的理解是不同的.Go语言中对面向对象有着自己的理解</p><blockquote><p>Although there is no universally accepted definition of object-oriented programming, for our purposes, an object is simply a value or variable that has methods , and a method is a function assiociated with a particular type.</p></blockquote></li><li><p>通过上面解释看出了Go语言开发者认为:面向对象就是特定类型(结构体)有这自己的方法,利用这个方法完成面向对象编程,并没有提封装、继承、多态.所有Go语言进行面向对象编程时,重点在于灵活使用方法.Go语言通过这样的设计降低了语言学习的压力.</p></li><li><p>Go语言有着自己对面向对象的理解,他也有着自己的封装、继承、多态</p></li></ul><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ul><li>封装主要体现在两个方面:封装数据、封装业务</li><li>Go语言中通过首字母大小控制访问权限.属性首字母小写对外提供访问方法是封装数据最常见的实现方式</li><li>可以通过方法封装业务<ul><li>提出方法是封装</li><li>控制结构体属性访问,对外提供访问方法也是封装</li></ul></li><li>在面向对象中封装的好处:<ul><li>安全性.结构体属性访问受到限制,必须按照特定访问渠道</li><li>可复用性,封装的方法实现可复用性</li><li>可读写,多段增加代码可读性</li></ul></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li>Go语言同包任意位置可以访问全局内容,封装控制可以控制包外访问结构体中数据<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span> <span class="comment">//姓名</span></span><br><span class="line">age  <span class="keyword">int</span>    <span class="comment">//体重.单位斤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">p.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">SetAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">p.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>封装业务就是根据自己的需求提取代码,使用Go语言标准库中的函数过程就属性封装业务(代码)</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>按照传统面向对象思想,继承就是把同一类事物提出共同点为父类,让子类可以复用父类的可访问性内容.</li><li>继承有多种实现方式<ul><li>通过关键字继承,强耦合实现方式</li><li>组合式继承,松耦合继承方式</li></ul></li><li>使用过Java或C#的应该知道尽量少用继承而是使用组合代替继承,可以使用高内聚,低耦合.Java之父之前在一次采访的时候也说过,如果给他一次机会重新做Java,他最希望修改的地方就是继承</li><li>Go语言中的继承是通过组合实现</li></ul><h2 id="匿名属性"><a href="#匿名属性" class="headerlink" title="匿名属性"></a>匿名属性</h2><ul><li>在Go语言中支持匿名属性(结构体中属性名字),但是每个最多只能存在匿名属性.编译器认为类型就是属性名,我们在使用时就把类型当作属性名进行使用<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p:=People&#123;<span class="string">"msr"</span>,<span class="number">22</span>&#125;</span><br><span class="line">fmt.Println(p.<span class="keyword">string</span>,p.<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结构体之间的关系"><a href="#结构体之间的关系" class="headerlink" title="结构体之间的关系"></a>结构体之间的关系</h2><ul><li>传统面向对象中类与类之间的关系<ul><li>继承:is-a,强耦合性,一般认为类与类之间具有强关系</li><li>实现:like-a,接口和实现类之间的关系</li><li>依赖:use-a,具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A,一般作为方法参数</li><li>关联:has-a一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的</li><li>聚合:has-a,整体与部分、拥有的关系</li><li>组合:contains-a,他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束</li><li>组合&gt;聚合&gt;关联&gt;依赖</li></ul></li><li>Go语言中标准的组合关系<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">peo       People</span><br><span class="line">classroom <span class="keyword">string</span> <span class="comment">//班级</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">teacher := Teacher&#123;People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;, <span class="string">"302教室"</span>&#125;</span><br><span class="line"><span class="comment">//必须通过包含的变量名调用另一个结构体中内容</span></span><br><span class="line">fmt.Println(teacher.classroom, teacher.peo.age, teacher.peo.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用匿名属性完成Go语言中的继承"><a href="#使用匿名属性完成Go语言中的继承" class="headerlink" title="使用匿名属性完成Go语言中的继承"></a>使用匿名属性完成Go语言中的继承</h2><ul><li>Go语言中的继承很好实现,把另一个结构体类型当作另一个结构体的属性,可以直接调用另一个结构体中的内容</li><li>因为Go语言中结构体不能相互转换,所以不能把子结构体变量赋值给父结构体变量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">People</span><br><span class="line">classroom <span class="keyword">string</span> <span class="comment">//班级</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">teacher := Teacher&#123;People&#123;<span class="string">"msr"</span>, <span class="number">22</span>&#125;, <span class="string">"302教室"</span>&#125;</span><br><span class="line">fmt.Println(teacher.classroom, teacher.age, teacher.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li><p>接口解释:接口是一组行为规范的定义.</p></li><li><p>接口中只能有方法声明,方法只能有名称、参数、返回值,不能有方法体</p></li><li><p>每个接口中可以有多个方法声明,结构体把接口中 <strong>所有</strong> 方法都重写后,结构体就属于接口类型</p></li><li><p>Go语言中接口和结构体之间的关系是传统面向对象中is-like-a的关系</p></li><li><p>定义接口类型关键字是interface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>&#123;</span><br><span class="line">  方法名(参数列表) 返回值列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口可以继承接口,且Go语言推荐把接口中方法拆分成多个接口</p></li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li>接口中声明完方法,结构体重写接口中方法后,编译器认为结构体实现了接口<ul><li>重写的方法要求必须和接口中方法名称、方法参数(参数名称可以不同)、返回值列表完全相同<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Live <span class="keyword">interface</span> &#123;</span><br><span class="line">run(run <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">run</span><span class="params">(run <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(p.name, <span class="string">"正在跑步,跑了,"</span>, run, <span class="string">"米"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">peo := People&#123;<span class="string">"张三"</span>, <span class="number">17</span>&#125;</span><br><span class="line">peo.run(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>如果接口中有多个方法声明,接口体必须重写接口中全部方法才任务结构体实现了接口<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Live <span class="keyword">interface</span> &#123;</span><br><span class="line">run(run <span class="keyword">int</span>)</span><br><span class="line">eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">run</span><span class="params">(run <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(p.name, <span class="string">"正在跑步,跑了,"</span>, run, <span class="string">"米"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(p.name, <span class="string">"正在吃饭"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">peo := People&#123;<span class="string">"张三"</span>, <span class="number">17</span>&#125;</span><br><span class="line">peo.run(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>接口可以继承接口(组合),上面代码可以改写成下面代码</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Live <span class="keyword">interface</span> &#123;</span><br><span class="line">run(run <span class="keyword">int</span>)</span><br><span class="line">Eat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Eat <span class="keyword">interface</span> &#123;</span><br><span class="line">eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">run</span><span class="params">(run <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(p.name, <span class="string">"正在跑步,跑了,"</span>, run, <span class="string">"米"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(p.name, <span class="string">"正在吃饭"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">peo := People&#123;<span class="string">"张三"</span>, <span class="number">17</span>&#125;</span><br><span class="line">peo.run(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul><li>多态:同一件事情由于条件不同产生的结果不同</li><li>由于Go语言中结构体不能相互转换,所以没有结构体(父子结构体)的多态,只有基于接口的多态.这也符合Go语言对面向对象的诠释</li><li>多态在代码层面最常见的一种方式是接口当作方法参数</li></ul><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li><p>结构体实现了接口的全部方法,就认为结构体属于接口类型,这是可以把结构体变量赋值给接口变量</p></li><li><p>重写接口时接收者为<code>Type</code>和<code>*Type</code>的区别</p><ul><li><code>*Type</code>可以调用<code>*Type</code>和<code>Type</code>作为接收者的方法.所以只要接口中多个方法中至少出现一个使用<code>*Type</code>作为接收者进行重写的方法,就必须把结构体指针赋值给接口变量,否则编译报错</li><li><code>Type</code>只能调用<code>Type</code>作为接收者的方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Live <span class="keyword">interface</span> &#123;</span><br><span class="line">run()</span><br><span class="line">eat()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(p.name, <span class="string">"正在跑步"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p People)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(p.name, <span class="string">"在吃饭"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//重写接口时</span></span><br><span class="line"><span class="keyword">var</span> run Live = &amp;People&#123;<span class="string">"张三"</span>&#125;</span><br><span class="line">run.run()</span><br><span class="line">run.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>既然接口可以接收实现接口所有方法的结构体变量,接口也就可以作为方法(函数)参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Live <span class="keyword">interface</span> &#123;</span><br><span class="line">run()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Animate <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"人在跑"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animate)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"动物在跑"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sport</span><span class="params">(live Live)</span></span> &#123;</span><br><span class="line">fmt.Println(live.run)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">peo := &amp;People&#123;&#125;</span><br><span class="line">peo.run() <span class="comment">//输出:人在跑</span></span><br><span class="line">ani := &amp;Animate&#123;&#125;</span><br><span class="line">ani.run() <span class="comment">//输出:动物在跑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><ul><li><p>只要实现了接口的全部方法认为这个类型属于接口类型,如果编写一个接口,这个接口中没有任何方法,这时认为所有类型都实现了这个接口.所以Go语言中<code>interface{}</code>代表任意类型</p></li><li><p>如果<code>interface{}</code>作为方法参数就可以接收任意类型,但是在程序中有时有需要知道这个参数到底是什么类型,这个时候就需要使用断言</p></li><li><p>断言使用时使用interface{}变量点括号,括号中判断是否属于的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">i.(Type)</span><br></pre></td></tr></table></figure></li><li><p>断言的两大作用:</p><ul><li>判断是否是指定类型</li><li>把interface{}转换为特定类型<h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2></li></ul></li><li><p>断言可以有一个返回值,如果判断结果是指定类型返回变量值,如果不是指定类型报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">result:=i.(<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数是456时,程序运行正常,输出:</span></span><br><span class="line"><span class="comment">456</span></span><br><span class="line"><span class="comment">参数是false时报错：</span></span><br><span class="line"><span class="comment">panic: interface conversion: interface &#123;&#125; is bool, not int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">demo(<span class="number">456</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>断言也可以有两个返回值,这时无论是否是指定类型都不报错.</p><ul><li>第一个参数:<ul><li>如果正确:返回值变量值</li><li>如果错误:返回判断类型的默认值</li></ul></li><li>第二个参数:<ul><li>返回值为bool类型,true表示正确,false表示错误<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">result, ok := i.(<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(result, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数是456时,程序运行正常,输出:</span></span><br><span class="line"><span class="comment">456true</span></span><br><span class="line"><span class="comment">参数是字符串"abc"时程序运行正常,输出:</span></span><br><span class="line"><span class="comment">0 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">demo(<span class="string">"abc"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十三：结构体</title>
    <link href="http://www.maishuren.top/posts/golang/202006182349-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006182349-index.html</id>
    <published>2020-06-18T15:49:04.000Z</published>
    <updated>2020-06-18T15:54:22.418Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ul><li>结构体解释:将一个或多个变量组合到一起,形成新的类型.这个类型就是结构体</li><li>Go语言中的结构体和C++结构体有点类似,而Java或C#中类本质就是结构体</li><li>结构体是值类型</li><li>结构体定义语法<ul><li>通过语法可以看出,Go语言发明者明确认为结构体就是一种自定义类型<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名称 <span class="keyword">struct</span>&#123;</span><br><span class="line">  名称 类型<span class="comment">//成员或属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li><p>定义结构体</p><ul><li>结构体可以定义在函数内部或函数外部(与普通变量一样),定义位置影响到结构体的访问范围</li><li>如果结构体定义在函数外面,结构体名称首字母是否大写影响到结构体是否能跨包访问</li><li>如果结构体能跨包访问,属性首字母是否大写影响到属性是否跨包访问<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>声明结构体变量</p><ul><li>由于结构体是值类型,所以声明后就会开辟内存空间</li><li>所有成员为类型对应的初始值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peo People</span><br><span class="line">fmt.Print(peo)<span class="comment">//输出:&#123;0 &#125;</span></span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>,&amp;peo)<span class="comment">//会打印内存地址值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>可以直接给结构体多个属性赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peo People</span><br><span class="line"><span class="comment">//按照结构体中属性的顺序进行赋值,可以省略属性名称</span></span><br><span class="line">peo = People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line">fmt.Println(peo)</span><br><span class="line"><span class="comment">//明确指定给哪些属性赋值.可以都赋值,也可以只给其中一部分赋值</span></span><br><span class="line">peo = People&#123;Age: <span class="number">18</span>, Name: <span class="string">"maishuren"</span>&#125;</span><br><span class="line">fmt.Println(peo)</span><br></pre></td></tr></table></figure></li><li><p>也可以通过结构体变量名称获取到属性进行赋值或查看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peo People</span><br><span class="line">peo.Name=<span class="string">"msr"</span></span><br><span class="line">peo.Age=<span class="number">17</span></span><br><span class="line">fmt.Println(peo)</span><br><span class="line">fmt.Println(peo.Name)</span><br><span class="line">fmt.Println(peo.Age)</span><br></pre></td></tr></table></figure><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2></li><li><p>双等(==)判断结构体中内容是否相等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p1 := People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line">p2 := People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>, &amp;p1, &amp;p2) <span class="comment">//输出地址不同</span></span><br><span class="line">fmt.Println(p1 == p2)           <span class="comment">//输出:true</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h1><ul><li>由于结构体是值类型,在方法传递时希望传递结构体地址,可以使用时结构体指针完成</li><li>可以结合new(T)函数创建结构体指针<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">peo := <span class="built_in">new</span>(People)</span><br><span class="line"><span class="comment">//因为结构体本质是值类型,所以创建结构体指针时已经开辟了内存空间</span></span><br><span class="line">fmt.Println(peo == <span class="literal">nil</span>) <span class="comment">//输出:false</span></span><br><span class="line"><span class="comment">//由于结构体中属性并不是指针类型,所以可以直接调用</span></span><br><span class="line">peo.Name = <span class="string">"msr"</span></span><br><span class="line">fmt.Println(peo)<span class="comment">//输出:&amp;&#123;msr 0&#125;</span></span><br><span class="line">peo1:=peo</span><br><span class="line">peo1.Name=<span class="string">"maishuren"</span></span><br><span class="line">fmt.Println(peo1,peo)<span class="comment">//输出:&amp;&#123;maishuren 0&#125; &amp;&#123;maishuren 0&#125;</span></span><br></pre></td></tr></table></figure></li><li>如果不想使用new(T)函数,可以直接声明结构体指针并赋值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明结构体指针</span></span><br><span class="line"><span class="keyword">var</span> peo *People</span><br><span class="line"><span class="comment">//给结构体指针赋值</span></span><br><span class="line">peo = &amp;People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码使用短变量方式如下</span></span><br><span class="line"><span class="comment">peo:= &amp;People&#123;"msr", 17&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fmt.Println(peo)</span><br></pre></td></tr></table></figure><h2 id="判断-1"><a href="#判断-1" class="headerlink" title="判断"></a>判断</h2></li><li>结构体指针比较的是地址</li><li>(*结构体指针)取出地址中对应的值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p1 := People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line">p2 := People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>, &amp;p1, &amp;p2) <span class="comment">//输出地址不同</span></span><br><span class="line">fmt.Println(p1 == p2)           <span class="comment">//输出:true</span></span><br><span class="line"></span><br><span class="line">p3 := <span class="built_in">new</span>(People)</span><br><span class="line">p3 = &amp;People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line"><span class="comment">//结构体变量不能和指针比较,使用*指针取出地址中值</span></span><br><span class="line">fmt.Println(p1 == *p3) <span class="comment">//输出:true</span></span><br><span class="line"></span><br><span class="line">p4 := &amp;People&#123;<span class="string">"msr"</span>, <span class="number">17</span>&#125;</span><br><span class="line"><span class="comment">//指针比较的是地址</span></span><br><span class="line">fmt.Println(p3 == p4) <span class="comment">//输出:false</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul><li><p>方法和函数语法比较像,区别是函数属于包,通过包调用函数,而方法属于结构体,通过结构体变量调用</p></li><li><p>默认是函数,隶属于包,所以需要添加标识.告诉编译器这个方法属性哪个结构体</p><ul><li>调用方法时就把调用者赋值给接收者(下面的变量名就是接受者)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(变量名 结构体类型)</span> 方法名<span class="params">(参数列表)</span> 返回值列表</span>&#123;</span><br><span class="line">  <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Go语言中已经有函数了,又添加了对方法的支持主要是保证Go语言是面向对象的.Go语言官方对面向对象的解释</p><ul><li>翻译如下:虽然面向对象没有统一的定义，但是对于我们来说对象仅仅是一个有着方法的值或变量,而方法就是一个属于特定类型的函数</li></ul><p><img src="images/2_7_3_method.png" alt=""></p></li><li><p>从上面的解释可以看出,官方给出可明确说明,方法类似于函数.方法归属于特定类型</p></li></ul><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li>定义一个People类型结构体,在对People结构体定义个run()方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span><span class="comment">//姓名</span></span><br><span class="line">Weight<span class="keyword">float64</span><span class="comment">//体重.单位斤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p People)</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(p.Name,<span class="string">"正在跑步"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">peo:=People&#123;<span class="string">"张三"</span>,<span class="number">17</span>&#125;</span><br><span class="line">peo.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果设定需求,在每次跑步后体重都减少0.1斤.上面代码就需要修改了.因为结构体是值类型,修改方法中结构体变量p的值,主函数中peo的值不会改变,因为传递的是值副本.所以修改方法中结构体类型为结构体指针类型就可以完成设定需求<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span><span class="comment">//姓名</span></span><br><span class="line">Weight<span class="keyword">float64</span><span class="comment">//体重.单位斤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(p.Name,<span class="string">"正在跑步,体重为:"</span>,p.Weight)<span class="comment">//输出:张三 正在跑步,体重为: 17</span></span><br><span class="line">p.Weight-=<span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">peo:=&amp;People&#123;<span class="string">"张三"</span>,<span class="number">17</span>&#125;</span><br><span class="line">peo.run()</span><br><span class="line">fmt.Println(peo.Name,<span class="string">"跑完步后的体重是"</span>,peo.Weight)<span class="comment">//输出:张三 跑完步后的体重是 16.9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十二：值传递和引用传递</title>
    <link href="http://www.maishuren.top/posts/gloang/202006182347-index.html"/>
    <id>http://www.maishuren.top/posts/gloang/202006182347-index.html</id>
    <published>2020-06-18T15:47:22.000Z</published>
    <updated>2020-06-18T15:48:11.732Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>讨论值传递和引用传递时,其实就是看值类型变量和引用类型变量作为函数参数时,修改形参是否会影响到实参</li><li>在Go语言中五个引用类型变量,其他都是值类型<ul><li>slice</li><li>map</li><li>channel</li><li>interface</li><li>func()</li></ul></li><li>引用类型作为参数时,称为浅拷贝,形参改变,实参数跟随变化.因为传递的是地址,形参和实参都指向同一块地址</li><li>值类型作为参数时,称为深拷贝,形参改变,实参不变,因为传递的是值的副本,形参会新开辟一块空间,与实参指向不同</li><li>如果希望值类型数据在修改形参时实参跟随变化,可以把参数设置为指针类型</li></ul><h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><ul><li>值类型作为参数代码演示<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i <span class="keyword">int</span>, s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">s = <span class="string">"改变"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">s := <span class="string">"原值"</span></span><br><span class="line">demo(i, s)</span><br><span class="line">fmt.Println(i, s) <span class="comment">//输出:1 原值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>引用传递代码示例<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(arg []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   arg[<span class="built_in">len</span>(arg)<span class="number">-1</span>] = <span class="number">110</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">   demo(s)</span><br><span class="line">   fmt.Println(s) <span class="comment">//输出:[1 2 110]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果希望值类型实参跟随形参变化,可以把值类型指针作为参数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//行参指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i *<span class="keyword">int</span>, s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="comment">//需要在变量前面带有*表示指针变量</span></span><br><span class="line">   *i = <span class="number">5</span></span><br><span class="line">   s = <span class="string">"改变"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   i := <span class="number">1</span></span><br><span class="line">   s := <span class="string">"原值"</span></span><br><span class="line">   <span class="comment">//注意此处第一个参数是i的地址,前面&amp;</span></span><br><span class="line">   <span class="comment">//s保留为值类型</span></span><br><span class="line">   demo(&amp;i, s)</span><br><span class="line">   fmt.Println(i, s) <span class="comment">//输出:5 原值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十一：包的访问权限、变量作用域、闭包</title>
    <link href="http://www.maishuren.top/posts/golang/202006182343-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006182343-index.html</id>
    <published>2020-06-18T15:43:23.000Z</published>
    <updated>2020-06-18T15:46:48.644Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="包概述"><a href="#包概述" class="headerlink" title="包概述"></a>包概述</h1><ul><li>包(package)是Go语言中组织单元.包是逻辑上的分组.而物理上的分组是不同的文件夹,文件夹和包一般是对应的</li><li>把多个文件放入同一个文件夹中,这些文件就是在同一个包中.</li><li>虽然允许源码文件的package和文件夹名不同但是最终编译后都会把文件的package编译成文件夹名称.所以为防止错误最好把文件的package和文件夹名称设置成相同的</li><li>一个Go语言项目必须要有main包,其他自定义名称的包个数任意,根据自己的需求即可.</li><li>Go语言在寻找包时会从GOPATH/src 路径中寻找包,如果不存在去GOROOT/src(Go语言标准库源码所在文件夹)下找</li><li>不同包下资源可以相互访问,在导入其他包后,可以访问包下首字母大写的内容</li><li>同包下不同文件中全局资源可以随意访问</li></ul><h1 id="自定义包"><a href="#自定义包" class="headerlink" title="自定义包"></a>自定义包</h1><ul><li>新建项目后在项目下新建src文件夹,在src文件夹中新建demo文件</li><li>在demo文件中新建demo1.go和demo2.go文件</li><li>demo1.go文件源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo<span class="comment">//包为demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"执行demo1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>demo2.go文件源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo<span class="comment">//包为demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo2</span><span class="params">()</span></span>  &#123;<span class="comment">//函数名大写才能被其他包访问</span></span><br><span class="line">fmt.Println(<span class="string">"执行demo2"</span>)</span><br><span class="line">demo1()<span class="comment">//同包下内容任意访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在项目根目录下新建main.go,源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"demo"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">demo.Demo2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行整个项目后,发现可以正常调用Demo2()函数</li><li>整个程序目录结构如下<br><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/project.png" alt=""></li></ul><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><ul><li>变量声明位置决定了变量的可访问范围(哪里能调用到变量)</li><li>Go语言中变量的有效范围如下<ul><li>函数级别:变量声明在函数内部,只有在函数内部才能访问,称变量为局部变量</li><li>package 包级别,在当前包下都可以访问.称变量为全局变量.变量声明在函数外面</li><li>应用级别,在整个应用下任何包内都可以访问.通过首字母大小写控制</li></ul></li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ul><li>局部变量一定是在函数内部</li><li>在哪个{}内部声明,只能在哪个{}内部访问<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">2</span> <span class="comment">//从此处开始到test1结束&#125;任何位置都能调用i</span></span><br><span class="line"><span class="keyword">if</span> i&gt;=<span class="number">2</span>&#123;</span><br><span class="line">j:=<span class="number">3</span></span><br><span class="line">fmt.Println(i+j)<span class="comment">//此处可以访问i</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="comment">//fmt.Println(j)//此处不能调用j,超出声明j时&#123;&#125;外</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(i) <span class="comment">//此处无法调用test1()中的i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2></li><li>全局变量声明到函数外部,整个包都可以访问</li><li>如果全局变量首字母大写,跨包也可以访问.</li><li>声明全局变量时规范是<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">变量名</span><br><span class="line">变量名=值</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>全局变量代码示例<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name = <span class="string">"smallming"</span></span><br><span class="line">age  = <span class="number">17</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"名字:"</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"年龄:"</span>,age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="闭包概述"><a href="#闭包概述" class="headerlink" title="闭包概述"></a>闭包概述</h1><ul><li>闭包不是Go语言独有的概念,在很多编程语言中都有闭包</li><li>闭包就是解决局部变量不能被外部访问一种解决方案</li><li>是把函数当作返回值的一种应用</li></ul><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><ul><li>总体思想为:在函数内部定义局部变量,把另一个函数当作返回值,局部变量对于返回值函数就相当于全局变量,所以多次调用返回值函数局部变量的值跟随变化<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//res其实就是test1返回值函数,和之前匿名函数变量一个道理</span></span><br><span class="line">res := test1()</span><br><span class="line">fmt.Println(res()) <span class="comment">//输出2</span></span><br><span class="line">fmt.Println(res()) <span class="comment">//输出3</span></span><br><span class="line">fmt.Println(res()) <span class="comment">//输出4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意此处,返回值类型是func int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果重新调用test1()会重新声明及赋值局部变量i<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := test1()</span><br><span class="line">fmt.Println(<span class="string">"f的地址"</span>, f) <span class="comment">//输出匿名函数地址</span></span><br><span class="line">fmt.Println(<span class="string">"f:"</span>, f()) <span class="comment">//调用匿名函数输出2</span></span><br><span class="line">fmt.Println(<span class="string">"f:"</span>, f()) <span class="comment">//调用匿名函数输出3</span></span><br><span class="line">k := test1()</span><br><span class="line">fmt.Println(<span class="string">"k的地址"</span>, k) <span class="comment">//输出匿名函数地址,与f相等</span></span><br><span class="line">fmt.Println(<span class="string">"k:"</span>, k()) <span class="comment">//调用匿名函数输出2</span></span><br><span class="line">fmt.Println(<span class="string">"f:"</span>, f()) <span class="comment">//输出:4</span></span><br><span class="line">fmt.Println(<span class="string">"k:"</span>, k()) <span class="comment">//输出:3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i++</span><br><span class="line"><span class="comment">// 每调用一次test1()输出的地址不一样</span></span><br><span class="line">fmt.Println(<span class="string">"i的地址:"</span>, &amp;i)</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习十：函数</title>
    <link href="http://www.maishuren.top/posts/golang/202006182334-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006182334-index.html</id>
    <published>2020-06-18T15:34:22.000Z</published>
    <updated>2020-06-18T15:42:38.878Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>函数:一段代码块</li><li>所有的流程控制代码和业务代码都只能写在函数内部</li><li>为什么使用函数:<ul><li>把一个功能提出作为一个函数便于后期维护,结构清晰</li></ul></li><li>函数声明的语法<ul><li>函数声明后不会执行,必须调用后才会执行<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span> 返回值</span>&#123;</span><br><span class="line">  <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>函数调用的语法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值:=函数名(参数)</span><br></pre></td></tr></table></figure></li></ul><h1 id="无参数无返回值函数"><a href="#无参数无返回值函数" class="headerlink" title="无参数无返回值函数"></a>无参数无返回值函数</h1><ul><li><p>函数可以有参数也可以没有参数,可以有返回值也可以没有返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">demo1()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"执行demo1函数"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面代码等同于</span></span><br><span class="line"><span class="comment">//func main()&#123;</span></span><br><span class="line"><span class="comment">//fmt.Println("执行demo1函数")</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h1 id="有参数函数"><a href="#有参数函数" class="headerlink" title="有参数函数"></a>有参数函数</h1></li><li><p>函数的参数可以有多个,且每个参数类型都可以不同</p></li><li><p>参数表示调用函数方想要给函数内部传递的值,给函数使用的.</p></li><li><p>声明函数时的参数叫做形参数,调用函数时参数叫做实参</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i:=<span class="number">5</span></span><br><span class="line">s:=<span class="string">"msr"</span></span><br><span class="line">show(s,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(name <span class="keyword">string</span>,age <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"姓名:"</span>,name,<span class="string">"年龄"</span>,age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h1></li><li><p>函数的返回值是给调用方返回的数据,给调用方使用的.</p></li><li><p>具有返回值的函数,必须要有return</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">fmt.Println(add(a,b))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(c, d <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c + d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也可以在返回值类型前面添加变量,return关键字后不写内容,表示变量是什么返回值什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">fmt.Println(add2(a,b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add2</span><span class="params">(c, d <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum = c + d</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="多返回值函数"><a href="#多返回值函数" class="headerlink" title="多返回值函数"></a>多返回值函数</h1><ul><li><p>在Go语言中每个函数声明时都可以定义成多返回值函数</p></li><li><p>Go语言中所有的错误都是通过返回值返回的</p></li><li><p>声明多返回值函数的语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span> <span class="params">(返回值,返回值)</span></span>&#123;</span><br><span class="line">  <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用函数的语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量,变量:=函数名(参数)</span><br></pre></td></tr></table></figure></li><li><p>调用函数时如果不想接收可以使用下划线占位</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量,_:=函数名(参数)</span><br></pre></td></tr></table></figure></li><li><p>理论上函数返回值个数可以无限多个,但是一般不去定义特别多个返回值(用结构体代替多返回值)</p></li></ul><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><ul><li>函数的返回值可以不接收,表示执行函数</li><li>函数的返回值如果接收,用于接收返回值的变量个数与返回值个数相同</li><li>不想接收的使用占位符(_)占位<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//不接收函数返回值</span></span><br><span class="line">demo()</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个返回值都接收</span></span><br><span class="line">a, b := demo()</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不希望接收的返回值使用下划线占位</span></span><br><span class="line">c, _ := demo()</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"msr"</span>, <span class="number">17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>多返回值函数也可以给返回值定义变量,return后面就不需要编写内容<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">()</span> <span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">name = <span class="string">"nsr"</span></span><br><span class="line">age = <span class="number">17</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h1><ul><li>Go语言支持可变参数函数</li><li>可变参数指调用参数时,参数的个数可以是任意个</li><li>可变参数必须在参数列表最后的位置,在参数名和类型之间添加三个点表示可变参数函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数<span class="params">(参数,参数,名称 ... 类型 )</span></span>&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>输出语句就是可变参数函数,源码如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>声明函数时,在函数体把可变参数当作切片使用即可</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li>声明可变参数声明与调用<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">demo(<span class="string">"看书"</span>, <span class="string">"写代码"</span>, <span class="string">"看抖音视频"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(hover ... <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> a, b := <span class="keyword">range</span> hover &#123;</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可变参数必须存在其他参数后面,一个函数不能有多个可变参数.<ul><li>因为前面普通参数个数是确定的,编译器知道,哪个实参给哪个形参<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">demo(<span class="string">"张三"</span>, <span class="string">"看书"</span>, <span class="string">"写代码"</span>, <span class="string">"看抖音视频"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(name <span class="keyword">string</span>, hover ... <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(name, <span class="string">"的爱好是"</span>)</span><br><span class="line"><span class="keyword">for</span> a, b := <span class="keyword">range</span> hover &#123;</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><ul><li><p>匿名函数就是没有名称的函数</p></li><li><p>正常函数可以通过名称多次调用,而匿名函数由于没有函数名,所以大部分情况都是在当前位置声明并立即调用(函数变量除外)</p></li><li><p>匿名函数声明完需要调用,在函数结束大括号后面紧跟小括号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;()<span class="comment">//括号表示调用</span></span><br></pre></td></tr></table></figure></li><li><p>匿名函数都是声明在其他函数内部</p><h2 id="匿名函数演示"><a href="#匿名函数演示" class="headerlink" title="匿名函数演示"></a>匿名函数演示</h2></li><li><p>无参数匿名函数</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"这是匿名函数"</span>)</span><br><span class="line">   &#125;()<span class="comment">//括号表示调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参数匿名函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Println(s, <span class="string">"这是匿名函数"</span>)</span><br><span class="line">   &#125;(<span class="string">"传递参数"</span>) <span class="comment">//调用时传递参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参数有返回值匿名函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(s, <span class="string">"这是匿名函数"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">110</span></span><br><span class="line">&#125;(<span class="string">"传递参数"</span>) <span class="comment">//调用时传递参数</span></span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h1><ul><li><p>在Go语言中函数也是一种类型,函数有多少种形式,函数变量就有多少种写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">()</span>           //无参数无返回值</span></span><br><span class="line"><span class="keyword">var</span> b <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span>        //有一个<span class="title">int</span>类型参数</span></span><br><span class="line"><span class="keyword">var</span> c <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">string</span> //有一个<span class="title">int</span>类型参数和<span class="title">string</span>类型返回值</span></span><br><span class="line">fmt.Println(a, b, c)   <span class="comment">//输出:&lt;nil&gt; &lt;nil&gt; &lt;nil&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义完函数变量后,可以使用匿名函数进行赋值.也可以使用已经定义好的函数进行赋值</p></li><li><p>函数变量定义以后与普通函数调用语法相同,变量名就是普通函数声明的函数名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">a = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"执行函数"</span>)</span><br><span class="line">&#125;   <span class="comment">//注意此处没有括号,有括号表示调用函数,变量a就表示接收函数返回值</span></span><br><span class="line">a() <span class="comment">//调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也可以使用短变量方式定义函数变量</span></span><br><span class="line"><span class="comment">等效于</span></span><br><span class="line"><span class="comment">func b(s string)&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">b := <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"执行第二个函数"</span>)</span><br><span class="line">&#125;</span><br><span class="line">b(<span class="string">"参数"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用定义好的函数</span></span><br><span class="line">d := c</span><br><span class="line">d()</span><br><span class="line"><span class="comment">//函数名称c也是一个变量</span></span><br><span class="line">c()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"c函数"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数类型变量是除了slice、map、channel、interface外第五种引用类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">a = b</span><br><span class="line">a()</span><br><span class="line"><span class="keyword">var</span> c <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">c = a</span><br><span class="line">c()</span><br><span class="line">fmt.Printf(<span class="string">"%p %p"</span>, a, c)<span class="comment">//输出地址相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"b"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数作为参数或返回值"><a href="#函数作为参数或返回值" class="headerlink" title="函数作为参数或返回值"></a>函数作为参数或返回值</h2></li><li><p>变量可以作为函数的参数或返回值类型.而函数既然可以当做变量看待,函数变量也可以当做函数的参数或返回值</p></li><li><p>函数作为参数时,类型写成对应的类型即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a(<span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">(b <span class="keyword">func</span>(s <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a执行"</span>)</span><br><span class="line">b(<span class="string">"传递给s的内容"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数作为返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//此时result指向返回值函数.</span></span><br><span class="line">result := a()</span><br><span class="line"><span class="comment">//调用函数,才能获取结果</span></span><br><span class="line">fmt.Println(result())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">110</span><span class="keyword">go</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang学习九：sort包、map、双向链表、双向循环链表</title>
    <link href="http://www.maishuren.top/posts/golang/202006182323-index.html"/>
    <id>http://www.maishuren.top/posts/golang/202006182323-index.html</id>
    <published>2020-06-18T15:23:43.000Z</published>
    <updated>2020-06-18T15:33:37.972Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="sort包"><a href="#sort包" class="headerlink" title="sort包"></a>sort包</h1><ul><li>Go语言标准库中sort提供了排序API</li><li>sort包提供了多种排序算法,这些算法是内部实现的,每次使用sort包排序时,会自动选择最优算法实现<ul><li>插入排序</li><li>快速排序</li><li>堆排</li></ul></li><li>sort包中最上层是一个名称为Interface的接口,只要满足sort.Interface类型都可以排序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A type, typically a collection, that satisfies sort.Interface can be</span></span><br><span class="line"><span class="comment">// sorted by the routines in this package. The methods require that the</span></span><br><span class="line"><span class="comment">// elements of the collection be enumerated by an integer index.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">Len() <span class="keyword">int</span></span><br><span class="line"><span class="comment">// Less reports whether the element with</span></span><br><span class="line"><span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Go语言标准库默认提供了对int、float64、string进行排序的API</li><li>很多函数的参数都是sort包下类型,需要进行转换.</li></ul><h1 id="排序实现"><a href="#排序实现" class="headerlink" title="排序实现"></a>排序实现</h1><ul><li>对int类型切片排序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num := [] <span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>&#125;</span><br><span class="line">sort.Ints(num) <span class="comment">//升序</span></span><br><span class="line">fmt.Println(num)</span><br><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(num))) <span class="comment">//降序</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure></li><li>对float64类型切片排序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f := [] <span class="keyword">float64</span>&#123;<span class="number">1.5</span>, <span class="number">7.2</span>, <span class="number">5.8</span>, <span class="number">2.3</span>, <span class="number">6.9</span>&#125;</span><br><span class="line">sort.Float64s(f) <span class="comment">//升序</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">sort.Sort(sort.Reverse(sort.Float64Slice(f))) <span class="comment">//降序</span></span><br><span class="line">fmt.Println(f)</span><br></pre></td></tr></table></figure></li><li>对string类型切片排序<ul><li>按照编码表数值进行排序</li><li>多字符串中按照第一个字符进行比较</li><li>如果第一个字符相同,比较第二个字符<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">string</span>&#123;<span class="string">"我"</span>, <span class="string">"我是Goer"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>, <span class="string">"国家"</span>, <span class="string">"你"</span>, <span class="string">"我a"</span>&#125;</span><br><span class="line">sort.Sort(sort.StringSlice(s)) <span class="comment">//升序</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="comment">//查找内容的索引,如果不存在,返回内容应该在升序排序切片的哪个位置插入</span></span><br><span class="line">fmt.Println(sort.SearchStrings(s, <span class="string">"你是"</span>))</span><br><span class="line">sort.Sort(sort.Reverse(sort.StringSlice(s)))</span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ul><li><p>map以散列表方式存储键值对集合</p></li><li><p>map中每个元素都是键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[key]Value</span><br></pre></td></tr></table></figure></li><li><p>key是操作map的唯一标准.可以通过key对map中元素进行增加/删除/修改/查看</p></li><li><p>key是唯一的,添加重复的key会覆盖之前的元素.</p></li><li><p>map是值类型,只声明时为空指针(nil)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(m == <span class="literal">nil</span>) <span class="comment">//输出:true</span></span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>, m)   <span class="comment">//输出:0x0</span></span><br></pre></td></tr></table></figure></li><li><p>map读写数据时并不是并发安全的,可以结合RWMutex保证并发安全(RWMutex在后面讲解)</p></li></ul><h2 id="实例化map的几种方式"><a href="#实例化map的几种方式" class="headerlink" title="实例化map的几种方式"></a>实例化map的几种方式</h2><ul><li>使用make函数实例化一个没有初始值的map<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(m==<span class="literal">nil</span>)<span class="comment">//输出:false</span></span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>, m)<span class="comment">//输出:内存地址</span></span><br></pre></td></tr></table></figure></li><li>可以在声明map时直接给map赋初始值.注意初始值在一行和在多行写时的语法区别<ul><li>map中元素键值对语法满足: key:value</li><li>key和value的类型必须和map[key]value类型严格对应<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"msr"</span>, <span class="string">"address"</span>: <span class="string">"中国广东"</span>&#125;</span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"name"</span>:     <span class="string">"msr"</span>,</span><br><span class="line"><span class="string">"addresss"</span>: <span class="string">"中国广东"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m, m1)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="操作map中的元素"><a href="#操作map中的元素" class="headerlink" title="操作map中的元素"></a>操作map中的元素</h2><ul><li>使用key判断,如果key不存在向map中新增数据,如果key存在会覆盖map中元素<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">m[<span class="string">"money"</span>] = <span class="number">5</span></span><br><span class="line">fmt.Println(m) <span class="comment">//输出:map[money:5]</span></span><br><span class="line">m[<span class="string">"money"</span>] = <span class="number">6</span></span><br><span class="line">fmt.Println(m) <span class="comment">//map[money:6]</span></span><br></pre></td></tr></table></figure></li><li>Go语言标准库中提供了对map元素删除的函数,使用顶层delete()即可完成删除<ul><li>如果key存在执行删除元素</li><li>如果key不存在,map中内容不变,也不会有错误<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">m[<span class="string">"money"</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"没有的key"</span>)</span><br><span class="line">fmt.Println(m) <span class="comment">//输出:map[money:5]</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"money"</span>)</span><br><span class="line">fmt.Println(m) <span class="comment">//输出:map[]</span></span><br></pre></td></tr></table></figure></li></ul></li><li>获取map中指定key对应的值<ul><li>使用:map变量[key]获取key对应的值</li><li>如果key不存在返回map[key]Value中Value类型的默认值.例如:Value是string类型就返回””</li><li>返回值可以是一个,也可以是两个.<ul><li>一个表示key对应的值</li><li>两个分别表示:key对应的值和这个key是否存在<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"msr"</span>, <span class="string">"address"</span>: <span class="string">"中国广东"</span>&#125;</span><br><span class="line">fmt.Println(m[<span class="string">"name"</span>]) <span class="comment">//输出:msr</span></span><br><span class="line">fmt.Println(m[<span class="string">"age"</span>])  <span class="comment">//输出:空字符串</span></span><br><span class="line">value, ok := m[<span class="string">"age"</span>]</span><br><span class="line">fmt.Println(value, ok) <span class="comment">//输出:空字符串 false</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>如果希望把map中所有元素都遍历,可以使用for结合range实现<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"msr"</span>, <span class="string">"address"</span>: <span class="string">"中国广东"</span>&#125;</span><br><span class="line"><span class="comment">//range遍历map时返回值分别表示key和value</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="双向链表概述"><a href="#双向链表概述" class="headerlink" title="双向链表概述"></a>双向链表概述</h1><ul><li><p>双向链表结构如下<br><img src="https://gitee.com/maishuren/blog-pic/raw/master/blog/lianbiao.png" alt="双向链表"></p></li><li><p>双向链表结构中元素在内存中不是紧邻空间,而是每个元素中存放上一个元素和后一个元素的地址</p><ul><li>第一个元素称为头(head)元素,前连接(前置指针域)为nil</li><li>最后一个元素称为尾(foot)元素,后连接(后置指针域)为nil</li></ul></li><li><p>双向链表的优点:</p><ul><li>在执行新增元素或删除元素时效率高,获取任意一个元素,可以方便的在这个元素前后插入元素</li><li>充分利用内存空间,实现内存灵活管理</li><li>可实现正序和逆序遍历</li><li>头元素和尾元素新增或删除时效率较高</li></ul></li><li><p>双向链表的缺点</p><ul><li>链表增加了元素的指针域,空间开销比较大</li><li>遍历时跳跃性查找内容,大量数据遍历性能低<h2 id="双向链表容器List"><a href="#双向链表容器List" class="headerlink" title="双向链表容器List"></a>双向链表容器List</h2></li></ul></li><li><p>在Go语言标准库的container/list 包提供了双向链表List</p></li><li><p>List结构体定义如下</p><ul><li>root表示根元素</li><li>len表示链表中有多少个元素<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List represents a doubly linked list.</span></span><br><span class="line"><span class="comment">// The zero value for List is an empty list ready to use.</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">root Element <span class="comment">// sentinel list element, only &amp;root, root.prev, and root.next are used</span></span><br><span class="line"><span class="built_in">len</span>  <span class="keyword">int</span>     <span class="comment">// current list length excluding (this) sentinel element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其中Element结构体定义如下</p><ul><li>next表示下一个元素,使用Next()可以获取到</li><li>prev表示上一个元素,使用Prev()可以获取到</li><li>list表示元素属于哪个链表</li><li>Value表示元素的值,interface{}在Go语言中表示任意类型<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Element is an element of a linked list.</span></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Next and previous pointers in the doubly-linked list of elements.</span></span><br><span class="line"><span class="comment">// To simplify the implementation, internally a list l is implemented</span></span><br><span class="line"><span class="comment">// as a ring, such that &amp;l.root is both the next element of the last</span></span><br><span class="line"><span class="comment">// list element (l.Back()) and the previous element of the first list</span></span><br><span class="line"><span class="comment">// element (l.Front()).</span></span><br><span class="line">next, prev *Element</span><br><span class="line"></span><br><span class="line"><span class="comment">// The list to which this element belongs.</span></span><br><span class="line">list *List</span><br><span class="line"></span><br><span class="line"><span class="comment">// The value stored with this element.</span></span><br><span class="line">Value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="操作List"><a href="#操作List" class="headerlink" title="操作List"></a>操作List</h2><ul><li>直接使用container/list包下的New()新建一个空的List<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylist := list.New()</span><br><span class="line">fmt.Println(mylist)       <span class="comment">//输出list中内容</span></span><br><span class="line">fmt.Println(mylist.Len()) <span class="comment">//查看链表中元素的个数</span></span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>, mylist)  <span class="comment">//输出地址</span></span><br></pre></td></tr></table></figure></li><li>Go语言标准库中提供了很多向双向链表中添加元素的函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加到最后,List["a"]</span></span><br><span class="line">mylist.PushBack(<span class="string">"a"</span>)</span><br><span class="line">   <span class="comment">//添加到最前面,List["b","a"]</span></span><br><span class="line">mylist.PushFront(<span class="string">"b"</span>) </span><br><span class="line"><span class="comment">//向第一个元素后面添加元素,List["b","c","a"]</span></span><br><span class="line">mylist.InsertAfter(<span class="string">"c"</span>, mylist.Front()) </span><br><span class="line"><span class="comment">//向最后一个元素前面添加元素,List["b","c","d","a"]</span></span><br><span class="line">mylist.InsertBefore(<span class="string">"d"</span>, mylist.Back())</span><br></pre></td></tr></table></figure></li><li>取出链表中的元素<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(mylist.Back().Value)  <span class="comment">//最后一个元素的值</span></span><br><span class="line">fmt.Println(mylist.Front().Value) <span class="comment">//第一个元素的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只能从头向后找,或从后往前找,获取元素内容</span></span><br><span class="line">n := <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> curr *list.Element</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; n &lt;= mylist.Len() &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">curr = mylist.Front()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> n == mylist.Len() &#123;</span><br><span class="line">curr = mylist.Back()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">curr = mylist.Front()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">curr = curr.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"n的数值不对"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历所有值</span></span><br><span class="line"><span class="keyword">for</span> e := mylist.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>移动元素的顺序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylist.MoveToBack(mylist.Front()) <span class="comment">//把第一个移动到后面</span></span><br><span class="line">mylist.MoveToFront(mylist.Back()) <span class="comment">//把最后一个移动到前面</span></span><br><span class="line">mylist.MoveAfter(mylist.Front(),mylist.Back())<span class="comment">//把第一个参数元素,移动到第二个参数元素后面</span></span><br><span class="line">mylist.MoveBefore(mylist.Front(),mylist.Back())<span class="comment">//把第一个参数元素,移动到第二个参数元素前面</span></span><br></pre></td></tr></table></figure></li><li>删除元素<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mylist.Remove(mylist.Front())</span><br></pre></td></tr></table></figure></li></ul><h1 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h1><ul><li><p>循环链表特点是没有节点的指针域为nil,通过任何一个元素都可以找到其他元素</p></li><li><p>环形链表结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A --&gt;B</span><br><span class="line">B --&gt;C</span><br><span class="line">C --&gt;D</span><br><span class="line">D --&gt;E</span><br><span class="line">E --&gt;D</span><br><span class="line">A --&gt;E</span><br><span class="line">E --&gt;A</span><br><span class="line">D --&gt;C</span><br><span class="line">C --&gt;B</span><br><span class="line">B --&gt;A</span><br></pre></td></tr></table></figure></li><li><p>双向循环链表和双向链表区别</p><ul><li>双向循环链表没有严格意义上的头元素和尾元素</li><li>没有元素的前连接和后连接为nil</li><li>一个长度为n的双向循环链表,通过某个元素向某个方向移动,在查找最多n-1次后一定会找到另一个元素</li></ul></li></ul><h2 id="Go语言中的双向循环链表"><a href="#Go语言中的双向循环链表" class="headerlink" title="Go语言中的双向循环链表"></a>Go语言中的双向循环链表</h2><ul><li><p>在container/ring包下结构体Ring源码如下</p><ul><li>官方明确说明了Ring是循环链表的元素,又是环形链表.</li><li>实际使用时Ring遍历就是环形链表第一个元素<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Ring is an element of a circular list, or ring.</span></span><br><span class="line"><span class="comment">// Rings do not have a beginning or end; a pointer to any ring element</span></span><br><span class="line"><span class="comment">// serves as reference to the entire ring. Empty rings are represented</span></span><br><span class="line"><span class="comment">// as nil Ring pointers. The zero value for a Ring is a one-element</span></span><br><span class="line"><span class="comment">// ring with a nil Value.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> Ring <span class="keyword">struct</span> &#123;</span><br><span class="line">next, prev *Ring</span><br><span class="line">Value      <span class="keyword">interface</span>&#123;&#125; <span class="comment">// for use by client; untouched by this library</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Go语言标准库中对container/ring包提供的API如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ring</span><br><span class="line"><span class="comment">//实例化长度为n的环形链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">//下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Next</span><span class="params">()</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="comment">//上一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Prev</span><span class="params">()</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="comment">//移动n次,支持负数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Move</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="comment">//合并s和r</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Link</span><span class="params">(s *Ring)</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="comment">//删除r后面n%r.Len()元素,删除多个,当前元素前面的不删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Unlink</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="comment">//循环遍历,i是当前元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span></span><br></pre></td></tr></table></figure><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2></li><li><p>实例化、赋值、遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r := ring.New(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r.Len(); i++ &#123;</span><br><span class="line">r.Move(i).Value = i</span><br><span class="line">&#125;</span><br><span class="line">r.Do(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>实例化后的r就是链表中第一个创建的元素.可以找到元素的前后元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(r.Next().Value)<span class="comment">//输出:1</span></span><br><span class="line">fmt.Println(r.Next().Next().Value)<span class="comment">//输出:2</span></span><br><span class="line">fmt.Println(r.Next().Next().Next().Value)<span class="comment">//输出:0</span></span><br><span class="line">fmt.Println(r.Move(<span class="number">-1</span>).Value)<span class="comment">//输出:2</span></span><br><span class="line">fmt.Println(r.Prev().Value)<span class="comment">//输出:2</span></span><br></pre></td></tr></table></figure></li><li><p>可以向环形链表添加或删除链表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s := ring.New(<span class="number">1</span>)</span><br><span class="line">s.Value = <span class="number">13</span></span><br><span class="line"><span class="comment">//r是哪个元素,就把新的链表添加到哪个元素后面</span></span><br><span class="line">r.Link(s)</span><br><span class="line">r.Do(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Print(i, <span class="string">" "</span>)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">""</span>)</span><br><span class="line"><span class="comment">//从r元素向后,n/r.Len()个元素被删除,当前元素和前面的保留</span></span><br><span class="line">r.Unlink(<span class="number">1</span>)</span><br><span class="line">r.Do(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Print(i, <span class="string">" "</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>centos7安装docker</title>
    <link href="http://www.maishuren.top/posts/docker/202006161622-index.html"/>
    <id>http://www.maishuren.top/posts/docker/202006161622-index.html</id>
    <published>2020-06-16T08:22:16.000Z</published>
    <updated>2020-06-16T09:10:47.762Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>1.查看内核版本</p><p>linux操作系统Centos7，linux 3.10 内核，docker官方说至少3.8以上（ubuntu下要linux内核3.8以上）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# uname -a</span><br><span class="line">Linux msr-server 3.10.0-514.26.2.el7.x86_64 #1 SMP Tue Jul 4 15:04:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>2.更新yum包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# yum update</span><br></pre></td></tr></table></figure><p>3.安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# yum -y install gcc</span><br><span class="line">[root@msr-server ~]# yum -y install gcc-c++</span><br><span class="line">[root@msr-server ~]# yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>4.设置阿里云的yum源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docke-rce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>5.查看仓库中docker版本，可以指定安装，不指定安装最新版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# yum list docker-ce --showduplicates | sort -r</span><br><span class="line">Repodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fast</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Installed Packages</span><br><span class="line">docker-ce.x86_64            3:19.03.5-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.5-3.el7                    @docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.4-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.3-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.2-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.1-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.0-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.9-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.8-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.7-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.6-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.5-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.4-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.3-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.2-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.1-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.0-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.3.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.2.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.1.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.0.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.03.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.03.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.12.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.12.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.09.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.09.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.06.2.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.06.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.06.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.3.ce-1.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.2.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">Determining fastest mirrors</span><br><span class="line">Available Packages</span><br></pre></td></tr></table></figure><p>6.安装docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# yum makecache fast</span><br><span class="line">[root@msr-server ~]# yum install docker-ce-18.03.1.ce</span><br></pre></td></tr></table></figure><p>7.启动Docker，加入开机启动，验证安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@msr-server ~]# systemctl start docker</span><br><span class="line">[root@msr-server ~]# systemctl enable  docker</span><br><span class="line">[root@msr-server ~]# docker version</span><br></pre></td></tr></table></figure><p>8.配置阿里云镜像加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# mkdir -p /etc/docker</span><br><span class="line">[root@msr-server ~]# tee /etc/docker/daemon.json &lt;&lt;-'EOF' </span><br><span class="line">&#123; </span><br><span class="line">"registry-mirrors": ["https://****.mirror.aliyuncs.com"] </span><br><span class="line">&#125; </span><br><span class="line">EOF</span><br><span class="line">[root@msr-server ~]# systemctl daemon-reload </span><br><span class="line">[root@msr-server ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="云计算" scheme="http://www.maishuren.top/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="docker" scheme="http://www.maishuren.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>nginx入门之配置语法</title>
    <link href="http://www.maishuren.top/posts/nginx/202006161551-index.html"/>
    <id>http://www.maishuren.top/posts/nginx/202006161551-index.html</id>
    <published>2020-06-16T07:51:03.000Z</published>
    <updated>2020-06-19T06:19:14.013Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="默认的配置文件"><a href="#默认的配置文件" class="headerlink" title="默认的配置文件"></a>默认的配置文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                  '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                  '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"></span><br><span class="line">access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">sendfile        on;</span><br><span class="line"><span class="meta">#</span><span class="bash">tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">gzip  on;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  localhost;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">   root   /usr/share/nginx/html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">error_page   500 502 503 504 404  /50x.html;</span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">    root   /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>user:设置nginx服务的系统使用用户</li><li>worker_processes:工作进程数</li><li>error_log:nginx的错误日志</li><li>pid:nginx服务启动时候pid</li><li>events：<ul><li>worker_connections:每个进程允许最大连接数</li><li>use:工作进程数</li></ul></li><li>server:<ul><li>listen 80 监听服务器80端口</li><li>server_name 可配置域名</li><li>location /:根目录<ul><li>root &amp; index:默认访问页面</li></ul></li><li>error_page: 错误页面，500 502 503 504 404这些状态码都会跳转到/50x.html</li><li>location = /50x.html:响应50x.html的访问，根目录下的50x.html</li></ul></li><li>keepalive_timeout:客户端超时时间</li><li>include /etc/nginx/conf.d/*.conf:引入配置文件，一般一个配置文件一个server</li></ul><h1 id="日志格式log-format"><a href="#日志格式log-format" class="headerlink" title="日志格式log_format"></a>日志格式log_format</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">默认配置</span></span><br><span class="line">log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                      '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                      '"$http_user_agent" "$http_x_forwarded_for"';</span><br></pre></td></tr></table></figure><p>1.Http变量：arg_PARAMETER、http_HEADER、sent_http_HEADER</p><p>​        eg:log_format  main ‘$arg_PARAMETER $http_HEADER $sent_http_HEADER’</p><p>2.内置变量：</p><p>​        内置变量存放在 ngx_http_core_module 模块中，变量的命名方式和apache 服务器变量是一致的。总而言之，这些变量代表着客户端请求头的内容。下面是nginx支持的内置变量：</p><p><strong>$arg_name</strong></p><p>请求中的的参数名，即“?”后面的arg_name=arg_value形式的arg_name</p><p><strong>$args</strong></p><p>请求中的参数值</p><p><strong>$binary_remote_addr</strong></p><p>客户端地址的二进制形式, 固定长度为4个字节</p><p><strong>$body_bytes_sent</strong></p><p>传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的“%B”参数保持兼容</p><p><strong>$bytes_sent</strong></p><p>传输给客户端的字节数 (1.3.8, 1.2.5)</p><p><strong>$connection</strong></p><p>TCP连接的序列号 (1.3.8, 1.2.5)</p><p><strong>$connection_requests</strong></p><p>TCP连接当前的请求数量 (1.3.8, 1.2.5)</p><p><strong>$content_length</strong></p><p>“Content-Length” 请求头字段</p><p><strong>$content_type</strong></p><p>“Content-Type” 请求头字段</p><p><strong>$cookie_name</strong></p><p>cookie名称</p><p><strong>$document_root</strong></p><p>当前请求的文档根目录或别名</p><p><strong>$document_uri</strong></p><p>同 $uri</p><p><strong>$host</strong></p><p>优先级如下：HTTP请求行的主机名&gt;”HOST”请求头字段&gt;符合请求的服务器名</p><p><strong>$hostname</strong></p><p>主机名</p><p><strong>$http_name</strong></p><p>匹配任意请求头字段； 变量名中的后半部分“name”可以替换成任意请求头字段，如在配置文件中需要获取http请求头：“Accept-Language”，那么将“－”替换为下划线，大写字母替换为小写，形如：$http_accept_language即可。</p><p>*<em>$https *</em></p><p>如果开启了SSL安全模式，值为“on”，否则为空字符串。</p><p><strong>$is_args</strong></p><p>如果请求中有参数，值为“?”，否则为空字符串。</p><p><strong>$limit_rate</strong></p><p>用于设置响应的速度限制，详见 limit_rate。</p><p><strong>$msec</strong></p><p>当前的Unix时间戳 (1.3.9, 1.2.6)</p><p><strong>$nginx_version</strong></p><p>nginx版本</p><p><strong>$pid</strong></p><p>工作进程的PID</p><p><strong>$pipe</strong></p><p>如果请求来自管道通信，值为“p”，否则为“.” (1.3.12, 1.2.7)</p><p><strong>$proxy_protocol_addr</strong></p><p>获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串。(1.5.12)</p><p><strong>$query_string</strong></p><p>同 $args</p><p><strong>$realpath_root</strong></p><p>当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径。</p><p><strong>$remote_addr</strong></p><p>客户端地址</p><p><strong>$remote_port</strong></p><p>客户端端口</p><p><strong>$remote_user</strong></p><p>用于HTTP基础认证服务的用户名</p><p><strong>$request</strong></p><p>代表客户端的请求地址</p><p><strong>$request_body</strong></p><p>客户端的请求主体</p><p>此变量可在location中使用，将请求主体通过proxy_pass, fastcgi_pass, uwsgi_pass, 和 scgi_pass传递给下一级的代理服务器。</p><p><strong>$request_body_file</strong></p><p>将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置client_body_in_file_only。如果将次文件传递给后端的代理服务器，需要禁用request body，即设置proxy_pass_request_body off，fastcgi_pass_request_body off, uwsgi_pass_request_body off, or scgi_pass_request_body off 。</p><p><strong>$request_completion</strong></p><p>如果请求成功，值为”OK”，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空。</p><p><strong>$request_filename</strong></p><p>当前连接请求的文件路径，由root或alias指令与URI请求生成。</p><p><strong>$request_length</strong></p><p>请求的长度 (包括请求的地址, http请求头和请求主体) (1.3.12, 1.2.7)</p><p><strong>$request_method</strong></p><p>HTTP请求方法，通常为“GET”或“POST”</p><p><strong>$request_time</strong></p><p>处理客户端请求使用的时间 (1.3.9, 1.2.6); 从读取客户端的第一个字节开始计时。</p><p><strong>$request_uri</strong></p><p>这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：”/cnphp/test.php?arg=freemouse”。</p><p><strong>$scheme</strong></p><p>请求使用的Web协议, “http” 或 “https”</p><p><strong>$sent_http_name</strong></p><p>可以设置任意http响应头字段； 变量名中的后半部分“name”可以替换成任意响应头字段，如需要设置响应头Content-length，那么将“－”替换为下划线，大写字母替换为小写，形如：$sent_http_content_length 4096即可。</p><p><strong>$server_addr</strong></p><p>服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中。</p><p><strong>$server_name</strong></p><p>服务器名，<a href="http://www.cnphp.info" target="_blank" rel="noopener">www.cnphp.info</a></p><p><strong>$server_port</strong></p><p>服务器端口</p><p><strong>$server_protocol</strong></p><p>服务器的HTTP版本, 通常为 “HTTP/1.0” 或 “HTTP/1.1”</p><p><strong>$status</strong></p><p>HTTP响应代码 (1.3.2, 1.2.2)</p><p><strong>$tcpinfo_rtt, $tcpinfo_rttvar, $tcpinfo_snd_cwnd, $tcpinfo_rcv_space</strong></p><p>客户端TCP连接的具体信息</p><p><strong>$time_iso8601</strong></p><p>服务器时间的ISO 8610格式 (1.3.12, 1.2.7)</p><p>*<em>$time_local $arg_name *</em></p><p>请求中的的参数名，即“?”后面的arg_name=arg_value形式的arg_name</p><p><strong>$args</strong></p><p>请求中的参数值</p><p><strong>$binary_remote_addr</strong></p><p>客户端地址的二进制形式, 固定长度为4个字节</p><p><strong>$body_bytes_sent</strong></p><p>传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的“%B”参数保持兼容</p><p><strong>$bytes_sent</strong></p><p>传输给客户端的字节数 (1.3.8, 1.2.5)</p><p><strong>$connection</strong></p><p>TCP连接的序列号 (1.3.8, 1.2.5)</p><p><strong>$connection_requests</strong></p><p>TCP连接当前的请求数量 (1.3.8, 1.2.5)</p><p>*<em>$content_lengt *</em></p><p>“Content-Length” 请求头字段</p><p><strong>$content_type</strong></p><p>“Content-Type” 请求头字段</p><p>*<em>$cookie_name *</em></p><p>cookie名称</p><p><strong>$document_root</strong></p><p>当前请求的文档根目录或别名</p><p><strong>$document_uri</strong></p><p>同 $uri</p><p><strong>$host</strong></p><p>优先级如下：HTTP请求行的主机名&gt;”HOST”请求头字段&gt;符合请求的服务器名</p><p><strong>$hostname</strong></p><p>主机名</p><p><strong>$http_name</strong></p><p>匹配任意请求头字段； 变量名中的后半部分“name”可以替换成任意请求头字段，如在配置文件中需要获取http请求头：“Accept-Language”，那么将“－”替换为下划线，大写字母替换为小写，形如：$http_accept_language即可。</p><p><strong>$https</strong></p><p>如果开启了SSL安全模式，值为“on”，否则为空字符串。</p><p><strong>$is_args</strong></p><p>如果请求中有参数，值为“?”，否则为空字符串。</p><p><strong>$limit_rate</strong></p><p>用于设置响应的速度限制，详见 limit_rate。</p><p><strong>$msec</strong></p><p>当前的Unix时间戳 (1.3.9, 1.2.6)</p><p><strong>$nginx_version</strong></p><p>nginx版本</p><p><strong>$pid</strong></p><p>工作进程的PID</p><p><strong>$pipe</strong></p><p>如果请求来自管道通信，值为“p”，否则为“.” (1.3.12, 1.2.7)</p><p><strong>$proxy_protocol_addr</strong></p><p>获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串。(1.5.12)</p><p><strong>$query_string</strong></p><p>同 $args</p><p><strong>$realpath_root</strong></p><p>当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径。</p><p><strong>$remote_addr</strong></p><p>客户端地址</p><p><strong>$remote_port</strong></p><p>客户端端口</p><p><strong>$remote_user</strong></p><p>用于HTTP基础认证服务的用户名</p><p><strong>$request</strong></p><p>代表客户端的请求地址</p><p><strong>$request_body</strong></p><p>客户端的请求主体</p><p>此变量可在location中使用，将请求主体通过proxy_pass, fastcgi_pass, uwsgi_pass, 和 scgi_pass传递给下一级的代理服务器。</p><p><strong>$request_body_file</strong></p><p>将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置client_body_in_file_only。如果将次文件传递给后端的代理服务器，需要禁用request body，即设置proxy_pass_request_body off，fastcgi_pass_request_body off, uwsgi_pass_request_body off, or scgi_pass_request_body off 。</p><p><strong>$request_completion</strong></p><p>如果请求成功，值为”OK”，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空。</p><p><strong>$request_filename</strong></p><p>当前连接请求的文件路径，由root或alias指令与URI请求生成。</p><p><strong>$request_length</strong></p><p>请求的长度 (包括请求的地址, http请求头和请求主体) (1.3.12, 1.2.7)</p><p><strong>$request_method</strong></p><p>HTTP请求方法，通常为“GET”或“POST”</p><p><strong>$request_time</strong></p><p>处理客户端请求使用的时间 (1.3.9, 1.2.6); 从读取客户端的第一个字节开始计时。</p><p><strong>$request_uri</strong></p><p>这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：”/cnphp/test.php?arg=freemouse”。</p><p><strong>$scheme</strong></p><p>请求使用的Web协议, “http” 或 “https”</p><p><strong>$sent_http_name</strong></p><p>可以设置任意http响应头字段； 变量名中的后半部分“name”可以替换成任意响应头字段，如需要设置响应头Content-length，那么将“－”替换为下划线，大写字母替换为小写，形如：$sent_http_content_length 4096即可。</p><p><strong>$server_addr</strong></p><p>服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中。</p><p><strong>$server_name</strong></p><p>服务器名如<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p><strong>$server_port</strong></p><p>服务器端口</p><p><strong>$server_protocol</strong></p><p>服务器的HTTP版本, 通常为 “HTTP/1.0” 或 “HTTP/1.1”</p><p><strong>$status</strong></p><p>HTTP响应代码 (1.3.2, 1.2.2)</p><p><strong>$tcpinfo_rtt</strong>, $tcpinfo_rttvar, $tcpinfo_snd_cwnd, $tcpinfo_rcv_space</p><p>客户端TCP连接的具体信息</p><p><strong>$time_iso8601</strong></p><p>服务器时间的ISO 8610格式 (1.3.12, 1.2.7)</p><p><strong>$time_local</strong></p><p>服务器时间（LOG Format 格式） (1.3.12, 1.2.7)</p><p><strong>$uri</strong></p><p>请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如”/foo/bar.html”。</p><p>服务器时间（LOG Format 格式） (1.3.12, 1.2.7)</p><p><strong>$uri</strong></p><p>请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如”/foo/bar.html”。</p><h1 id="监控模块http-stub-status-modules"><a href="#监控模块http-stub-status-modules" class="headerlink" title="监控模块http_stub_status_modules"></a>监控模块http_stub_status_modules</h1><p>作用：监控Nginx客户端状态</p><p>作用域：server；location</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查看配置参数</span><br><span class="line">root@3de922dd7a75:/usr/share/nginx/html# nginx -V </span><br><span class="line">nginx version: nginx/1.19.0</span><br><span class="line">built by gcc 8.3.0 (Debian 8.3.0-6) </span><br><span class="line">built with OpenSSL 1.1.1d  10 Sep 2019</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt='-g -O2 -fdebug-prefix-map=/data/builder/debuild/nginx-1.19.0/debian/debuild-base/nginx-1.19.0=. -fstack-protector-strong -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC' --with-ld-opt='-Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie'</span><br></pre></td></tr></table></figure><ol><li>配置语法：在一个server下配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location  /status &#123;</span><br><span class="line">stub_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改完之后，测试配置文件是否有错误</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@3de922dd7a75:/etc/nginx# nginx -tc ./nginx.conf </span><br><span class="line">nginx: the configuration file /etc/nginx/./nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/./nginx.conf test is successful</span><br></pre></td></tr></table></figure><ol start="3"><li>重载配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@3de922dd7a75:/etc/nginx# nginx-s reload /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><ol start="4"><li>再访问htttp://ip/stasus，出现一下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Active connections: 2 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 4 4 1 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 1</span><br></pre></td></tr></table></figure><ol start="5"><li>nginx_status详解</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Active connections: 1     </span><br><span class="line">##nginx正处理的活跃连接数　　</span><br><span class="line">server accepts handled requests</span><br><span class="line">##server  nginx启动到现在共处理了多少个连接</span><br><span class="line">##accepts  nginx启动到现在共创建了多少次握手，请求丢失数&#x3D;握手数-连接数</span><br><span class="line">##handled requests    总共处理了多少个请求</span><br><span class="line">Reading: 0 Writing: 1 Waiting: 0</span><br><span class="line">##Reading  nginx读取客户端 header 信息数</span><br><span class="line">##Writing  nginx返回给客户端的 hearder 信息数</span><br><span class="line">##Waiting  nginx已经处理完正在等待下一次请求指令的驻留连接，在开启keep-alive的情况下，waiting值等于active - (Reading+Writing)</span><br></pre></td></tr></table></figure><h1 id="模块http-random-index-module"><a href="#模块http-random-index-module" class="headerlink" title="模块http_random_index_module"></a>模块http_random_index_module</h1><p>作用：在主目录中选择一个随机主页</p><p>默认：关闭</p><p>作用域：location</p><ol><li>配置语法：在location中配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">root /etc/nginx/html;</span><br><span class="line">random_index on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在/etc/nginx/html中新建一个html文件</li><li>重复上一小节的检查配置文件，重载配置文件，在浏览器访问，不断刷新，出现不同的页面</li></ol><h1 id="默认模块http-sub-module"><a href="#默认模块http-sub-module" class="headerlink" title="默认模块http_sub_module"></a>默认模块http_sub_module</h1><p>作用：HTTP内容替换</p><p>常用选项：sub_filter string replacement；sub_filter_last_modified on|off；sub_filter_once on|off</p><p>作用域：http；server；location</p><ol><li><p>配置语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">root &#x2F;etc&#x2F;nginx&#x2F;html;</span><br><span class="line">index index.html index.htm;</span><br><span class="line">sub_filter &#39;nginx&#39; &#39;NGINX&#39;; #替换第一个nginx</span><br><span class="line">sub_filter_once off; #关闭之后，所有的nginx都会被替换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Nginx的请求访问限制"><a href="#Nginx的请求访问限制" class="headerlink" title="Nginx的请求访问限制"></a>Nginx的请求访问限制</h1><h2 id="请求限制"><a href="#请求限制" class="headerlink" title="请求限制"></a>请求限制</h2><ol><li><p>连接频率限制：limit_conn_module</p><p>limit_conn_zone key zone=name:size，作用域：http</p><p>limit_conn zone number，作用域：http，server，location</p></li><li><p>请求频率限制：limit_req_module</p><p>limit_req_zone key zone=name:size rate=rate,http</p><p>limit_req zone=name，作用域：http，server，location</p></li><li><p>配置语法：</p><p>在http下配置，以客户端的ip地址作为key，对这个key进行限制，同时申请一个zone空间大小为1m用来存储访问的频次信息。$binary_remote_addr可以节省zone空间。rate=1r/s：表示允许相同标识的客户端的<strong>访问频次</strong>，这里限制的是每秒1次，即每秒只处理一个请求。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;conn_zone:1m</span><br><span class="line">limit_req_zone $binary_remote_addr zone&#x3D;req_zone:1m rate&#x3D;1r&#x2F;s</span><br></pre></td></tr></table></figure><ol start="4"><li>在localtion下配置：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location  /status &#123;</span><br><span class="line">   root html;</span><br><span class="line"><span class="meta">   #</span><span class="bash">   limit_conn conn_zone 1;  <span class="comment">#同一时间只允许一个连接</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">   limit_req zone=req_zone burst=3 nodelay;  </span></span><br><span class="line"><span class="meta">   #</span><span class="bash">   limit_req zone=req_zone burst=3;</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">   limit_req zone=req_zone;</span></span><br><span class="line">   index show.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> limit_req zone=req_zon：使用配置好的rate的速率来处理数据</p><p> burst=3：设置一个大小为3的缓冲区当有大量请求（爆发）过来时，超过了<strong>访问频次</strong>限制的<strong>请求可以先放到这个缓冲区内等待，但是这个等待区里的位置只有3个</strong>，超过的请求会直接报503的错误然后返回。</p><p>nodelay：如果设置，会在瞬时提供处理(burst + rate)个请求的能力，请求超过（<strong>burst + rate）</strong>的时候就会直接返回503，永远不存在请求需要等待的情况。如果没有设置，则所有请求会依次等待排队</p><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><h3 id="基于IP的访问控制：http-access-module"><a href="#基于IP的访问控制：http-access-module" class="headerlink" title="基于IP的访问控制：http_access_module"></a>基于IP的访问控制：http_access_module</h3><ol><li><p>常用选项：</p><p>allow address | CIDR | unix: | all。作用域： http,，server， location，limit_except</p><p>allow允许访问 ，address配置为IP地址</p><p>deny address | CIDR | unix: | all。作用域：http, server, location, limit_except</p><p>deny不允许访问 ，address配置为IP地址</p></li><li><p>在location下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">root html;</span><br><span class="line">    deny 192.168.1.74;#也可以配置IP段：192.168.1.0/24</span><br><span class="line">    allow all;</span><br><span class="line">    index show.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，location下的’/‘目录不允许IP为192.168.1.74的用户访问，其他地IP都可以访问。当192.168.1.74访问时，会出现403页面，不允许访问。</p></li><li><p>局限性：</p><p>由于http_access_module的访问控制是是针对客户端的IP来进行限制，凡是和nginx进行连接交互的都会被当作客户端，当真正的客户端与nginx之间有一下代理服务的时候，这种IP的控制就会失效。</p></li></ol><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/nginx/ip_fail_nginx.jpg" alt=""></p><ol start="4"><li><p>局限性解决方法总结：</p><p>方法一： 采用http头信息控制访问，如HTTP_X_FORWARD_FOR<br>方法二： 结合geo模块<br>方法三： 通过HTTP自定义变量传递</p><p>http_x_forwarded_for头信息控制访问 会更好的解决该问题,它要求访问时必须带上所有用到的ip的地址信息</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_x_forwarded_for &#x3D; Client IP, Proxy(1)IP, Proxy(2)IP,...</span><br></pre></td></tr></table></figure><h3 id="基于用户的信任登录：http-auth-basic-module"><a href="#基于用户的信任登录：http-auth-basic-module" class="headerlink" title="基于用户的信任登录：http_auth_basic_module"></a>基于用户的信任登录：http_auth_basic_module</h3><ol><li><p>常用选项：</p><p>auth_basic string | off。默认: auth_basic off。作用域：http, server, location, limit_except </p><p>auth_basic_user_file file。作用域： http, server, location, limit_except</p></li><li><p>配置：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@msr-server ~]# yum install httpd-tools -y        #安装httpd-tools工具</span><br><span class="line">[root@msr-server conf.d]# htpasswd -c .&#x2F;auth_conf msr  #生成文件</span><br><span class="line">New password: </span><br><span class="line">Re-type new password: </span><br><span class="line">Adding password for user msr</span><br><span class="line">[root@msr-server conf.d]# ll                           #查看</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 1 root root   42 Jun 19 14:05 auth_conf     </span><br><span class="line">-rw-r--r-- 1 root root 1144 Jun 16 18:09 default.conf</span><br><span class="line">[root@msr-server conf.d]# more auth_conf               #查看内容</span><br><span class="line">msr:$apr1$ripuvDcJ$274OgHXOPwCb5kJ5dggq7.</span><br></pre></td></tr></table></figure><ol start="3"><li>在location下配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">root html;</span><br><span class="line">auth_basic "AUth access!";</span><br><span class="line">auth_basic_user_file /etc/nginx/conf.d/auth_conf;</span><br><span class="line">index show.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再去访问，就会出现，认证框。虽然可以实现访问控制，但是用户信息依赖外部文件，操作管理机械，效率低下。所以可以Nginx结合LUA实现高效认证，Nginx和LDAR大同，利用nginx-auth-ldar模块</p><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/nginx/auth.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      高性能服务器Nginx的入门
    
    </summary>
    
    
      <category term="运维" scheme="http://www.maishuren.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="nginx" scheme="http://www.maishuren.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx入门之初识nginx</title>
    <link href="http://www.maishuren.top/posts/nginx/202006151538-index.html"/>
    <id>http://www.maishuren.top/posts/nginx/202006151538-index.html</id>
    <published>2020-06-15T07:38:28.000Z</published>
    <updated>2020-06-16T07:44:02.362Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><p><em>Nginx</em> (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><h1 id="Nginx的三个主要运用场景"><a href="#Nginx的三个主要运用场景" class="headerlink" title="Nginx的三个主要运用场景"></a>Nginx的三个主要运用场景</h1><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/nginx/nginx1.png" alt=""></p><ul><li>静态资源服务<ul><li>通过本地文件系统提供服务</li></ul></li><li>反向代理服务<ul><li>Ngnix强大性能</li><li>缓存</li><li>负载均衡</li></ul></li><li>API服务<ul><li>OpenResty</li></ul></li></ul><h1 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h1><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/nginx/nginx2.png" alt=""></p><h1 id="Nginx的组成"><a href="#Nginx的组成" class="headerlink" title="Nginx的组成"></a>Nginx的组成</h1><p>Nginx二进制可执行文件：由各模块源码编译出的一个文件</p><p>Nginx配置文件Nginx.conf：控制Nginx的行为</p><p>access.log访问日志：记录每一条http请求信息</p><p>error.log错误日志：记录错误信息，可以定位问题</p><h1 id="Nginx的编译和安装"><a href="#Nginx的编译和安装" class="headerlink" title="Nginx的编译和安装"></a>Nginx的编译和安装</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>1.安装相关依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel</span><br></pre></td></tr></table></figure><p>2.安装常用工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget httpd-tools vim</span><br></pre></td></tr></table></figure><p>3.查看防火墙状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br><span class="line">或者</span><br><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>4.开启了防火墙，所以配置iptables</p><p>安装iptables</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install iptables<span class="literal">-services</span></span><br></pre></td></tr></table></figure><p>配置iptables规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><p>常用的80和8080端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sample configuration <span class="keyword">for</span> iptables service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> you can edit this manually or use system-config-firewall</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> please <span class="keyword">do</span> not ask us to add additional ports/services to this default configuration</span></span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -jACCEPT    #添加的</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT  #添加的</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><p>重启生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart iptables</span><br></pre></td></tr></table></figure><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>1.下载Nginx压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.nginx.org/download/nginx-1.17.7.tar.gz</span><br></pre></td></tr></table></figure><p>2.解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.17.7.tar.gz</span><br></pre></td></tr></table></figure><p>3.Nginx目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x. 6 1001 1001   4096 Jun 15 18:53 auto</span><br><span class="line">-rw-r--r--. 1 1001 1001 301572 Dec 24 23:00 CHANGES</span><br><span class="line">-rw-r--r--. 1 1001 1001 460207 Dec 24 23:00 CHANGES.ru</span><br><span class="line">drwxr-xr-x. 2 1001 1001    168 Jun 15 18:53 conf</span><br><span class="line">-rwxr-xr-x. 1 1001 1001   2502 Dec 24 23:00 configure</span><br><span class="line">drwxr-xr-x. 4 1001 1001     72 Jun 15 18:53 contrib</span><br><span class="line">drwxr-xr-x. 2 1001 1001     40 Jun 15 18:53 html</span><br><span class="line">-rw-r--r--. 1 1001 1001   1397 Dec 24 23:00 LICENSE</span><br><span class="line">drwxr-xr-x. 2 1001 1001     21 Jun 15 18:53 man</span><br><span class="line">-rw-r--r--. 1 1001 1001     49 Dec 24 23:00 README</span><br><span class="line">drwxr-xr-x. 9 1001 1001     91 Jun 15 18:53 src</span><br></pre></td></tr></table></figure><p>4.编译安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 nginx-1.6.2]# ./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35</span><br><span class="line">[root@centos7 nginx-1.6.2]# make</span><br><span class="line">[root@centos7 nginx-1.6.2]# make install</span><br><span class="line">[root@centos7 nginx-1.6.2]#</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h3><p>安装目的目录或路径</p><ul><li>–prefix=/etc/nginx</li><li>–sbin-path=/usr/sbin/nginx</li><li>–modules-path=/usr/lib64/nginx/modules</li><li>–conf-path=/etc/nginx/nginx.conf</li><li>–error-log-path=/var/log/nginx/error.log</li><li>–http-log-path=/var/log/nginx/access.log</li><li>–pid-path=/var/run/nginx.pid (记录nginx启动服务的进程ID)</li><li>–lock-path=/var/run/nginx.lock</li></ul><p>编译生成的文件，执行对应模块时，Nginx所保留的临时性文件</p><ul><li>–http-client-body-temp-path=/var/cache/nginx/client_temp</li><li>–http-proxy-temp-path=/var/cache/nginx/proxy_temp</li><li>–http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp</li><li>–http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp</li><li>–http-scgi-temp-path=/var/cache/nginx/scgi_temp</li></ul><h3 id="rpm安装时的目录"><a href="#rpm安装时的目录" class="headerlink" title="rpm安装时的目录"></a>rpm安装时的目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;logrotate.d&#x2F;nginx</span><br></pre></td></tr></table></figure><ul><li><code>类型：配置文件</code></li><li><code>作用：Nginx日志轮转，用于logrotate服务的日志切割（比如按天切割日志）</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</span><br></pre></td></tr></table></figure><ul><li><code>类型：目录，配置文件</code></li><li><code>作用：Nginx主配置文件</code></li></ul><p>/etc/nginx/nginx.conf 是主配置文件，当Nginx启动优先读取，当没有变更的时候，会读取/etc/nginx/conf.d/default.conf（安装是默认加载的）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;fastcgi_params &#x2F;etc&#x2F;nginx&#x2F;uwsgi_params &#x2F;etc&#x2F;nginx&#x2F;scgi_params</span><br></pre></td></tr></table></figure><ul><li><code>类型：配置文件</code></li><li><code>作用：cgi配置相关，fastcgi配置</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;koi-utf &#x2F;etc&#x2F;nginx&#x2F;koi-win &#x2F;etc&#x2F;nginx&#x2F;win-utf</span><br></pre></td></tr></table></figure><ul><li><code>类型：配置文件</code></li><li><code>作用：编码转换映射转化文件</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;mime.types</span><br></pre></td></tr></table></figure><ul><li><p><code>类型：配置文件</code></p></li><li><p><code>作用：设置http协议的ContentType(数据返回类型)与扩展名对应关系</code></p><p>当Nginx要处理一些不能识别的扩展名和文件类型的时候就需要编辑该文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx-debug.service &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service &#x2F;etc&#x2F;sysconfig&#x2F;nginx &#x2F;etc&#x2F;sysconfig&#x2F;nginx-debug</span><br></pre></td></tr></table></figure><ul><li><code>类型：配置文件</code></li><li><code>作用：用于配置出系统守护进程管理器管理方式</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;lib64&#x2F;nginx &#x2F;etc&#x2F;nginx&#x2F;modules</span><br></pre></td></tr></table></figure><ul><li><code>类型：目录</code></li><li><code>作用：Nginx模块目录</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;sbin&#x2F;nginx-debug</span><br></pre></td></tr></table></figure><ul><li><code>类型：命令</code></li><li><code>作用：Nginx服务的启动管理的终端命令</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.6.2 &#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.6.2&#x2F;COPYRIGHT &#x2F;usr&#x2F;share&#x2F;man&#x2F;man8&#x2F;nginx.8.gz</span><br></pre></td></tr></table></figure><ul><li><code>类型：文件，目录</code></li><li><code>作用：Nginx的手册和帮助文件</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;cache&#x2F;nginx</span><br></pre></td></tr></table></figure><ul><li><code>类型：目录</code></li><li><code>作用：Nginx的缓存目录</code></li></ul><p>Nginx处理可以做代理，还可以做缓存服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;log&#x2F;nginx</span><br></pre></td></tr></table></figure><ul><li><code>类型：目录</code></li><li><code>作用：Nginx的日志目录</code></li></ul>]]></content>
    
    <summary type="html">
    
      高性能服务器Nginx的入门，初识Nginx
    
    </summary>
    
    
      <category term="运维" scheme="http://www.maishuren.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="nginx" scheme="http://www.maishuren.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot应用：整合actuator和Admin实现SpringBoot监控</title>
    <link href="http://www.maishuren.top/posts/springboot/202006141700-index.html"/>
    <id>http://www.maishuren.top/posts/springboot/202006141700-index.html</id>
    <published>2020-06-14T09:00:27.000Z</published>
    <updated>2020-06-14T09:00:27.868Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>大数据之hadoop一：hadoop入门</title>
    <link href="http://www.maishuren.top/posts/hadoop/202006132303-index.html"/>
    <id>http://www.maishuren.top/posts/hadoop/202006132303-index.html</id>
    <published>2020-06-13T15:03:26.000Z</published>
    <updated>2020-06-15T16:07:46.858Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Hadoop是什么？"><a href="#Hadoop是什么？" class="headerlink" title="Hadoop是什么？"></a>Hadoop是什么？</h1><p>1）hadoop是由Apache基金会所开发的分布式系统基础架构</p><p>2）主要解决海量数据的存储和海量数据的分析计算问题</p><p>3）广义来说，hadoop通常是之一个更广泛的概念—hadoop生态圈</p><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop1.jpg" alt=""></p><h1 id="Hadoop三大发行版本"><a href="#Hadoop三大发行版本" class="headerlink" title="Hadoop三大发行版本"></a>Hadoop三大发行版本</h1><p>Hadoop三大发行版本：Apache、Cloudera、Hortonworks。</p><p>Apache版本最原始（最基础）的版本，对于入门学习最好。</p><p>Cloudera在大型互联网企业中用的较多。</p><p>Hortonworks文档较好。</p><ol><li>Apache Hadoop</li></ol><p>官网地址：<a href="http://hadoop.apache.org/releases.html" target="_blank" rel="noopener">http://hadoop.apache.org/releases.html</a></p><p>下载地址：<a href="https://archive.apache.org/dist/hadoop/common/" target="_blank" rel="noopener">https://archive.apache.org/dist/hadoop/common/</a></p><ol start="2"><li>Cloudera Hadoop </li></ol><p>官网地址：<a href="https://www.cloudera.com/downloads/cdh/5-10-0.html" target="_blank" rel="noopener">https://www.cloudera.com/downloads/cdh/5-10-0.html</a></p><p>下载地址：<a href="http://archive-primary.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">http://archive-primary.cloudera.com/cdh5/cdh/5/</a></p><p>（1）2008年成立的Cloudera是最早将Hadoop商用的公司，为合作伙伴提供Hadoop的商用解决方案，主要是包括支持、咨询服务、培训。</p><p>（2）2009年Hadoop的创始人Doug Cutting也加盟Cloudera公司。Cloudera产品主要为CDH，Cloudera Manager，Cloudera Support</p><p>（3）CDH是Cloudera的Hadoop发行版，完全开源，比Apache Hadoop在兼容性，安全性，稳定性上有所增强。</p><p>（4）Cloudera Manager是集群的软件分发及管理监控平台，可以在几个小时内部署好一个Hadoop集群，并对集群的节点及服务进行实时监控。Cloudera Support即是对Hadoop的技术支持。</p><p>（5）Cloudera的标价为每年每个节点4000美元。Cloudera开发并贡献了可实时处理大数据的Impala项目。</p><ol start="3"><li>Hortonworks Hadoop</li></ol><p>官网地址：<a href="https://hortonworks.com/products/data-center/hdp/" target="_blank" rel="noopener">https://hortonworks.com/products/data-center/hdp/</a></p><p>下载地址：<a href="https://hortonworks.com/downloads/#data-platform" target="_blank" rel="noopener">https://hortonworks.com/downloads/#data-platform</a></p><p>（1）2011年成立的Hortonworks是雅虎与硅谷风投公司Benchmark Capital合资组建。</p><p>（2）公司成立之初就吸纳了大约25名至30名专门研究Hadoop的雅虎工程师，上述工程师均在2005年开始协助雅虎开发Hadoop，贡献了Hadoop80%的代码。</p><p>（3）雅虎工程副总裁、雅虎Hadoop开发团队负责人Eric Baldeschwieler出任Hortonworks的首席执行官。</p><p>（4）Hortonworks的主打产品是Hortonworks Data Platform（HDP），也同样是100%开源的产品，HDP除常见的项目外还包括了Ambari，一款开源的安装和管理系统。</p><p>（5）HCatalog，一个元数据管理系统，HCatalog现已集成到Facebook开源的Hive中。Hortonworks的Stinger开创性的极大的优化了Hive项目。Hortonworks为入门提供了一个非常好的，易于使用的沙盒。</p><p>（6）Hortonworks开发了很多增强特性并提交至核心主干，这使得Apache Hadoop能够在包括Window Server和Windows Azure在内的Microsoft Windows平台上本地运行。定价以集群为基础，每10个节点每年为12500美元。</p><h1 id="Hadoop的组成"><a href="#Hadoop的组成" class="headerlink" title="Hadoop的组成"></a>Hadoop的组成</h1><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop2.png" alt=""></p><h2 id="HDFS架构概述"><a href="#HDFS架构概述" class="headerlink" title="HDFS架构概述"></a>HDFS架构概述</h2><p>HDFS由NameNode、DataNode、SencodaryNode组成。</p><ul><li>NameNode：存储文件的元数据，如文件名，文件目录结构，文件属性(生成时间、副本数、文件权限)，以及每个文件的块列表和块所在的DataNode等。</li><li>DataNode：在本地文件系统存储文件块数据，以及块数据的校验和。</li><li>SecondaryNode：用于监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。</li></ul><h2 id="Yarn架构概述"><a href="#Yarn架构概述" class="headerlink" title="Yarn架构概述"></a>Yarn架构概述</h2><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop3.png" alt=""></p><h2 id="MapReduce架构概述"><a href="#MapReduce架构概述" class="headerlink" title="MapReduce架构概述"></a>MapReduce架构概述</h2><p>MapReduce将计算过程分为两个阶段：Map和Reduce</p><p>1）Map阶段并行处理输入数据</p><p>2）Reduce阶段对Map结果进行汇总</p><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop4.png" alt=""></p><h1 id="大数据生态体系"><a href="#大数据生态体系" class="headerlink" title="大数据生态体系"></a>大数据生态体系</h1><p>TODO</p><h1 id="推荐系统框架图"><a href="#推荐系统框架图" class="headerlink" title="推荐系统框架图"></a>推荐系统框架图</h1><p>TODO</p><h1 id="Hadoop运行环境搭建"><a href="#Hadoop运行环境搭建" class="headerlink" title="Hadoop运行环境搭建"></a>Hadoop运行环境搭建</h1><h2 id="安装JDK和安装Hadoop"><a href="#安装JDK和安装Hadoop" class="headerlink" title="安装JDK和安装Hadoop"></a>安装JDK和安装Hadoop</h2><p>1.解压jdk压缩包</p><p>2.解压Hadoop压缩包</p><p>3.配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/software/bigdata/jdk1.8</span><br><span class="line">export JRE_HOME=/opt/software/bigdata/jdk1.8/jre</span><br><span class="line">export HADOOP_HOME=/opt/software/bigdata/hadoop</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure><p>4.验证环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]# java -version</span><br><span class="line">java version "1.8.0_211"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]# hadoop version</span><br><span class="line">Hadoop 2.7.2</span><br><span class="line">Subversion Unknown -r Unknown</span><br><span class="line">Compiled by root on 2017-05-22T10:49Z</span><br><span class="line">Compiled with protoc 2.5.0</span><br><span class="line">From source with checksum d0fda26633fa762bff87ec759ebe689c</span><br><span class="line">This command was run using /opt/software/bigdata/hadoop/share/hadoop/common/hadoop-common-2.7.2.jar</span><br></pre></td></tr></table></figure><p>配置成功！</p><h2 id="Hadoop目录结构"><a href="#Hadoop目录结构" class="headerlink" title="Hadoop目录结构"></a>Hadoop目录结构</h2><p>1、查看Hadoop目录结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 hadoop-2.7.2]$ ll</span><br><span class="line">总用量 52</span><br><span class="line">drwxr-xr-x. 2 atguigu atguigu 4096 5月 22 2017 **bin**</span><br><span class="line">drwxr-xr-x. 3 atguigu atguigu 4096 5月 22 2017 **etc**</span><br><span class="line">drwxr-xr-x. 2 atguigu atguigu 4096 5月 22 2017 include</span><br><span class="line">drwxr-xr-x. 3 atguigu atguigu 4096 5月 22 2017 **lib**</span><br><span class="line">drwxr-xr-x. 2 atguigu atguigu 4096 5月 22 2017 libexec</span><br><span class="line">-rw-r--r--. 1 atguigu atguigu 15429 5月 22 2017 LICENSE.txt</span><br><span class="line">-rw-r--r--. 1 atguigu atguigu  101 5月 22 2017 NOTICE.txt</span><br><span class="line">-rw-r--r--. 1 atguigu atguigu 1366 5月 22 2017 README.txt</span><br><span class="line">drwxr-xr-x. 2 atguigu atguigu 4096 5月 22 2017 **sbin**</span><br><span class="line">drwxr-xr-x. 4 atguigu atguigu 4096 5月 22 2017 **share**</span><br></pre></td></tr></table></figure><p>2、重要目录</p><p>（1）bin目录：存放对Hadoop相关服务（HDFS,YARN）进行操作的脚本</p><p>（2）etc目录：Hadoop的配置文件目录，存放Hadoop的配置文件</p><p>（3）lib目录：存放Hadoop的本地库（对数据进行压缩解压缩功能）</p><p>（4）sbin目录：存放启动或停止Hadoop相关服务的脚本</p><p>（5）share目录：存放Hadoop的依赖jar包、文档、和官方案例</p><h1 id="Hadoop运行模式"><a href="#Hadoop运行模式" class="headerlink" title="Hadoop运行模式"></a>Hadoop运行模式</h1><p>Hadoop运行模式包括：本地模式、伪分布式模式以及完全分布式模式。</p><p>Hadoop官方网站：<a href="http://hadoop.apache.org/" target="_blank" rel="noopener">http://hadoop.apache.org/</a></p><h2 id="本地运行模式"><a href="#本地运行模式" class="headerlink" title="本地运行模式"></a>本地运行模式</h2><h3 id="官方Grep案例"><a href="#官方Grep案例" class="headerlink" title="官方Grep案例"></a>官方Grep案例</h3><ol><li>创建在hadoop-2.7.2文件下面创建一个input文件夹</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ mkdir input</span><br></pre></td></tr></table></figure><ol start="2"><li>将Hadoop的xml配置文件复制到input</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ cp etc/hadoop/*.xml input</span><br></pre></td></tr></table></figure><ol start="3"><li>执行share目录下的MapReduce程序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar grep input output 'dfs[a-z.]+'</span><br></pre></td></tr></table></figure><ol start="4"><li>查看输出结果</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ cat output/*</span><br></pre></td></tr></table></figure><h3 id="官方WordCount程序"><a href="#官方WordCount程序" class="headerlink" title="官方WordCount程序"></a>官方WordCount程序</h3><ol><li>创建在hadoop文件下面创建一个wcinput文件夹</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ mkdir wcinput</span><br></pre></td></tr></table></figure><ol start="2"><li>在wcinput文件下创建一个wc.input文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ cd wcinput</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ touch wc.input</span><br></pre></td></tr></table></figure><ol start="3"><li>编辑wc.input文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ vim wc.input</span><br><span class="line"></span><br><span class="line">hadoop yarn</span><br><span class="line">hadoop mapreduce</span><br><span class="line">root</span><br><span class="line">root</span><br></pre></td></tr></table></figure><ol start="4"><li>回到Hadoop目录，执行程序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount wcinput wcoutput</span><br></pre></td></tr></table></figure><ol start="6"><li>查看结果</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ cat wcoutput/part-r-00000</span><br><span class="line"></span><br><span class="line">root 2</span><br><span class="line">hadoop 2</span><br><span class="line">mapreduce    1</span><br><span class="line">yarn  1</span><br></pre></td></tr></table></figure><h2 id="伪分布式运行模式"><a href="#伪分布式运行模式" class="headerlink" title="伪分布式运行模式"></a>伪分布式运行模式</h2><h3 id="启动HDFS并运行MapReduce程序"><a href="#启动HDFS并运行MapReduce程序" class="headerlink" title="启动HDFS并运行MapReduce程序"></a>启动HDFS并运行MapReduce程序</h3><ol><li>分析</li></ol><p>​    （1）配置集群</p><p>​    （2）启动、测试集群增、删、查</p><p>​    （3）执行WordCount案例</p><ol start="2"><li>执行步骤</li></ol><p>（1）配置集群</p><p>​       （a）配置：hadoop-env.sh</p><p>​         Linux系统中获取JDK的安装路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# echo $JAVA_HOME</span><br><span class="line"></span><br><span class="line">/opt/module/jdk1.8.0_211</span><br></pre></td></tr></table></figure><p>​        修改hadoop-env.sh中的JAVA_HOME 路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_211</span><br></pre></td></tr></table></figure><p>（b）配置：core-site.xml</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定HDFS中NameNode的地址  --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop1:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 指定Hadoop运行时产生文件的存储目录  --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（c）配置：hdfs-site.xml</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  指定HDFS副本的数量 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）启动集群</p><p>​    （a）格式化<strong>NameNode</strong>（第一次启动时格式化，以后就不要总格式化）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><p>​    （b）启动NameNode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ sbin/hadoop-daemon.sh start namenode</span><br></pre></td></tr></table></figure><p>​    （c）启动DataNode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ sbin&#x2F;hadoop-daemon.sh start datanode</span><br></pre></td></tr></table></figure><p>（3）查看集群</p><p>​    （a）查看是否启动成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ jps</span><br><span class="line"></span><br><span class="line">13586 NameNode</span><br><span class="line">13668 DataNode</span><br><span class="line">13786 Jps</span><br></pre></td></tr></table></figure><p>​    （b）web端查看HDFS文件系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip:50070&#x2F;dfshealth.html#tab-overview</span><br></pre></td></tr></table></figure><p>​    （c）查看产生的Log日志</p><p>​        说明：在企业中遇到Bug时，经常根据日志提示信息去分析问题、解决Bug。</p><p>当前目录：hadoop/logs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 logs]$ ls</span><br><span class="line"></span><br><span class="line">hadoop-root-datanode-hadoop.root.com.log</span><br><span class="line">hadoop-root-datanode-hadoop.root.com.out</span><br><span class="line">hadoop-root-namenode-hadoop.root.com.log</span><br><span class="line">hadoop-root-namenode-hadoop.root.com.out</span><br><span class="line">SecurityAuth-root.audit</span><br><span class="line"></span><br><span class="line">[root@centos7 logs]$ cat hadoop-root-datanode-hadoop101.log</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ cd data/tmp/dfs/name/current/</span><br><span class="line"></span><br><span class="line">[root@centos7 current]$ cat VERSION</span><br><span class="line"></span><br><span class="line">**clusterID=CID-f0330a58-36fa-4a2a-a65f-2688269b5837**</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ cd data/tmp/dfs/data/current/</span><br><span class="line"></span><br><span class="line">**clusterID=CID-f0330a58-36fa-4a2a-a65f-2688269b5837**</span><br></pre></td></tr></table></figure><p>注意：格式化NameNode，会产生新的集群id,导致NameNode和DataNode的集群id不一致，集群找不到已往数据。所以，格式NameNode时，一定要先删除data数据和log日志，然后再格式化NameNode。</p><p>（4）操作集群</p><p>​       （a）在HDFS文件系统上<strong>创建</strong>一个input文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -mkdir -p /user/atguigu/input</span><br></pre></td></tr></table></figure><p>​       （b）将测试文件内容<strong>上传</strong>到文件系统上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$bin/hdfs dfs -put wcinput/wc.input</span><br><span class="line"></span><br><span class="line">/user/root/input/</span><br></pre></td></tr></table></figure><p>​       （c）<strong>查看</strong>上传的文件是否正确</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -ls /user/atguigu/input/</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -cat /user/atguigu/ input/wc.input</span><br></pre></td></tr></table></figure><p>​       （d）运行MapReduce程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/root/input/ /user/root/output</span><br></pre></td></tr></table></figure><p>​        （e）查看输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -cat /user/root/output/*</span><br></pre></td></tr></table></figure><p>浏览器查看，如图所示 查看output文件</p><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop5.png" alt=""></p><p>​       （f）将测试文件内容<strong>下载</strong>到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ hdfs dfs -get /user/atguigu/output/part-r-00000 ./wcoutput/</span><br></pre></td></tr></table></figure><p>​      （g）<strong>删除</strong>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ hdfs dfs -rm -r /user/atguigu/output</span><br></pre></td></tr></table></figure><h3 id="启动YARN并运行MapReduce程序"><a href="#启动YARN并运行MapReduce程序" class="headerlink" title="启动YARN并运行MapReduce程序"></a>启动YARN并运行MapReduce程序</h3><ol><li>分析</li></ol><p>​    （1）配置集群在YARN上运行MR</p><p>​    （2）启动、测试集群增、删、查</p><p>​    （3）在YARN上执行WordCount案例</p><ol start="2"><li>执行步骤    </li></ol><p>​    （1）配置集群</p><p>​       （a）配置yarn-env.sh.配置一下JAVA_HOME</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_211</span><br></pre></td></tr></table></figure><p>​        （b）配置yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Reducer获取数据的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定YARN的ResourceManager的地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop101<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​       （c）配置：mapred-env.sh.配置一下JAVA_HOME</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_144</span><br></pre></td></tr></table></figure><p>​       （d）配置： (对mapred-site.xml.template重新命名为) mapred-site.xml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ mv mapred-site.xml.template mapred-site.xml</span><br><span class="line">[root@centos7 hadoop]$ vim mapred-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定MR运行在YARN上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）启动集群</p><p>​    （a）启动前必须保证NameNode和DataNode已经启动</p><p>​    （b）启动ResourceManager</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ sbin/yarn-daemon.sh start resourcemanager</span><br></pre></td></tr></table></figure><p>​    （c）启动NodeManager</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ sbin/yarn-daemon.sh start nodemanager</span><br></pre></td></tr></table></figure><p>  （3）集群操作</p><p>​    （a）YARN的浏览器页面查看，如图所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip:8088&#x2F;cluster</span><br></pre></td></tr></table></figure><p> YARN的浏览器页面<img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop6.png" alt=""></p><p>​       （b）删除文件系统上的output文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -rm -R /user/atguigu/output</span><br></pre></td></tr></table></figure><p>​       （c）执行MapReduce程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/atguigu/input /user/atguigu/output</span><br></pre></td></tr></table></figure><p>​       （d）查看运行结果，如图所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -cat /user/atguigu/output/*</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop7.png" alt=""></p><h3 id="配置历史服务器"><a href="#配置历史服务器" class="headerlink" title="配置历史服务器"></a>配置历史服务器</h3><p>为了查看程序的历史运行情况，需要配置一下历史服务器。具体配置步骤如下：</p><ol><li>配置mapred-site.xml</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ vim mapred-site.xml</span><br></pre></td></tr></table></figure><p>在该文件里面增加如下配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 历史服务器端地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop101:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 历史服务器web端地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop101:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>启动历史服务器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ sbin&#x2F;mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure><ol start="3"><li>查看历史服务器是否启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$jps</span><br></pre></td></tr></table></figure><ol start="4"><li>查看JobHistory：<a href="http://ip:19888/jobgistory" target="_blank" rel="noopener">http://ip:19888/jobgistory</a></li></ol><h3 id="配置日志的聚集"><a href="#配置日志的聚集" class="headerlink" title="配置日志的聚集"></a>配置日志的聚集</h3><p>日志聚集概念：应用运行完成以后，将程序运行日志信息上传到HDFS系统上。</p><p>日志聚集功能好处：可以方便的查看到程序运行详情，方便开发调试。</p><p>注意：开启日志聚集功能，需要重新启动NodeManager 、ResourceManager和HistoryManager。</p><p>开启日志聚集功能具体步骤如下：</p><ol><li>配置yarn-site.xml</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ vi yarn-site.xml</span><br></pre></td></tr></table></figure><p>在该文件里面增加如下配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志聚集功能使能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 日志保留时间设置7天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>604800<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>关闭NodeManager 、ResourceManager和HistoryServer</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ sbin/yarn-daemon.sh stop resourcemanager</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ sbin/yarn-daemon.sh stop nodemanager</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ sbin/mr-jobhistory-daemon.sh stop historyserver</span><br></pre></td></tr></table></figure><ol start="3"><li>启动NodeManager 、ResourceManager和HistoryServer</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$]$ sbin/yarn-daemon.sh start resourcemanager</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ sbin/yarn-daemon.sh start nodemanager</span><br><span class="line"></span><br><span class="line">[root@centos7 hadoop]$ sbin/mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure><ol start="4"><li>删除HDFS上已经存在的输出文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ bin/hdfs dfs -rm -R /user/atguigu/output</span><br></pre></td></tr></table></figure><ol start="5"><li>执行WordCount程序</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 hadoop]$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/atguigu/input /user/atguigu/output</span><br></pre></td></tr></table></figure><ol start="6"><li>查看日志，如图所示</li></ol><p><a href="http://hadoop101:19888/jobhistory" target="_blank" rel="noopener">http://hadoop101:19888/jobhistory</a></p><p> Job History</p><p><img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop8.png" alt=""></p><p>job运行情况<img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop9.png" alt=""></p><p>查看日志<img src="https://gitee.com/maishuren/blog-pic/raw/master/hadoop/hadoop10.png" alt=""></p><h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><p>Hadoop配置文件分两类：默认配置文件和自定义配置文件，只有用户想修改某一默认配置值时，才需要修改自定义配置文件，更改相应属性值。</p><p>（1）默认配置文件：</p><table><thead><tr><th>要获取的默认文件</th><th>文件存放在Hadoop的jar包中的位置</th></tr></thead><tbody><tr><td>[core-default.xml]</td><td>hadoop-common-2.7.2.jar/  core-default.xml</td></tr><tr><td>[hdfs-default.xml]</td><td>hadoop-hdfs-2.7.2.jar/  hdfs-default.xml</td></tr><tr><td>[yarn-default.xml]</td><td>hadoop-yarn-common-2.7.2.jar/  yarn-default.xml</td></tr><tr><td>[mapred-default.xml]</td><td>hadoop-mapreduce-client-core-2.7.2.jar/  mapred-default.xml</td></tr></tbody></table><p>​    （2）自定义配置文件：</p><p>​    core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml四个配置文件存放在$HADOOP_HOME/etc/hadoop这个路径上，用户可以根据项目需求重新进行修改配置。</p><h2 id="完全分布式运行模式"><a href="#完全分布式运行模式" class="headerlink" title="完全分布式运行模式"></a>完全分布式运行模式</h2><p>TODO</p><h1 id="Hadoop编译源码"><a href="#Hadoop编译源码" class="headerlink" title="Hadoop编译源码"></a>Hadoop编译源码</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据" scheme="http://www.maishuren.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="hadoop" scheme="http://www.maishuren.top/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>golang学习八：切片</title>
    <link href="http://www.maishuren.top/posts/gloang/202006131039-index.html"/>
    <id>http://www.maishuren.top/posts/gloang/202006131039-index.html</id>
    <published>2020-06-13T02:39:26.000Z</published>
    <updated>2020-06-13T02:45:37.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><ul><li><p>切片的英文名称slice</p></li><li><p>切片:具有可变长度相同类型元素序列.</p></li><li><p>由于长度是可变,可以解决数组长度在数据个数不确定情况下浪费内存的问题.</p></li><li><p>切片和数组声明时语法最主要的区别就是长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">string</span>  <span class="comment">//切片</span></span><br><span class="line"><span class="keyword">var</span> array [<span class="number">3</span>]<span class="keyword">string</span> <span class="comment">//数组</span></span><br></pre></td></tr></table></figure></li><li><p>切片只声明时为nil,没有开辟内存空间,不能直接操作切片,需要先初始化</p><ul><li>注意:切片只能和nil进行判断是否相等<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">string</span>  <span class="comment">//切片</span></span><br><span class="line">fmt.Println(slice==<span class="literal">nil</span>)<span class="comment">//输出:true</span></span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>,slice)<span class="comment">//输出:0x0</span></span><br></pre></td></tr></table></figure><h1 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h1></li></ul></li><li><p>通过直接指定初始值定初始化一个切片变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names := []<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;</span><br><span class="line">fmt.Println(names)</span><br></pre></td></tr></table></figure></li><li><p>定义完切片后就可以通过<code>切片对象[脚标]</code>取出或修改切片中元素内容.语法和数组相同</p></li></ul><h1 id="切片是引用类型"><a href="#切片是引用类型" class="headerlink" title="切片是引用类型"></a>切片是引用类型</h1><ul><li>引用类型在变量之间赋值时传递的是地址.引用类型变量就是这个类型的指针.切片就是引用类型</li><li>值类型在变量之间赋值时传递的是值的副本<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names := []<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;</span><br><span class="line">names1 := names</span><br><span class="line">names1[<span class="number">0</span>] = <span class="string">"a"</span></span><br><span class="line">fmt.Println(names, names1)<span class="comment">//输出:[a world] [a world]</span></span><br><span class="line">fmt.Printf(<span class="string">"%p %p"</span>,names,names1)<span class="comment">//地址相同</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h1><ul><li><p>Go语言中可以使用make函数创建slice 、 map、 channel、 interface</p></li><li><p>使用make函数定义无内容,但是不是nil的切片,意味着切片已经申请了内存空间</p><ul><li><code>make(类型,初始长度[,初始容量])</code></li><li>初始容量可以省略,默认和长度相等<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)     <span class="comment">//长度为0的切片,没有第三个参数表示容量和长度相等</span></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="comment">//长度为0,容量为2</span></span><br><span class="line">fmt.Println(slice, slice1)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>长度表示切片中元素的实际个数,容量表示切片占用空间大小,且切片容量成倍增加.当增加到1024后按照一定百分比增加.</p><ul><li>len(slice) 查看切片的长度</li><li>cap(slice) 查看切片的容量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)     <span class="comment">//长度为0的切片,没有第三个参数表示容量和长度相等</span></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">3</span>) <span class="comment">//长度为0,容量为2</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice1), <span class="built_in">cap</span>(slice1))</span><br></pre></td></tr></table></figure><h1 id="append-函数"><a href="#append-函数" class="headerlink" title="append()函数"></a>append()函数</h1></li></ul></li><li><p>append()在Go语言标准库中源码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The append built-in function appends elements to the end of a slice. If</span></span><br><span class="line"><span class="comment">// it has sufficient capacity, the destination is resliced to accommodate the</span></span><br><span class="line"><span class="comment">// new elements. If it does not, a new underlying array will be allocated.</span></span><br><span class="line"><span class="comment">// Append returns the updated slice. It is therefore necessary to store the</span></span><br><span class="line"><span class="comment">// result of append, often in the variable holding the slice itself:</span></span><br><span class="line"><span class="comment">//slice = append(slice, elem1, elem2)</span></span><br><span class="line"><span class="comment">//slice = append(slice, anotherSlice...)</span></span><br><span class="line"><span class="comment">// As a special case, it is legal to append a string to a byte slice, like this:</span></span><br><span class="line"><span class="comment">//slice = append([]byte("hello "), "world"...)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span> []<span class="title">Type</span></span></span><br></pre></td></tr></table></figure></li><li><p>可以向切片中添加一个或多个值,添加后必须使用切片接收append()函数返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))<span class="comment">//输出:0 0</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"老张"</span>, <span class="string">"佳明哥"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))<span class="comment">//输出:2 2</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"smallming"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))<span class="comment">//输出:3 4</span></span><br></pre></td></tr></table></figure></li><li><p>如果添加一次添加多个值,且添加后的长度大于扩容一次的大小,容量和长度相等.等到下次添加内容时如果不超出扩容大小,在现在的基础上进行翻倍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//输出:0 0</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"老张"</span>, <span class="string">"佳明哥"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//输出:2 2</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"smallming"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//输出:3 4</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//输出:9 9</span></span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="string">"10"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//输出:10 18</span></span><br></pre></td></tr></table></figure></li><li><p>也可以把一个切片的内容直接添加到另一个切片中.需要注意语法中有三个点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">s1 := []<span class="keyword">string</span>&#123;<span class="string">"smallming"</span>, <span class="string">"佳明哥"</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, s1...) <span class="comment">//注意此处,必须有三个点</span></span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></table></figure></li></ul><h1 id="通过数组产生切片"><a href="#通过数组产生切片" class="headerlink" title="通过数组产生切片"></a>通过数组产生切片</h1><ul><li><p>定义数组后,取出数组中一个片段,这个片段就是切片类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"老张"</span>, <span class="string">"佳明哥"</span>, <span class="string">"smallming"</span>&#125;</span><br><span class="line">s := names[<span class="number">0</span>:<span class="number">2</span>]     <span class="comment">//包前不包后</span></span><br><span class="line">fmt.Printf(<span class="string">"%T"</span>, s) <span class="comment">//输出:[]string</span></span><br><span class="line">fmt.Println(s)      <span class="comment">//输出:[老张 佳明哥]</span></span><br></pre></td></tr></table></figure></li><li><p>切片是指针,指向数组元素地址,修改切片的内容,数组的内容会跟随变化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"老张"</span>, <span class="string">"佳明哥"</span>, <span class="string">"smallming"</span>&#125;</span><br><span class="line">s := names[<span class="number">0</span>:<span class="number">2</span>] <span class="comment">//包前不包后</span></span><br><span class="line">fmt.Printf(<span class="string">"%p %p"</span>,s,&amp;names[<span class="number">0</span>])<span class="comment">//输出的地址是相同的</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">"Go语言"</span></span><br><span class="line">fmt.Println(s)     <span class="comment">//输出:[Go语言 佳明哥]</span></span><br><span class="line">fmt.Println(names) <span class="comment">//输出:[Go语言 佳明哥 smallming]</span></span><br></pre></td></tr></table></figure></li><li><p>当切片内容在增加时</p><ul><li>如果增加后切片的长度没有超出数组,修改切片也是在修改数组</li><li>如果增加后切片的长度超出数组,会重新开辟一块空间放切片的内容</li><li>通过下面代码也正面了切片中内容存在一块连续空间(和数组一样)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">names := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"老张"</span>, <span class="string">"佳明哥"</span>, <span class="string">"smallming"</span>&#125;</span><br><span class="line">s := names[<span class="number">0</span>:<span class="number">2</span>] <span class="comment">//包前不包后</span></span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>,s,&amp;names[<span class="number">0</span>])</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">"Go语言"</span></span><br><span class="line">s=<span class="built_in">append</span>(s,<span class="string">"区块链"</span>)</span><br><span class="line">fmt.Println(s)     <span class="comment">//输出:[Go语言 佳明哥 区块链]</span></span><br><span class="line">fmt.Println(names) <span class="comment">//输出:[Go语言 佳明哥 区块链]</span></span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>,s,&amp;names[<span class="number">0</span>])<span class="comment">//地址相同</span></span><br><span class="line"></span><br><span class="line">s=<span class="built_in">append</span>(s,<span class="string">"超出了数组长度"</span>)</span><br><span class="line">fmt.Println(s)     <span class="comment">//输出:[Go语言 佳明哥 区块链 超出了数组长度]</span></span><br><span class="line">fmt.Println(names) <span class="comment">//输出:[Go语言 佳明哥 区块链]</span></span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>,s,&amp;names[<span class="number">0</span>])<span class="comment">//切片地址改变</span></span><br></pre></td></tr></table></figure><h1 id="删除实现"><a href="#删除实现" class="headerlink" title="删除实现"></a>删除实现</h1></li></ul></li><li><p>Go语言标准库中没有提供删除的函数</p></li><li><p>切片也可以取其中的一段形成子切片,利用这个特性可以实现删除效果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num := []<span class="keyword">int</span> &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">//要删除脚标为n的元素</span></span><br><span class="line">n:= <span class="number">2</span></span><br><span class="line">num1 :=num[<span class="number">0</span>:n]</span><br><span class="line">num1= <span class="built_in">append</span>(num1,num[n+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(num1)</span><br></pre></td></tr></table></figure></li></ul><h1 id="copy函数"><a href="#copy函数" class="headerlink" title="copy函数"></a>copy函数</h1><ul><li>通过copy函数可以把一个切片内容复制到另一个切片中</li><li>Go语言标准库源码定义如下<ul><li>第一个参数是目标切片,接收第二个参数内容</li><li>第二个参数是源切片,把内容拷贝到第一个参数中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The copy built-in function copies elements from a source slice into a</span></span><br><span class="line"><span class="comment">// destination slice. (As a special case, it also will copy bytes from a</span></span><br><span class="line"><span class="comment">// string to a slice of bytes.) The source and destination may overlap. Copy</span></span><br><span class="line"><span class="comment">// returns the number of elements copied, which will be the minimum of</span></span><br><span class="line"><span class="comment">// len(src) and len(dst).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(dst, src []Type)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li>拷贝时严格按照脚标进行拷贝.且不会对目标切片进行扩容</li></ul><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><ul><li>把短切片拷贝到长切片中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1:=[]<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">s2:=[]<span class="keyword">int</span> &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s2,s1)</span><br><span class="line">fmt.Println(s1)<span class="comment">//输出:[1 2]</span></span><br><span class="line">fmt.Println(s2)<span class="comment">//输出:[1 2 5 6]</span></span><br></pre></td></tr></table></figure></li><li>把长切片拷贝到短切片中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1:=[]<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">s2:=[]<span class="keyword">int</span> &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s1,s2)</span><br><span class="line">fmt.Println(s1)<span class="comment">//输出:[3 4]</span></span><br><span class="line">fmt.Println(s2)<span class="comment">//输出:[3 4 5 6]</span></span><br></pre></td></tr></table></figure></li><li>把切片片段拷贝到切片中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1:=[]<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">s2:=[]<span class="keyword">int</span> &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s1,s2[<span class="number">1</span>:])</span><br><span class="line">fmt.Println(s1)<span class="comment">//输出:[4 5]</span></span><br><span class="line">fmt.Println(s2)<span class="comment">//输出:[3 4 5 6]</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="使用copy完成删除元素"><a href="#使用copy完成删除元素" class="headerlink" title="使用copy完成删除元素"></a>使用copy完成删除元素</h1><ul><li>使用copy函数可以保证原切片内容不变<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">n := <span class="number">2</span> <span class="comment">//要删除元素的索引</span></span><br><span class="line">newSlice := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line"><span class="built_in">copy</span>(newSlice, s[<span class="number">0</span>:n])</span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, s[n+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(s)        <span class="comment">//原切片不变</span></span><br><span class="line">fmt.Println(newSlice) <span class="comment">//删除指定元素后的切片</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="后端" scheme="http://www.maishuren.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://www.maishuren.top/tags/golang/"/>
    
      <category term="入门" scheme="http://www.maishuren.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
